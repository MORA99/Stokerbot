
Nyt.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000448  00800100  0000869c  00008730  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000869c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001dab  00800548  00800548  00008b78  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00008b78  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000006e0  00000000  00000000  00008bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000b473  00000000  00000000  000092b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000026d7  00000000  00000000  00014727  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002d7a  00000000  00000000  00016dfe  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001a98  00000000  00000000  00019b78  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000172d  00000000  00000000  0001b610  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000a0df  00000000  00000000  0001cd3d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000770  00000000  00000000  00026e1c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#include "twi.h"
#include "I2CEEPROM.h"
#include <avr/pgmspace.h>

uint8_t IEP_readbyte(uint16_t address)
{
       0:	0c 94 a2 0b 	jmp	0x1744	; 0x1744 <__ctors_end>
       4:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
       8:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
  uint8_t ioBuffer[ 2 ];
  uint8_t rc;

  ioBuffer[ 0 ] = (address & 0xFF00) >> 8;
  ioBuffer[ 1 ] = (address & 0x00FF);
       c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>

  rc = twiWrite( EEPROM_ADDRESS, ioBuffer, 2 );
      10:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      14:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      18:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>

  if ( rc != 0 )
      1c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
  {
    //fprintf(stdout, twiWriteErrorFmt);
    return -1;
  }

  rc = twiRead( EEPROM_ADDRESS, (uint8_t *) &ioBuffer, 2 );  //2 bytes returned MSB first, D11-D4 + D3-D0 (padded with 0000)
      20:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      24:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      28:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      2c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
  if ( rc != 0 )
      30:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
  {
    printf_P(PSTR("Error read byte"));
      34:	0c 94 95 24 	jmp	0x492a	; 0x492a <__vector_13>
      38:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      3c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
    return -1;
      40:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
  } // end if

  //Parse result
  return ioBuffer[0];
      44:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
  rc = twiWrite( EEPROM_ADDRESS, ioBuffer, 2 );

  if ( rc != 0 )
  {
    //fprintf(stdout, twiWriteErrorFmt);
    return -1;
      48:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
    return -1;
  } // end if

  //Parse result
  return ioBuffer[0];
}
      4c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      50:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      54:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      58:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      5c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      60:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      64:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      68:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      6c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      70:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      74:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      78:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      7c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      80:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      84:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>
      88:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__bad_interrupt>

0000008c <__trampolines_end>:
      8c:	0d 0a       	sbc	r0, r29
      8e:	43 6f       	ori	r20, 0xF3	; 243
      90:	6e 74       	andi	r22, 0x4E	; 78
      92:	65 6e       	ori	r22, 0xE5	; 229
      94:	74 2d       	mov	r23, r4
      96:	54 79       	andi	r21, 0x94	; 148
      98:	70 65       	ori	r23, 0x50	; 80
      9a:	3a 20       	and	r3, r10
      9c:	61 70       	andi	r22, 0x01	; 1
      9e:	70 6c       	ori	r23, 0xC0	; 192
      a0:	69 63       	ori	r22, 0x39	; 57
      a2:	61 74       	andi	r22, 0x41	; 65
      a4:	69 6f       	ori	r22, 0xF9	; 249
      a6:	6e 2f       	mov	r22, r30
      a8:	78 2d       	mov	r23, r8
      aa:	77 77       	andi	r23, 0x77	; 119
      ac:	77 2d       	mov	r23, r7
      ae:	66 6f       	ori	r22, 0xF6	; 246
      b0:	72 6d       	ori	r23, 0xD2	; 210
      b2:	2d 75       	andi	r18, 0x5D	; 93
      b4:	72 6c       	ori	r23, 0xC2	; 194
      b6:	65 6e       	ori	r22, 0xE5	; 229
      b8:	63 6f       	ori	r22, 0xF3	; 243
      ba:	64 65       	ori	r22, 0x54	; 84
      bc:	64 0d       	add	r22, r4
      be:	0a 0d       	add	r16, r10
      c0:	0a 00       	.word	0x000a	; ????

000000c2 <__c.2852>:
      c2:	43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a 20     Content-Length: 
	...

000000d3 <__c.2850>:
      d3:	0d 0a 55 73 65 72 2d 41 67 65 6e 74 3a 20 53 42     ..User-Agent: SB
      e3:	4e 47 2f 31 2e 31 0d 0a 41 63 63 65 70 74 3a 20     NG/1.1..Accept: 
      f3:	2a 2f 2a 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a     */*..Connection:
     103:	20 63 6c 6f 73 65 0d 0a 00                           close...

0000010c <__c.2848>:
     10c:	0d 0a 00                                            ...

0000010f <__c.2846>:
     10f:	20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a      HTTP/1.1..Host:
     11f:	20 00                                                .

00000121 <__c.2844>:
     121:	50 4f 53 54 20 00                                   POST .

00000127 <__c.2842>:
     127:	0d 0a 55 73 65 72 2d 41 67 65 6e 74 3a 20 53 42     ..User-Agent: SB
     137:	4e 47 2f 31 2e 30 0d 0a 41 63 63 65 70 74 3a 20     NG/1.0..Accept: 
     147:	74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f 6e 6e 65     text/html..Conne
     157:	63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a     ction: close....
	...

00000168 <__c.2840>:
     168:	20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a      HTTP/1.1..Host:
     178:	20 00                                                .

0000017a <__c.2838>:
     17a:	47 45 54 20 00                                      GET .

0000017f <iphdr>:
     17f:	45 00 00 82 00 00 40 00 20                          E.....@. 

00000188 <arpreqhdr>:
     188:	00 01 08 00 06 04 00 01                             ........

00000190 <__c.2721>:
     190:	4e 6f 20 73 79 73 74 65 6d 20 69 64 20 66 6f 75     No system id fou
     1a0:	6e 64 2c 20 61 64 64 20 61 20 44 53 32 34 30 31     nd, add a DS2401
     1b0:	20 6f 72 20 75 73 65 20 6f 6c 64 20 73 6f 66 74      or use old soft
     1c0:	77 61 72 65 20 2a 2a 2a 00                          ware ***.

000001c9 <__c.2716>:
     1c9:	46 6f 75 6e 64 20 73 79 73 74 65 6d 20 69 64 20     Found system id 
     1d9:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     1e9:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     1f9:	0d 0a 00                                            ...

000001fc <__c.2703>:
     1fc:	53 65 74 74 69 6e 67 20 64 65 66 61 75 6c 74 20     Setting default 
     20c:	76 61 6c 75 65 73 0d 0a 00                          values...

00000215 <__c.2701>:
     215:	53 74 6f 6b 65 72 62 6f 74 20 53 33 20 2d 20 46     Stokerbot S3 - F
     225:	69 72 6d 77 61 72 65 20 25 75 2e 25 75 20 72 65     irmware %u.%u re
     235:	61 64 79 0d 0a 00                                   ady...

0000023b <__c.2699>:
     23b:	53 74 6f 6b 65 72 62 6f 74 20 53 33 20 2d 20 46     Stokerbot S3 - F
     24b:	69 72 6d 77 61 72 65 20 25 75 2e 25 75 20 62 6f     irmware %u.%u bo
     25b:	6f 74 69 6e 67 0d 0a 00                             oting...

00000263 <__c.2195>:
     263:	43 52 43 20 45 72 72 6f 72 20 28 6c 6f 73 74 20     CRC Error (lost 
     273:	63 6f 6e 6e 65 63 74 69 6f 6e 3f 29 00              connection?).

00000280 <__c.2188>:
     280:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     290:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     2a0:	20 25 63 25 64 2e 25 30 34 64 00                     %c%d.%04d.

000002ab <__c.3035>:
     2ab:	67 6f 74 20 72 65 70 6c 79 20 2e 2e 2e 0d 0a 00     got reply ......

000002bb <__c.3005>:
     2bb:	67 6f 74 20 6c 63 64 20 72 65 70 6c 79 20 2e 2e     got lcd reply ..
     2cb:	2e 0d 0a 00                                         ....

000002cf <__c.2974>:
     2cf:	48 54 54 50 2f 31 2e 30 20 34 30 31 20 55 6e 61     HTTP/1.0 401 Una
     2df:	75 74 68 6f 72 69 7a 65 64 0d 0a 43 6f 6e 74 65     uthorized..Conte
     2ef:	6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f 68 74     nt-Type: text/ht
     2ff:	6d 6c 0d 0a 0d 0a 3c 68 31 3e 34 30 31 20 55 6e     ml....<h1>401 Un
     30f:	61 75 74 68 6f 72 69 7a 65 64 3c 2f 68 31 3e 00     authorized</h1>.

0000031f <__c.2972>:
     31f:	2f 65 78 70 6f 72 74 2e 68 74 6d 00                 /export.htm.

0000032b <__c.2970>:
     32b:	2f 73 74 79 6c 65 2e 63 73 73 00                    /style.css.

00000336 <__c.2968>:
     336:	2f 61 6c 69 73 74 2e 6a 73 00                       /alist.js.

00000340 <__c.2966>:
     340:	2f 73 6c 69 73 74 2e 6a 73 00                       /slist.js.

0000034a <__c.2964>:
     34a:	2f 6c 6f 61 64 65 72 2e 6a 73 00                    /loader.js.

00000355 <__c.2962>:
     355:	2f 61 6c 61 72 6d 73 2e 6a 73 00                    /alarms.js.

00000360 <__c.2960>:
     360:	2f 66 6d 75 32 2e 6a 73 00                          /fmu2.js.

00000369 <__c.2958>:
     369:	2f 66 6d 75 2e 6a 73 00                             /fmu.js.

00000371 <__c.2953>:
     371:	45 25 75 00                                         E%u.

00000375 <__c.2951>:
     375:	52 25 75 00                                         R%u.

00000379 <__c.2949>:
     379:	50 25 75 00                                         P%u.

0000037d <__c.2947>:
     37d:	44 25 75 00                                         D%u.

00000381 <__c.2945>:
     381:	56 25 75 00                                         V%u.

00000385 <__c.2943>:
     385:	54 25 75 00                                         T%u.

00000389 <__c.2934>:
     389:	53 25 75 00                                         S%u.

0000038d <__c.2930>:
     38d:	2f 73 65 74 74 69 6e 67 73 2f 61 6c 61 72 6d 00     /settings/alarm.

0000039d <__c.2926>:
     39d:	2f 73 65 74 74 69 6e 67 73 2f 6e 65 74 00           /settings/net.

000003ab <__c.2913>:
     3ab:	44 25 75 00                                         D%u.

000003af <__c.2907>:
     3af:	41 44 43 25 75 00                                   ADC%u.

000003b5 <__c.2903>:
     3b5:	2f 73 65 74 74 69 6e 67 73 2f 69 6f 00              /settings/io.

000003c2 <__c.2899>:
     3c2:	2f 73 65 74 74 69 6e 67 73 2f 67 65 6e 65 72 61     /settings/genera
     3d2:	6c 00                                               l.

000003d4 <__c.2896>:
     3d4:	3c 68 31 3e 32 30 30 20 4f 4b 3c 2f 68 31 3e 00     <h1>200 OK</h1>.

000003e4 <__c.2892>:
     3e4:	2f 67 65 74 4c 43 44 2e 70 68 70 00                 /getLCD.php.

000003f0 <__c.2894>:
     3f0:	73 74 6f 6b 65 72 6c 6f 67 2e 64 6b 00              stokerlog.dk.

000003fd <__c.2890>:
     3fd:	3f 69 64 3d 25 30 32 58 25 30 32 58 25 30 32 58     ?id=%02X%02X%02X
     40d:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     41d:	25 30 32 58 00                                      %02X.

00000422 <__c.2887>:
     422:	53 74 61 72 74 69 6e 67 20 6c 63 64 20 72 65 71     Starting lcd req
     432:	75 65 73 74 20 0d 0a 00                             uest ...

0000043a <__c.2883>:
     43a:	2f 69 6e 63 6f 6d 69 6e 67 2e 70 68 70 3f 76 3d     /incoming.php?v=
     44a:	31 00                                               1.

0000044c <__c.2885>:
     44c:	73 74 6f 6b 65 72 6c 6f 67 2e 64 6b 00              stokerlog.dk.

00000459 <__c.2881>:
     459:	26 69 64 3d 25 30 32 58 25 30 32 58 25 30 32 58     &id=%02X%02X%02X
     469:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     479:	25 30 32 58 00                                      %02X.

0000047e <__c.2877>:
     47e:	53 74 61 72 74 69 6e 67 20 77 65 62 63 6c 69 65     Starting webclie
     48e:	6e 74 20 72 65 71 75 65 73 74 20 0d 0a 00           nt request ...

0000049c <__c.2875>:
     49c:	52 65 74 72 79 20 64 6e 73 20 6c 6f 6f 6b 75 70     Retry dns lookup
     4ac:	20 2e 2e 2e 20 0d 0a 00                              ... ...

000004b4 <__c.2873>:
     4b4:	47 6f 74 20 64 6e 73 20 72 65 70 6c 79 20 3a 20     Got dns reply : 
     4c4:	25 64 2e 25 64 2e 25 64 2e 25 64 20 0d 0a 00        %d.%d.%d.%d ...

000004d3 <__c.2871>:
     4d3:	73 74 6f 6b 65 72 6c 6f 67 2e 64 6b 00              stokerlog.dk.

000004e0 <__c.2869>:
     4e0:	52 65 71 75 65 73 74 20 44 4e 53 20 6c 6f 6f 6b     Request DNS look
     4f0:	75 70 0d 0a 00                                      up...

000004f5 <__c.2858>:
     4f5:	26 44 25 64 54 3d 25 67 26 44 25 64 48 3d 25 67     &D%dT=%g&D%dH=%g
	...

00000506 <__c.2854>:
     506:	26 44 25 64 54 3d 25 67 26 44 25 64 48 3d 25 67     &D%dT=%g&D%dH=%g
	...

00000517 <__c.2846>:
     517:	26 25 30 32 58 25 30 32 58 25 30 32 58 25 30 32     &%02X%02X%02X%02
     527:	58 25 30 32 58 25 30 32 58 25 30 32 58 25 30 32     X%02X%02X%02X%02
     537:	58 3d 25 63 25 64 2e 25 30 34 64 00                 X=%c%d.%04d.

00000543 <__c.2839>:
     543:	26 44 25 75 3d 25 75 00                             &D%u=%u.

0000054b <__c.2833>:
     54b:	26 41 44 43 25 75 3d 25 75 00                       &ADC%u=%u.

00000555 <__c.2820>:
     555:	41 75 74 68 6f 72 69 7a 61 74 69 6f 6e 00           Authorization.

00000563 <__c.2817>:
     563:	62 75 66 20 3d 20 25 73 20 0d 0a 00                 buf = %s ...

0000056f <__c.2791>:
     56f:	50 6c 65 6e 20 69 73 20 25 64 20 0d 0a 00           Plen is %d ...

0000057d <__c.2789>:
     57d:	64 77 28 27 3c 2f 74 61 62 6c 65 3e 27 29 3b 66     dw('</table>');f
     58d:	6f 72 6d 65 6e 64 28 29 3b 3c 2f 73 63 72 69 70     ormend();</scrip
     59d:	74 3e 00                                            t>.

000005a0 <__c.2784>:
     5a0:	64 70 6f 72 74 28 25 64 2c 20 27 44 25 64 27 2c     dport(%d, 'D%d',
     5b0:	20 25 64 29 3b 00                                    %d);.

000005b6 <__c.2778>:
     5b6:	61 64 63 73 65 74 28 25 64 2c 20 27 41 44 43 25     adcset(%d, 'ADC%
     5c6:	64 27 2c 20 25 64 29 3b 00                          d', %d);.

000005cf <__c.2775>:
     5cf:	3c 53 43 52 49 50 54 20 53 52 43 3d 27 2f 6c 6f     <SCRIPT SRC='/lo
     5df:	61 64 65 72 2e 6a 73 27 3e 3c 2f 53 43 52 49 50     ader.js'></SCRIP
     5ef:	54 3e 3c 73 63 72 69 70 74 3e 6d 65 6e 75 28 32     T><script>menu(2
     5ff:	2c 31 29 3b 66 6f 72 6d 73 74 61 72 74 28 27 2f     ,1);formstart('/
     60f:	73 65 74 74 69 6e 67 73 2f 69 6f 27 29 3b 74 66     settings/io');tf
     61f:	68 28 27 69 6f 27 2c 27 31 27 2c 30 29 3b 64 77     h('io','1',0);dw
     62f:	28 27 3c 74 61 62 6c 65 20 62 6f 72 64 65 72 3d     ('<table border=
     63f:	30 3e 27 29 3b 00                                   0>');.

00000645 <__c.2769>:
     645:	50 6c 65 6e 20 69 73 20 25 64 20 0d 0a 00           Plen is %d ...

00000653 <__c.2767>:
     653:	64 77 28 27 4d 41 53 4b 3a 20 27 29 3b 74 66 28     dw('MASK: ');tf(
     663:	27 4d 41 53 4b 30 27 2c 20 25 64 2c 20 32 29 3b     'MASK0', %d, 2);
     673:	74 66 28 27 4d 41 53 4b 31 27 2c 20 25 64 2c 20     tf('MASK1', %d, 
     683:	32 29 3b 74 66 28 27 4d 41 53 4b 32 27 2c 20 25     2);tf('MASK2', %
     693:	64 2c 20 32 29 3b 74 66 28 27 4d 41 53 4b 33 27     d, 2);tf('MASK3'
     6a3:	2c 20 25 64 2c 20 32 29 3b 66 6f 72 6d 65 6e 64     , %d, 2);formend
     6b3:	28 29 3b 3c 2f 73 63 72 69 70 74 3e 3c 62 72 3e     ();</script><br>
	...

000006c4 <__c.2765>:
     6c4:	64 77 28 27 44 4e 53 3a 20 27 29 3b 74 66 28 27     dw('DNS: ');tf('
     6d4:	44 4e 53 30 27 2c 20 25 64 2c 20 32 29 3b 74 66     DNS0', %d, 2);tf
     6e4:	28 27 44 4e 53 31 27 2c 20 25 64 2c 20 32 29 3b     ('DNS1', %d, 2);
     6f4:	74 66 28 27 44 4e 53 32 27 2c 20 25 64 2c 20 32     tf('DNS2', %d, 2
     704:	29 3b 74 66 28 27 44 4e 53 33 27 2c 20 25 64 2c     );tf('DNS3', %d,
     714:	20 32 29 3b 64 77 28 27 3c 62 72 3e 27 29 3b 00      2);dw('<br>');.

00000724 <__c.2763>:
     724:	64 77 28 27 47 57 20 3a 20 27 29 3b 74 66 28 27     dw('GW : ');tf('
     734:	47 57 30 27 2c 20 25 64 2c 20 32 29 3b 74 66 28     GW0', %d, 2);tf(
     744:	27 47 57 31 27 2c 20 25 64 2c 20 32 29 3b 74 66     'GW1', %d, 2);tf
     754:	28 27 47 57 32 27 2c 20 25 64 2c 20 32 29 3b 74     ('GW2', %d, 2);t
     764:	66 28 27 47 57 33 27 2c 20 25 64 2c 20 32 29 3b     f('GW3', %d, 2);
     774:	64 77 28 27 3c 62 72 3e 27 29 3b 00                 dw('<br>');.

00000780 <__c.2761>:
     780:	64 77 28 27 49 50 20 3a 20 27 29 3b 74 66 28 27     dw('IP : ');tf('
     790:	49 50 30 27 2c 20 25 64 2c 20 32 29 3b 74 66 28     IP0', %d, 2);tf(
     7a0:	27 49 50 31 27 2c 20 25 64 2c 20 32 29 3b 74 66     'IP1', %d, 2);tf
     7b0:	28 27 49 50 32 27 2c 20 25 64 2c 20 32 29 3b 74     ('IP2', %d, 2);t
     7c0:	66 28 27 49 50 33 27 2c 20 25 64 2c 20 32 29 3b     f('IP3', %d, 2);
     7d0:	64 77 28 27 3c 62 72 3e 27 29 3b 00                 dw('<br>');.

000007dc <__c.2759>:
     7dc:	3c 53 43 52 49 50 54 20 53 52 43 3d 27 2f 6c 6f     <SCRIPT SRC='/lo
     7ec:	61 64 65 72 2e 6a 73 27 3e 3c 2f 53 43 52 49 50     ader.js'></SCRIP
     7fc:	54 3e 3c 73 63 72 69 70 74 3e 6d 65 6e 75 28 32     T><script>menu(2
     80c:	2c 31 29 3b 66 6f 72 6d 73 74 61 72 74 28 27 2f     ,1);formstart('/
     81c:	73 65 74 74 69 6e 67 73 2f 6e 65 74 27 29 3b 00     settings/net');.

0000082c <__c.2753>:
     82c:	50 6c 65 6e 20 69 73 20 25 64 20 0d 0a 00           Plen is %d ...

0000083a <__c.2751>:
     83a:	66 6f 72 6d 65 6e 64 28 29 3b 3c 2f 73 63 72 69     formend();</scri
     84a:	70 74 3e 3c 62 72 3e 00                             pt><br>.

00000852 <__c.2749>:
     852:	64 77 28 27 4c 43 44 20 3a 20 27 29 3b 63 62 28     dw('LCD : ');cb(
     862:	27 4c 43 44 27 2c 20 27 25 75 27 2c 20 31 29 3b     'LCD', '%u', 1);
     872:	64 77 28 27 3c 62 72 3e 27 29 3b 00                 dw('<br>');.

0000087e <__c.2746>:
     87e:	64 77 28 27 50 61 73 73 77 6f 72 64 20 3a 20 27     dw('Password : '
     88e:	29 3b 74 66 28 27 50 41 53 53 27 2c 20 27 25 73     );tf('PASS', '%s
     89e:	27 2c 20 31 30 29 3b 64 77 28 27 3c 62 72 3e 27     ', 10);dw('<br>'
     8ae:	29 3b 00                                            );.

000008b1 <__c.2743>:
     8b1:	3c 53 43 52 49 50 54 20 53 52 43 3d 27 2f 6c 6f     <SCRIPT SRC='/lo
     8c1:	61 64 65 72 2e 6a 73 27 3e 3c 2f 53 43 52 49 50     ader.js'></SCRIP
     8d1:	54 3e 3c 73 63 72 69 70 74 3e 6d 65 6e 75 28 32     T><script>menu(2
     8e1:	2c 31 29 3b 66 6f 72 6d 73 74 61 72 74 28 27 2f     ,1);formstart('/
     8f1:	73 65 74 74 69 6e 67 73 2f 67 65 6e 65 72 61 6c     settings/general
     901:	27 29 3b 00                                         ');.

00000905 <__c.2734>:
     905:	61 6c 61 72 6d 73 5b 25 75 5d 20 3d 20 5b 25 75     alarms[%u] = [%u
     915:	2c 20 27 25 75 27 2c 27 25 69 27 2c 27 25 75 27     , '%u','%i','%u'
     925:	2c 27 25 75 27 2c 27 25 75 27 2c 27 25 75 27 5d     ,'%u','%u','%u']
     935:	3b 00                                               ;.

00000937 <__c.2729>:
     937:	76 61 72 20 61 6c 61 72 6d 73 20 3d 20 6e 65 77     var alarms = new
     947:	20 41 72 72 61 79 28 29 3b 00                        Array();.

00000951 <__c.2723>:
     951:	5d 3b 00                                            ];.

00000954 <__c.2718>:
     954:	5b 25 75 2c 20 27 25 30 32 58 25 30 32 58 25 30     [%u, '%02X%02X%0
     964:	32 58 25 30 32 58 25 30 32 58 25 30 32 58 25 30     2X%02X%02X%02X%0
     974:	32 58 25 30 32 58 27 2c 20 27 25 63 25 64 2e 25     2X%02X', '%c%d.%
     984:	30 34 64 27 5d 00                                   04d'].

0000098a <__c.2714>:
     98a:	76 61 72 20 73 65 6e 73 6f 72 73 3d 5b 00           var sensors=[.

00000998 <__c.2707>:
     998:	50 6c 65 6e 20 69 73 20 25 64 20 0d 0a 00           Plen is %d ...

000009a6 <__c.2705>:
     9a6:	3c 2f 70 72 65 3e 3c 73 63 72 69 70 74 3e 66 6f     </pre><script>fo
     9b6:	72 20 28 69 3d 30 3b 20 69 20 3c 20 73 65 6e 73     r (i=0; i < sens
     9c6:	6f 72 73 2e 6c 65 6e 67 74 68 3b 20 69 2b 2b 29     ors.length; i++)
     9d6:	20 7b 20 64 77 28 73 65 6e 73 6f 72 73 5b 69 5d      { dw(sensors[i]
     9e6:	5b 31 5d 2b 27 20 3d 20 27 2b 73 65 6e 73 6f 72     [1]+' = '+sensor
     9f6:	73 5b 69 5d 5b 32 5d 2b 27 3c 62 72 3e 27 29 3b     s[i][2]+'<br>');
     a06:	20 7d 3c 2f 73 63 72 69 70 74 3e 00                  }</script>.

00000a12 <__c.2703>:
     a12:	0a 4e 75 6d 62 65 72 20 73 75 63 63 65 73 73 66     .Number successf
     a22:	75 6c 20 64 61 74 61 20 75 70 6c 6f 61 64 73 20     ul data uploads 
     a32:	3a 20 00                                            : .

00000a35 <__c.2701>:
     a35:	0a 4e 75 6d 62 65 72 20 6f 66 20 64 61 74 61 20     .Number of data 
     a45:	75 70 6c 6f 61 64 73 20 3a 20 00                    uploads : .

00000a50 <__c.2699>:
     a50:	0a 55 70 74 69 6d 65 3a 20 25 75 64 61 79 73 20     .Uptime: %udays 
     a60:	25 75 68 6f 75 72 73 20 25 75 6d 69 6e 75 74 65     %uhours %uminute
     a70:	73 20 25 75 73 65 63 6f 6e 64 73 0a 00              s %useconds..

00000a7d <__c.2683>:
     a7d:	0a 77 61 69 74 69 6e 67 20 66 6f 72 20 44 4e 53     .waiting for DNS
     a8d:	20 61 6e 73 77 65 72 2e 0a 00                        answer...

00000a97 <__c.2681>:
     a97:	0a 77 61 69 74 69 6e 67 20 66 6f 72 20 47 57 20     .waiting for GW 
     aa7:	49 50 20 74 6f 20 61 6e 73 77 65 72 20 61 72 70     IP to answer arp
     ab7:	2e 0a 00                                            ...

00000aba <__c.2679>:
     aba:	0a 53 79 73 74 65 6d 49 44 3a 20 25 30 32 58 25     .SystemID: %02X%
     aca:	30 32 58 25 30 32 58 25 30 32 58 25 30 32 58 25     02X%02X%02X%02X%
     ada:	30 32 58 25 30 32 58 25 30 32 58 0a 00              02X%02X%02X..

00000ae7 <__c.2677>:
     ae7:	3c 53 43 52 49 50 54 3e 6d 65 6e 75 28 32 2c 31     <SCRIPT>menu(2,1
     af7:	29 3b 3c 2f 53 43 52 49 50 54 3e 3c 50 52 45 3e     );</SCRIPT><PRE>
	...

00000b08 <__c.2675>:
     b08:	3c 53 43 52 49 50 54 20 53 52 43 3d 27 2f 6c 6f     <SCRIPT SRC='/lo
     b18:	61 64 65 72 2e 6a 73 3f 25 75 27 3e 3c 2f 53 43     ader.js?%u'></SC
     b28:	52 49 50 54 3e 00                                   RIPT>.

00000b2e <__c.2666>:
     b2e:	44 25 64 54 20 25 67 0d 0a 44 25 64 48 20 25 67     D%dT %g..D%dH %g
     b3e:	0d 0a 00                                            ...

00000b41 <__c.2662>:
     b41:	44 25 64 54 20 25 67 0d 0a 44 25 64 48 20 25 67     D%dT %g..D%dH %g
     b51:	0d 0a 00                                            ...

00000b54 <__c.2654>:
     b54:	4f 50 25 75 20 25 75 0d 0a 00                       OP%u %u...

00000b5e <__c.2648>:
     b5e:	52 4c 25 75 20 25 75 0d 0a 00                       RL%u %u...

00000b68 <__c.2642>:
     b68:	44 25 75 20 25 75 0d 0a 00                          D%u %u...

00000b71 <__c.2636>:
     b71:	41 25 75 20 25 75 0d 0a 00                          A%u %u...

00000b7a <__c.2630>:
     b7a:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     b8a:	25 30 32 58 25 30 32 58 25 30 32 58 25 30 32 58     %02X%02X%02X%02X
     b9a:	20 25 63 25 64 2e 25 30 34 64 0d 0a 00               %c%d.%04d...

00000ba7 <__c.2622>:
     ba7:	48 54 54 50 2f 31 2e 30 20 34 30 31 20 41 75 74     HTTP/1.0 401 Aut
     bb7:	68 6f 72 69 7a 61 74 69 6f 6e 20 52 65 71 75 69     horization Requi
     bc7:	72 65 64 0d 0a 57 57 57 2d 41 75 74 68 65 6e 74     red..WWW-Authent
     bd7:	69 63 61 74 65 3a 20 42 61 73 69 63 20 72 65 61     icate: Basic rea
     be7:	6c 6d 3d 22 53 74 6f 6b 65 72 62 6f 74 20 61 64     lm="Stokerbot ad
     bf7:	6d 69 6e 22 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79     min"..Content-Ty
     c07:	70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 50     pe: text/html..P
     c17:	72 61 67 6d 61 3a 20 6e 6f 2d 63 61 63 68 65 0d     ragma: no-cache.
     c27:	0a 0d 0a 00                                         ....

00000c2b <__c.2617>:
     c2b:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     c3b:	0a 43 6f 6e 74 65 6e 74 2d 45 6e 63 6f 64 69 6e     .Content-Encodin
     c4b:	67 3a 20 67 7a 69 70 0d 0a 43 6f 6e 74 65 6e 74     g: gzip..Content
     c5b:	2d 54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d 6c     -Type: text/html
     c6b:	0d 0a 50 72 61 67 6d 61 3a 20 6e 6f 2d 63 61 63     ..Pragma: no-cac
     c7b:	68 65 0d 0a 0d 0a 00                                he.....

00000c82 <__c.2612>:
     c82:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     c92:	0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74     .Content-Type: t
     ca2:	65 78 74 2f 68 74 6d 6c 0d 0a 50 72 61 67 6d 61     ext/html..Pragma
     cb2:	3a 20 6e 6f 2d 63 61 63 68 65 0d 0a 0d 0a 00        : no-cache.....

00000cc1 <style_css>:
     cc1:	1f 8b 08 00 00 00 00 00 00 03 c5 56 4d 8f db 36     ...........VM..6
     cd1:	10 bd 1b f0 7f 18 78 0f 4e d2 d8 6b cb 6b af 23     ......x.N..k.k.#
     ce1:	9f 72 c8 16 05 ba 45 d1 6d d1 33 25 8e 24 26 34     .r....E.m.3%.$&4
     cf1:	29 88 b4 bd 9b 45 ff 7b 87 d4 87 65 5b 76 37 0d     )....E.{...e[v7.
     d01:	92 48 80 2d 91 c3 99 37 ef 71 86 8a 34 7f 02 78     .H.-...7.q..4..x
     d11:	ee f7 00 22 16 7f 4a 0b bd 51 3c 84 ab 0f ef ee     ..."..J..Q<.....
     d21:	82 bb c5 ca 8d af 59 91 0a 15 c2 c4 bf 59 7c b4     ......Y......Y|.
     d31:	23 26 45 4a 23 31 2a 8b c5 0a e0 fa 0d dc 3f fc     #&EJ#1*.......?.
     d41:	f2 01 e6 c0 35 1a 35 b4 d5 14 f9 34 c8 41 2b 60     ....5.5....4.A+`
     d51:	1b ab 41 62 62 af 0b 91 66 b6 72 6a de 3a 97 e7     ..Abb...f.rj.:..
     d61:	ae 68 63 61 d8 8a 57 fa 1c fa 18 75 00 ab f3 91     .hca..W....u....
     d71:	c4 2d 4a e0 62 6b 42 78 73 ed 21 0b 35 da 09 6e     .-J.bkBxs.!.5..n
     d81:	b3 10 a6 93 c9 24 7f 5c 95 1e 09 e7 43 8e b1 48     .....$.\....C..H
     d91:	9e 80 ed 8d 20 d1 e4 28 43 88 1c 19 cc 00 8d a2     .... ..(C.......
     da1:	fb 77 63 c3 5d c1 f2 9c c2 5e 42 0a 28 71 4d 80     .wc.]....^B.(qM.
     db1:	40 58 83 32 19 c3 9f 99 30 90 17 04 4c 59 03 0a     @X.2....0...LY..
     dc1:	53 66 c5 16 e1 95 18 e3 18 84 62 71 8c c6 88 48     Sf........bq...H
     dd1:	e2 eb 8b 6e 1d 61 a3 8a 2a 5a 06 8a 15 85 de 41     ...n.a..*Z.....A
     de1:	44 3f 86 92 df 09 c5 e9 09 76 19 2a d8 18 a1 d2     D?.......v.*....
     df1:	8b de 7e 63 5b 41 40 28 d9 c5 4f d7 f7 fa b3 90     ..~c[A@(..O.....
     e01:	92 39 6d fe 16 6a 16 94 d4 fd d3 ef f5 7b 57 b1     .9m..j.......{W.
     e11:	56 96 09 45 11 9e 8f 25 77 88 56 15 95 7f a0 41     V..E...%w.V....A
     e21:	0b 7e c2 27 4f 0a c7 7a 9d a3 32 cc a2 27 b5 43     .~.'O..z..2..'.C
     e31:	bd 5a a2 2e 79 0e 04 72 e4 97 f2 e8 c4 bf 54 1c     .Z..y..r......T.
     e41:	57 e4 9a 4c 6f 24 87 08 fd 9c 61 6b bc 94 3b 89     W..Lo$....ak..;.
     e51:	39 f4 ea 36 a2 37 40 4a 7a 47 2e b1 d0 6f d3 55     9..6.7@JzG...o.U
     e61:	85 83 72 73 83 c0 14 87 83 4d eb 12 75 86 6f 29     ..rs.....M..u.o)
     e71:	f4 a6 de 89 44 be 43 72 09 44 b3 49 94 c7 5c b1     ....D.Cr.D.I..\.
     e81:	ec 16 be 72 d8 5e 83 65 e9 11 2a 1f b7 82 55 ab     ...r.^.e..*...U.
     e91:	93 21 e3 4e 1a 28 63 e5 8c 73 f2 11 c2 6c 9e 3f     .!.N.(c..s...l.?
     ea1:	c2 8c d8 84 fa 61 55 5a 1c 14 f6 2c ba 5d 2c 6f     .....aUZ...,.],o
     eb1:	ab 99 0c 4b ff d3 c9 de 3a d6 52 17 64 78 e7 af     ...K....:.R.dx..
     ec1:	6a d0 eb c8 31 d6 05 6d 64 4d fb 40 69 85 d5 5c     j...1..mdM.@i..\
     ed1:	42 79 8c 8c f8 8c 61 3b a8 1f 4d d8 5a c8 a7 10     By....a;..M.Z...
     ee1:	06 f7 4f 85 60 1c 7e 2f f4 c0 e5 01 ed 44 58 b9     ..O.`.~/.....DX.
     ef1:	cb be 2e f2 74 f9 b2 c8 3e 30 a9 b0 99 d6 51 f7     ....t...>0....Q.
     f01:	ec 8c 6a 00 07 1c 35 fc 2e 6a 7a dd c3 a4 0e 26     ..j...5..jz....&
     f11:	35 b3 55 59 1c ba 3f 49 2b 9e f3 05 8f be 30 ad     5.UY..?I+.....0.
     f21:	9b 2f 4e 8b 85 99 de d6 a5 bb 8f 8e 71 12 24 b3     ./N.........q.$.
     f31:	03 db e0 db 52 10 fc 20 0a 82 17 52 20 d6 2c c5     ....R.. ...R .,.
     f41:	48 3f 7e 33 16 fa bd 71 5e e8 8f 18 db 3a 44 75     H?~3...q^....:Du
     f51:	94 4e 5d 81 4e 20 98 57 eb bd 75 36 3d b2 82 d3     .N].N .W..u6=...
     f61:	9a 5c 2e de 2d 6f 66 27 1c 05 e7 28 7a 4f 0c 49     .\..-of'...(zO.I
     f71:	ea fb ee d4 18 b4 2d 76 55 e1 2b 5d ac 99 6c 20     ......-vU.+]..l 
     f81:	04 c7 94 1d 10 d0 16 65 de 44 ac d1 06 13 9f d4     .......e.D......
     f91:	61 4e b3 17 3b 0c 4e 1c 96 fe 26 6d 7f 57 6b 6a     aN..;.N...&m.Wkj
     fa1:	98 17 f4 6a 3a 47 d5 61 dc 16 6b 1a 65 e3 b7 bc     ...j:G.a..k.e...
     fb1:	9b 78 8d ae 5e 0f 9f 46 f3 74 c4 ff 8d bf 3a a9     .x..^..F.t....:.
     fc1:	fe 19 35 b9 67 83 8e d4 66 8d 1f 49 87 ea a8 69     ..5.g...f..I...i
     fd1:	ba fb 96 d5 3e 61 3f 6e 8c a5 f3 ef 28 09 76 91     ....>a?n....(.v.
     fe1:	c8 73 a5 e4 49 3b 59 7a 90 c5 c5 a5 e3 48 a4 84     .s..I;Yz.....H..
     ff1:	f9 d3 ff 0a 7e 5a c7 fb fe 50 e6 d4 5d a6 0d bc     ....~Z...P..]...
    1001:	d2 34 d1 da ee 8d ba 8b f0 dc 61 47 dd 86 ee 4e     .4........aG...N
    1011:	bd 7e dd c4 82 33 78 60 74 9e ff a5 44 ac 39 0e     .~...3x`t...D.9.
    1021:	fe 53 ed 2a 93 69 a7 70 fe ac 3e 86 dd 90 7f 89     .S.*.i.p..>.....
    1031:	a5 3a 60 b0 70 f7 89 8b 6e 9a 16 fe 6a 94 32 98     .:`.p...n...j.2.
    1041:	b3 c2 7f dc 3d 1f 03 6e e1 2d 17 b7 ea c4 af 8d     ....=..n.-......
    1051:	25 b2 bd 7f f7 12 46 da 66 f5 7c 22 50 72 fa d4     %.....F.f.|"Pr..
    1061:	eb f7 ea ca d3 05 1d dc 44 04 51 6f b4 14 bc b5     ........D.Qo....
    1071:	23 fc 0a 89 29 2a de d8 77 b6 ff f3 5f 25 1d ee     #...)*..w..._%..
    1081:	6f 97 d3 d9 7c 7a 52 b0 a5 fc 75 1a 42 25 9a fa     o...|zR...u.B%..
    1091:	f9 77 0e 6b dd 67 cc 51 cc 73 6d ae 6a 9b e5 3a     .w.k.g.Q.sm.j..:
    10a1:	27 ef d9 75 de e4 5f 44 45 07 30 9d 0d 00 00 25     '..u.._DE.0....%
    10b1:	45 4e 44                                            END

000010b4 <loader_js>:
    10b4:	1f 8b 08 00 00 00 00 00 00 03 65 8f 41 0e 82 30     ..........e.A..0
    10c4:	14 44 f7 9e a2 e9 a6 10 13 9a e8 12 cb 49 dc 34     .D...........I.4
    10d4:	f5 13 8a a5 60 ff af 42 8c 77 b7 84 18 15 b6 6f     ....`..B.w.....o
    10e4:	26 93 37 75 f4 86 6c ef 59 80 5b b4 01 32 9d 3f     &.7u..l.Y.[..2.?
    10f4:	2f bd 89 1d 78 2a 1e c1 12 64 e2 84 26 d8 81 18     /...x*...d..&...
    1104:	4d 03 28 4e 30 92 6c f5 5d 2f 94 33 0c 46 71 b1     M.(N0.l.]/.3.Fq.
    1114:	d7 7b c1 ab f3 78 34 72 09 2a 91 bf 3e a3 5c d6     .{...x4r.*..>.\.
    1124:	5d 2c 5a e4 79 f9 87 0e 6b a6 9d 45 da 42 1d 3a     ],Z.y...k..E.B.:
    1134:	5c 53 fc 56 37 c2 ce fa 6b 7a e4 14 47 9a 1c 60     \S.V7...kz..G..`
    1144:	03 90 44 7f fc 0d 22 67 4d 80 5a a5 a1 b9 52 cc     ..D..."gM.Z...R.
    1154:	44 26 e7 72 f7 06 f2 64 7b 58 13 01 00 00 25 45     D&.r...d{X....%E
    1164:	4e 44                                               ND

00001166 <fmu2_js>:
    1166:	1f 8b 08 00 00 00 00 00 00 03 8d 91 3d 6f c2 30     ............=o.0
    1176:	10 86 77 7e 85 e5 81 c4 0a 10 28 a3 9d 48 55 d5     ..w~......(..HU.
    1186:	af a5 1d d2 0d 31 5c 92 cb 87 48 7c c8 36 65 40     .....1\...H|.6e@
    1196:	fc f7 da 88 b6 8c 0c 3e eb 5e dd 73 f7 9e dd 1c     .......>.^.s....
    11a6:	74 e5 7a d2 ac 21 33 5a 07 c6 c5 20 4e f5 31 8e     t.z..!3Z... N.1.
    11b6:	54 50 d8 88 ae a3 3a e3 af cf 5f 9c c1 a5 34 e3     TP....:..._...4.
    11c6:	51 02 49 c4 f3 48 9c 9b 5f dc 5a 1c b0 f2 f0 ac     Q.I..H.._.Z.....
    11d6:	9c 55 e2 e4 33 eb 1b c9 55 96 55 d3 29 ed 5d cc     .U..3...U.U.).].
    11e6:	f9 8c cf fd 79 ea 88 2c 32 d2 c8 85 f4 23 62 c8     ....y..,2....#b.
    11f6:	96 12 94 45 6d c9 d8 c5 80 ba 75 9d 84 24 11 81     ...Em.....u..$..
    1206:	ba ca 1b d8 6e 96 5b df fa 26 5f 6d 85 0c 43 63     ....n.[..&_m..Cc
    1216:	71 9e fc d9 18 51 1f 82 87 eb 0a 75 ff cd 7a ef     q....Q.....u..z.
    1226:	be 43 a8 d1 f0 bc 70 b4 43 53 92 63 c5 9a cd d9     .C....p.CS.c....
    1236:	4b 6f c6 23 18 64 0f 8b d5 5a 95 26 57 c0 3a 83     Ko.#.d...Z.&W.:.
    1246:	4d c6 53 9e bf d1 88 2a 85 7c aa 4b bb 97 b7 f1     M.S....*.|.K....
    1256:	bf ca a2 73 bd 6e 6d da a2 46 03 83 c7 8a ab a4     ...s.nm..F......
    1266:	ee 24 35 3a 4f 7d a0 3b 92 d9 dd 3d af 27 0f bd     .$5:O}.;...=.'..
    1276:	a7 9f 77 03 30 80 19 3d f3 18 6e 1b 30 95 fa d7     ..w.0..=..n.0...
    1286:	c9 2f 5b 57 a8 1d 9a f0 9f 72 f2 03 4d 79 36 cd     ./[W.....r..My6.
    1296:	11 02 00 00 25 45 4e 44                             ....%END

0000129e <fmu_js>:
    129e:	1f 8b 08 00 00 00 00 00 00 03 bd 54 c1 4e c3 30     ...........T.N.0
    12ae:	0c bd ef 2b 2a 5f da aa 13 63 03 2e ac 2b 42 e3     ...+*_...c...+B.
    12be:	00 27 24 e0 07 d2 24 dd 22 b6 74 4a 5d 36 98 f8     .'$...$.".tJ]6..
    12ce:	77 e2 a4 db da 31 21 c4 01 a9 87 d8 7e 7e f6 7b     w....1!.....~~.{
    12de:	51 5a d4 9a a3 2a 75 20 d6 11 8b b7 a2 e4 f5 52     QZ...*u .......R
    12ee:	6a 3c 5b 1b 85 d2 66 3e 8b 1d a0 88 58 3f ef f3     j<[...f>....X?..
    12fe:	be b0 a8 75 14 a6 4a af 6a 0c f0 7d 25 27 10 26     ...u..J.j..}%'.&
    130e:	2c 09 21 d0 6c e9 82 9c 02 25 f6 c7 37 b6 a8 5d     ,.!.l....%..7..]
    131e:	81 53 54 a9 0f 39 09 13 91 40 06 2d 7e 6c 06 c4     .ST..9...@.-~l..
    132e:	db 22 02 94 1b 84 be 8f db 90 79 0b 33 57 42 48     ."........y.3WBH
    133e:	fd 1d 55 94 c6 4a 10 91 db 13 d2 dc d8 31 63 8b     ..U..J.......1c.
    134e:	af ea 7c a9 2c 2b d8 ef 99 bd 49 3a c5 63 87 19     ..|.,+....I:.c..
    135e:	50 4f 67 9b 72 85 bb 51 4e ad 8d 29 bd 57 e2 f4     POg.r..QN..).W..
    136e:	86 89 aa 9e e5 42 72 94 82 d0 31 49 b2 22 2d a1     .....Br...1I."-.
    137e:	c7 13 65 6f cf c9 04 af 64 9b 16 52 34 59 8a 22     ..eo....d..R4Y."
    138e:	bb d5 6c 51 ce 02 6f 29 58 72 70 c6 a6 03 5b a3     ..lQ..o)Xrp...[.
    139e:	ba df 33 4c 2b 37 ac e3 73 16 c6 63 5a 76 68 af     ..3L+7..s..cZvh.
    13ae:	06 6e ef a6 e0 c3 11 85 77 6a a6 90 2d 9a d4 05     .n......wj..-...
    13be:	a5 a6 65 ad 51 9a bd 70 cf 98 f9 49 03 34 1d 13     ..e.Q..p...I.4..
    13ce:	54 35 9d 4b fe 4a e2 e2 ad 91 58 1b 1d 9c a7 ec     T5.K.J....X.....
    13de:	06 02 ee f3 01 5c 03 9c c0 3f 39 37 76 2d 6c 32     .....\...?97v-l2
    13ee:	c9 7f e8 e9 38 78 d4 53 35 35 df 74 b0 52 ac 4a     ....8x.S55.t.R.J
    13fe:	73 d2 c9 46 72 40 f5 3f 3a 79 4e 3e 3d d6 68 ef     s..Fr@.?:yN>=.h.
    140e:	a2 6d e6 83 3e 24 8e ac a4 d4 a5 33 fc fe 65 34     .m..>$.....3..e4
    141e:	6a 12 57 4d 62 38 fc 9d d9 b6 58 b9 27 78 62 3d     j.WMb8....X.'xb=
    142e:	e6 d7 eb 80 65 03 3e f0 fe f7 d5 f1 bc f3 44 da     ....e.>.......D.
    143e:	3f 04 d7 90 97 1b e8 48 68 fe 09 74 a4 a7 b3 db     ?......Hh..t....
    144e:	d0 be 9b b0 fb 8f 20 ad e3 de 17 0e ed 38 a0 9c     ...... ......8..
    145e:	04 00 00 25 45 4e 44                                ...%END

00001465 <alarms_js>:
    1465:	1f 8b 08 00 00 00 00 00 00 03 75 92 5f 0b 82 30     ..........u._..0
    1475:	14 c5 df fd 14 71 9f 26 09 ea b4 5e b4 20 28 2a     .....q.&...^. (*
    1485:	08 8a 8a 7a 10 1f 96 ce 0a 4c c3 2d 7a 88 be 7b     ...z.....L.-z..{
    1495:	f3 5f 34 d3 c7 9d f3 bb bb e7 b0 45 8f 24 e0 d7     ._4........E.$..
    14a5:	34 e9 b1 4b fa 9c c4 24 bb 21 a2 be a2 34 bb 31     4..K...$.!...4.1
    14b5:	4e 32 8e 40 67 94 f3 6b 72 66 3a c9 5d 50 9d f0     N2.@g..krf:.]P..
    14c5:	89 c0 e5 d9 d8 e5 e1 58 1c 19 a3 31 0d 04 b9 83     .......X...1....
    14d5:	3e d1 0a 88 79 c4 f7 0c 5f 33 2b 58 17 64 4d d3     >...y..._3+X.dM.
    14e5:	98 21 d8 0b 54 75 d2 bb 98 32 e1 67 c6 f4 35 70     .!..Tu...2.g..5p
    14f5:	a1 72 70 d3 19 d5 8e d5 74 aa 9b 29 fa 5f c8 23     .rp.....t..)._.#
    1505:	04 07 39 19 f6 35 dc 95 6c fa 4d 66 fe 4c 58 45     ..9..5..l.Mf.LXE
    1515:	97 5c c5 b2 8a 4b d5 92 55 ab 54 6d 59 b5 3b 33     .\...K..U.TmY.;3
    1525:	96 ab 37 ad ab 6d 51 6f b1 9c 2f aa ee 46 c3 5a     ..7..mQo../..F.Z
    1535:	ad 8f dd dd 83 13 82 ad dc 7d 50 34 51 da c8 99     .........}P4Q...
    1545:	4c 0e 5b df 2f ff 19 34 09 a5 65 ba f8 0c a0 be     L.[./..4..e.....
    1555:	1d e5 03 ee 46 9b 8b 4d 02 00 00 25 45 4e 44        ....F..M...%END

00001564 <alarms_htm>:
    1564:	1f 8b 08 00 00 00 00 00 00 03 5d 90 cf 0b 82 30     ..........]....0
    1574:	14 c7 cf ed af d8 4d c5 68 d8 29 70 0e 42 3a 74     ......M.h.)p.B:t
    1584:	2a 54 ba 4f b7 b0 50 27 6f 9b d2 7f 9f ba 4a e8     *T.O..P'o.....J.
    1594:	f0 e0 7d be ef f7 a3 79 9a 9d af 05 ce b3 34 f1     ..}....y......4.
    15a4:	48 a3 b8 90 b0 7b 6a 8f 51 e2 22 0c 51 5d c1 a3     H....{j.Q.".Q]..
    15b4:	37 0c b5 b2 b3 fe 7e 1b 05 31 42 62 f4 3d 6a 78     7.....~..1Bb.=jx
    15c4:	d9 48 5c 2a 98 8a 92 88 79 53 c0 e9 b5 e4 82 51     .H\*....yS.....Q
    15d4:	03 93 09 96 2b 0b 95 a4 c4 88 05 8b 57 bf c2 8d     ....+.......W...
    15e4:	37 76 a5 8b 35 bd 35 7f 88 b5 e1 66 cd c9 e4 20     7v..5.5....f... 
    15f4:	41 af 7c ea e6 25 1c 92 79 22 71 d3 e7 65 ee 0a     A.|..%..y"q..e..
    1604:	b0 3f 70 c0 bc e1 d0 26 51 ec 1c 9a 1c 3e 5e 18     .?p....&Q....>^.
    1614:	06 68 a3 6b 35 1e 67 f2 17 ed 77 1d 59 ce 5b 1a     .h.k5.g...w.Y.[.
    1624:	21 4a be 4f 78 03 e5 b9 85 93 31 01 00 00 25 45     !J.Ox.....1...%E
    1634:	4e 44                                               ND

00001636 <__c.2161>:
    1636:	6e 61 6e 00                                         nan.

0000163a <__c.2159>:
    163a:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
    164a:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
    165a:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
    166a:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
    167a:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
    168a:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
    169a:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
    16aa:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
    16ba:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
    16ca:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
    16da:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
    16ea:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
    16fa:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
    170a:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
    171a:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
    172a:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00001738 <__c.2299>:
    1738:	63 64 69 6e 6f 70 73 75 78 58 5b 00                 cdinopsuxX[.

00001744 <__ctors_end>:
    1744:	11 24       	eor	r1, r1
    1746:	1f be       	out	0x3f, r1	; 63
    1748:	cf ef       	ldi	r28, 0xFF	; 255
    174a:	d0 e4       	ldi	r29, 0x40	; 64
    174c:	de bf       	out	0x3e, r29	; 62
    174e:	cd bf       	out	0x3d, r28	; 61

00001750 <__do_copy_data>:
    1750:	15 e0       	ldi	r17, 0x05	; 5
    1752:	a0 e0       	ldi	r26, 0x00	; 0
    1754:	b1 e0       	ldi	r27, 0x01	; 1
    1756:	ec e9       	ldi	r30, 0x9C	; 156
    1758:	f6 e8       	ldi	r31, 0x86	; 134
    175a:	00 e0       	ldi	r16, 0x00	; 0
    175c:	0b bf       	out	0x3b, r16	; 59
    175e:	02 c0       	rjmp	.+4      	; 0x1764 <__do_copy_data+0x14>
    1760:	07 90       	elpm	r0, Z+
    1762:	0d 92       	st	X+, r0
    1764:	a8 34       	cpi	r26, 0x48	; 72
    1766:	b1 07       	cpc	r27, r17
    1768:	d9 f7       	brne	.-10     	; 0x1760 <__do_copy_data+0x10>

0000176a <__do_clear_bss>:
    176a:	22 e2       	ldi	r18, 0x22	; 34
    176c:	a8 e4       	ldi	r26, 0x48	; 72
    176e:	b5 e0       	ldi	r27, 0x05	; 5
    1770:	01 c0       	rjmp	.+2      	; 0x1774 <.do_clear_bss_start>

00001772 <.do_clear_bss_loop>:
    1772:	1d 92       	st	X+, r1

00001774 <.do_clear_bss_start>:
    1774:	a3 3f       	cpi	r26, 0xF3	; 243
    1776:	b2 07       	cpc	r27, r18
    1778:	e1 f7       	brne	.-8      	; 0x1772 <.do_clear_bss_loop>
    177a:	0e 94 dd 19 	call	0x33ba	; 0x33ba <main>
    177e:	0c 94 4c 43 	jmp	0x8698	; 0x8698 <_exit>

00001782 <__bad_interrupt>:
    1782:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001786 <dht_getdata>:
uint16_t rawtemperature;

/*
 * get data from sensor
 */
int8_t dht_getdata(uint8_t syspin, int16_t *temperature, int16_t *humidity, bool dht22) {
    1786:	8f 92       	push	r8
    1788:	9f 92       	push	r9
    178a:	af 92       	push	r10
    178c:	bf 92       	push	r11
    178e:	cf 92       	push	r12
    1790:	df 92       	push	r13
    1792:	ef 92       	push	r14
    1794:	ff 92       	push	r15
    1796:	0f 93       	push	r16
    1798:	1f 93       	push	r17
    179a:	cf 93       	push	r28
    179c:	df 93       	push	r29
    179e:	00 d0       	rcall	.+0      	; 0x17a0 <dht_getdata+0x1a>
    17a0:	00 d0       	rcall	.+0      	; 0x17a2 <dht_getdata+0x1c>
    17a2:	1f 92       	push	r1
    17a4:	cd b7       	in	r28, 0x3d	; 61
    17a6:	de b7       	in	r29, 0x3e	; 62
    17a8:	8b 01       	movw	r16, r22
    17aa:	7a 01       	movw	r14, r20
    17ac:	92 2e       	mov	r9, r18
	uint8_t bits[5];
	uint8_t i,j = 0;

	memset(bits, 0, sizeof(bits));
    17ae:	fe 01       	movw	r30, r28
    17b0:	31 96       	adiw	r30, 0x01	; 1
    17b2:	95 e0       	ldi	r25, 0x05	; 5
    17b4:	df 01       	movw	r26, r30
    17b6:	1d 92       	st	X+, r1
    17b8:	9a 95       	dec	r25
    17ba:	e9 f7       	brne	.-6      	; 0x17b6 <dht_getdata+0x30>

	//reset port
	DHT_DDR |= (1<<syspin); //output
    17bc:	97 b1       	in	r25, 0x07	; 7
    17be:	e1 e0       	ldi	r30, 0x01	; 1
    17c0:	f0 e0       	ldi	r31, 0x00	; 0
    17c2:	08 2e       	mov	r0, r24
    17c4:	02 c0       	rjmp	.+4      	; 0x17ca <dht_getdata+0x44>
    17c6:	ee 0f       	add	r30, r30
    17c8:	ff 1f       	adc	r31, r31
    17ca:	0a 94       	dec	r0
    17cc:	e2 f7       	brpl	.-8      	; 0x17c6 <dht_getdata+0x40>
    17ce:	9e 2b       	or	r25, r30
    17d0:	97 b9       	out	0x07, r25	; 7
	DHT_PORT |= (1<<syspin); //high
    17d2:	98 b1       	in	r25, 0x08	; 8
    17d4:	9e 2b       	or	r25, r30
    17d6:	98 b9       	out	0x08, r25	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17d8:	bf ef       	ldi	r27, 0xFF	; 255
    17da:	20 e7       	ldi	r18, 0x70	; 112
    17dc:	32 e0       	ldi	r19, 0x02	; 2
    17de:	b1 50       	subi	r27, 0x01	; 1
    17e0:	20 40       	sbci	r18, 0x00	; 0
    17e2:	30 40       	sbci	r19, 0x00	; 0
    17e4:	e1 f7       	brne	.-8      	; 0x17de <dht_getdata+0x58>
    17e6:	00 c0       	rjmp	.+0      	; 0x17e8 <dht_getdata+0x62>
    17e8:	00 00       	nop
	_delay_ms(100);

	//send request
	DHT_PORT &= ~(1<<syspin); //low
    17ea:	98 b1       	in	r25, 0x08	; 8
    17ec:	2e 2f       	mov	r18, r30
    17ee:	20 95       	com	r18
    17f0:	92 23       	and	r25, r18
    17f2:	98 b9       	out	0x08, r25	; 8
	if (!dht22)
    17f4:	91 10       	cpse	r9, r1
    17f6:	05 c0       	rjmp	.+10     	; 0x1802 <dht_getdata+0x7c>
    17f8:	af e9       	ldi	r26, 0x9F	; 159
    17fa:	bc e8       	ldi	r27, 0x8C	; 140
    17fc:	11 97       	sbiw	r26, 0x01	; 1
    17fe:	f1 f7       	brne	.-4      	; 0x17fc <dht_getdata+0x76>
    1800:	04 c0       	rjmp	.+8      	; 0x180a <dht_getdata+0x84>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1802:	a7 ee       	ldi	r26, 0xE7	; 231
    1804:	b3 e0       	ldi	r27, 0x03	; 3
    1806:	11 97       	sbiw	r26, 0x01	; 1
    1808:	f1 f7       	brne	.-4      	; 0x1806 <dht_getdata+0x80>
    180a:	00 c0       	rjmp	.+0      	; 0x180c <dht_getdata+0x86>
    180c:	00 00       	nop
		_delay_ms(18);
	else
		_delay_us(500);

	DHT_PORT |= (1<<syspin); //high
    180e:	98 b1       	in	r25, 0x08	; 8
    1810:	9e 2b       	or	r25, r30
    1812:	98 b9       	out	0x08, r25	; 8
	DHT_DDR &= ~(1<<syspin); //input
    1814:	97 b1       	in	r25, 0x07	; 7
    1816:	92 23       	and	r25, r18
    1818:	97 b9       	out	0x07, r25	; 7
    181a:	ba e6       	ldi	r27, 0x6A	; 106
    181c:	ba 95       	dec	r27
    181e:	f1 f7       	brne	.-4      	; 0x181c <dht_getdata+0x96>
    1820:	00 c0       	rjmp	.+0      	; 0x1822 <dht_getdata+0x9c>
	_delay_us(40);

	//check start condition 1
	if((DHT_PIN & (1<<syspin))) {
    1822:	26 b1       	in	r18, 0x06	; 6
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	08 2e       	mov	r0, r24
    1828:	02 c0       	rjmp	.+4      	; 0x182e <dht_getdata+0xa8>
    182a:	35 95       	asr	r19
    182c:	27 95       	ror	r18
    182e:	0a 94       	dec	r0
    1830:	e2 f7       	brpl	.-8      	; 0x182a <dht_getdata+0xa4>
    1832:	20 fd       	sbrc	r18, 0
    1834:	99 c0       	rjmp	.+306    	; 0x1968 <dht_getdata+0x1e2>
    1836:	25 ed       	ldi	r18, 0xD5	; 213
    1838:	2a 95       	dec	r18
    183a:	f1 f7       	brne	.-4      	; 0x1838 <dht_getdata+0xb2>
    183c:	00 00       	nop
		return -1;
	}
	_delay_us(80);
	//check start condition 2
	if(!(DHT_PIN & (1<<syspin))) {
    183e:	26 b1       	in	r18, 0x06	; 6
    1840:	30 e0       	ldi	r19, 0x00	; 0
    1842:	02 c0       	rjmp	.+4      	; 0x1848 <dht_getdata+0xc2>
    1844:	35 95       	asr	r19
    1846:	27 95       	ror	r18
    1848:	8a 95       	dec	r24
    184a:	e2 f7       	brpl	.-8      	; 0x1844 <dht_getdata+0xbe>
    184c:	20 ff       	sbrs	r18, 0
    184e:	8e c0       	rjmp	.+284    	; 0x196c <dht_getdata+0x1e6>
    1850:	35 ed       	ldi	r19, 0xD5	; 213
    1852:	3a 95       	dec	r19
    1854:	f1 f7       	brne	.-4      	; 0x1852 <dht_getdata+0xcc>
    1856:	00 00       	nop
    1858:	de 01       	movw	r26, r28
    185a:	11 96       	adiw	r26, 0x01	; 1
    185c:	6e 01       	movw	r12, r28
    185e:	86 e0       	ldi	r24, 0x06	; 6
    1860:	c8 0e       	add	r12, r24
    1862:	d1 1c       	adc	r13, r1
					return -3; //timeout
				}
			}
			_delay_us(30);
			if(DHT_PIN & (1<<syspin)) //if input is high after 30 us, get result
				result |= (1<<(7-i));
    1864:	aa 24       	eor	r10, r10
    1866:	a3 94       	inc	r10
    1868:	b1 2c       	mov	r11, r1
uint16_t rawtemperature;

/*
 * get data from sensor
 */
int8_t dht_getdata(uint8_t syspin, int16_t *temperature, int16_t *humidity, bool dht22) {
    186a:	87 e0       	ldi	r24, 0x07	; 7
    186c:	90 e0       	ldi	r25, 0x00	; 0
    186e:	81 2c       	mov	r8, r1
    1870:	49 ec       	ldi	r20, 0xC9	; 201
    1872:	50 e0       	ldi	r21, 0x00	; 0
	uint16_t timeoutcounter = 0;
	for (j=0; j<5; j++) { //read 5 byte
		uint8_t result=0;
		for(i=0; i<8; i++) {//read every bit
			timeoutcounter = 0;
			while(!(DHT_PIN & (1<<syspin))) { //wait for an high input (non blocking)
    1874:	26 b1       	in	r18, 0x06	; 6
    1876:	30 e0       	ldi	r19, 0x00	; 0
    1878:	2e 23       	and	r18, r30
    187a:	3f 23       	and	r19, r31
    187c:	23 2b       	or	r18, r19
    187e:	39 f4       	brne	.+14     	; 0x188e <dht_getdata+0x108>
    1880:	41 50       	subi	r20, 0x01	; 1
    1882:	51 09       	sbc	r21, r1
				timeoutcounter++;
				if(timeoutcounter > DHT_TIMEOUT) {
    1884:	41 15       	cp	r20, r1
    1886:	51 05       	cpc	r21, r1
    1888:	a9 f7       	brne	.-22     	; 0x1874 <dht_getdata+0xee>
					return -3; //timeout
    188a:	8d ef       	ldi	r24, 0xFD	; 253
    188c:	72 c0       	rjmp	.+228    	; 0x1972 <dht_getdata+0x1ec>
    188e:	20 e5       	ldi	r18, 0x50	; 80
    1890:	2a 95       	dec	r18
    1892:	f1 f7       	brne	.-4      	; 0x1890 <dht_getdata+0x10a>
				}
			}
			_delay_us(30);
			if(DHT_PIN & (1<<syspin)) //if input is high after 30 us, get result
    1894:	46 b1       	in	r20, 0x06	; 6
    1896:	50 e0       	ldi	r21, 0x00	; 0
    1898:	4e 23       	and	r20, r30
    189a:	5f 23       	and	r21, r31
    189c:	45 2b       	or	r20, r21
    189e:	39 f0       	breq	.+14     	; 0x18ae <dht_getdata+0x128>
				result |= (1<<(7-i));
    18a0:	95 01       	movw	r18, r10
    18a2:	08 2e       	mov	r0, r24
    18a4:	01 c0       	rjmp	.+2      	; 0x18a8 <dht_getdata+0x122>
    18a6:	22 0f       	add	r18, r18
    18a8:	0a 94       	dec	r0
    18aa:	ea f7       	brpl	.-6      	; 0x18a6 <dht_getdata+0x120>
    18ac:	82 2a       	or	r8, r18
			timeoutcounter = 0;
			while(DHT_PIN & (1<<syspin)) { //wait until input get low (non blocking)
    18ae:	69 ec       	ldi	r22, 0xC9	; 201
    18b0:	70 e0       	ldi	r23, 0x00	; 0
    18b2:	46 b1       	in	r20, 0x06	; 6
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	4e 23       	and	r20, r30
    18b8:	5f 23       	and	r21, r31
    18ba:	45 2b       	or	r20, r21
    18bc:	39 f0       	breq	.+14     	; 0x18cc <dht_getdata+0x146>
    18be:	61 50       	subi	r22, 0x01	; 1
    18c0:	71 09       	sbc	r23, r1
				timeoutcounter++;
				if(timeoutcounter > DHT_TIMEOUT) {
    18c2:	61 15       	cp	r22, r1
    18c4:	71 05       	cpc	r23, r1
    18c6:	a9 f7       	brne	.-22     	; 0x18b2 <dht_getdata+0x12c>
					return -4; //timeout
    18c8:	8c ef       	ldi	r24, 0xFC	; 252
    18ca:	53 c0       	rjmp	.+166    	; 0x1972 <dht_getdata+0x1ec>
    18cc:	01 97       	sbiw	r24, 0x01	; 1
    18ce:	80 f6       	brcc	.-96     	; 0x1870 <dht_getdata+0xea>
				}
			}
		}
		bits[j] = result;
    18d0:	8d 92       	st	X+, r8
	}
	_delay_us(80);

	//read the data
	uint16_t timeoutcounter = 0;
	for (j=0; j<5; j++) { //read 5 byte
    18d2:	ac 15       	cp	r26, r12
    18d4:	bd 05       	cpc	r27, r13
    18d6:	49 f6       	brne	.-110    	; 0x186a <dht_getdata+0xe4>
		}
		bits[j] = result;
	}

	//reset port
	DHT_DDR |= (1<<syspin); //output
    18d8:	87 b1       	in	r24, 0x07	; 7
    18da:	8e 2b       	or	r24, r30
    18dc:	87 b9       	out	0x07, r24	; 7
	DHT_PORT |= (1<<syspin); //low
    18de:	88 b1       	in	r24, 0x08	; 8
    18e0:	8e 2b       	or	r24, r30
    18e2:	88 b9       	out	0x08, r24	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    18e4:	8f ef       	ldi	r24, 0xFF	; 255
    18e6:	90 e7       	ldi	r25, 0x70	; 112
    18e8:	a2 e0       	ldi	r26, 0x02	; 2
    18ea:	81 50       	subi	r24, 0x01	; 1
    18ec:	90 40       	sbci	r25, 0x00	; 0
    18ee:	a0 40       	sbci	r26, 0x00	; 0
    18f0:	e1 f7       	brne	.-8      	; 0x18ea <dht_getdata+0x164>
    18f2:	00 c0       	rjmp	.+0      	; 0x18f4 <dht_getdata+0x16e>
    18f4:	00 00       	nop
	_delay_ms(100);

	//check checksum
	if ((uint8_t)(bits[0] + bits[1] + bits[2] + bits[3]) == bits[4]) {
    18f6:	99 81       	ldd	r25, Y+1	; 0x01
    18f8:	2a 81       	ldd	r18, Y+2	; 0x02
    18fa:	3b 81       	ldd	r19, Y+3	; 0x03
    18fc:	4c 81       	ldd	r20, Y+4	; 0x04
    18fe:	82 2f       	mov	r24, r18
    1900:	89 0f       	add	r24, r25
    1902:	83 0f       	add	r24, r19
    1904:	84 0f       	add	r24, r20
    1906:	5d 81       	ldd	r21, Y+5	; 0x05
    1908:	85 13       	cpse	r24, r21
    190a:	32 c0       	rjmp	.+100    	; 0x1970 <dht_getdata+0x1ea>
		printf("CRC OK %d %d %d %d", bits[0], bits[1], bits[2], bits[3]);
    190c:	1f 92       	push	r1
    190e:	4f 93       	push	r20
    1910:	1f 92       	push	r1
    1912:	3f 93       	push	r19
    1914:	1f 92       	push	r1
    1916:	2f 93       	push	r18
    1918:	1f 92       	push	r1
    191a:	9f 93       	push	r25
    191c:	80 e3       	ldi	r24, 0x30	; 48
    191e:	91 e0       	ldi	r25, 0x01	; 1
    1920:	9f 93       	push	r25
    1922:	8f 93       	push	r24
    1924:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
		//return temperature and humidity
		if (dht22)
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	de bf       	out	0x3e, r29	; 62
    192e:	0f be       	out	0x3f, r0	; 63
    1930:	cd bf       	out	0x3d, r28	; 61
    1932:	29 81       	ldd	r18, Y+1	; 0x01
    1934:	8b 81       	ldd	r24, Y+3	; 0x03
		{
			*humidity = bits[0]<<8 | bits[1];
    1936:	30 e0       	ldi	r19, 0x00	; 0

	//check checksum
	if ((uint8_t)(bits[0] + bits[1] + bits[2] + bits[3]) == bits[4]) {
		printf("CRC OK %d %d %d %d", bits[0], bits[1], bits[2], bits[3]);
		//return temperature and humidity
		if (dht22)
    1938:	99 20       	and	r9, r9
    193a:	69 f0       	breq	.+26     	; 0x1956 <dht_getdata+0x1d0>
		{
			*humidity = bits[0]<<8 | bits[1];
    193c:	32 2f       	mov	r19, r18
    193e:	22 27       	eor	r18, r18
    1940:	9a 81       	ldd	r25, Y+2	; 0x02
    1942:	29 2b       	or	r18, r25
    1944:	d7 01       	movw	r26, r14
    1946:	2d 93       	st	X+, r18
    1948:	3c 93       	st	X, r19
			*temperature = bits[2]<<8 | bits[3];
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	98 2f       	mov	r25, r24
    194e:	88 27       	eor	r24, r24
    1950:	2c 81       	ldd	r18, Y+4	; 0x04
    1952:	82 2b       	or	r24, r18
    1954:	04 c0       	rjmp	.+8      	; 0x195e <dht_getdata+0x1d8>
		} else {
			*humidity = bits[0];
    1956:	d7 01       	movw	r26, r14
    1958:	2d 93       	st	X+, r18
    195a:	3c 93       	st	X, r19
			*temperature = bits[2];			
    195c:	90 e0       	ldi	r25, 0x00	; 0
    195e:	f8 01       	movw	r30, r16
    1960:	91 83       	std	Z+1, r25	; 0x01
    1962:	80 83       	st	Z, r24
		}
		return 0;
    1964:	80 e0       	ldi	r24, 0x00	; 0
    1966:	05 c0       	rjmp	.+10     	; 0x1972 <dht_getdata+0x1ec>
	DHT_DDR &= ~(1<<syspin); //input
	_delay_us(40);

	//check start condition 1
	if((DHT_PIN & (1<<syspin))) {
		return -1;
    1968:	8f ef       	ldi	r24, 0xFF	; 255
    196a:	03 c0       	rjmp	.+6      	; 0x1972 <dht_getdata+0x1ec>
	}
	_delay_us(80);
	//check start condition 2
	if(!(DHT_PIN & (1<<syspin))) {
		return -2;
    196c:	8e ef       	ldi	r24, 0xFE	; 254
    196e:	01 c0       	rjmp	.+2      	; 0x1972 <dht_getdata+0x1ec>
			*temperature = bits[2];			
		}
		return 0;
	}

	return -5;
    1970:	8b ef       	ldi	r24, 0xFB	; 251
}
    1972:	0f 90       	pop	r0
    1974:	0f 90       	pop	r0
    1976:	0f 90       	pop	r0
    1978:	0f 90       	pop	r0
    197a:	0f 90       	pop	r0
    197c:	df 91       	pop	r29
    197e:	cf 91       	pop	r28
    1980:	1f 91       	pop	r17
    1982:	0f 91       	pop	r16
    1984:	ff 90       	pop	r15
    1986:	ef 90       	pop	r14
    1988:	df 90       	pop	r13
    198a:	cf 90       	pop	r12
    198c:	bf 90       	pop	r11
    198e:	af 90       	pop	r10
    1990:	9f 90       	pop	r9
    1992:	8f 90       	pop	r8
    1994:	08 95       	ret

00001996 <enc28j60ReadOp>:
//
#define waitspi() while(!(SPSR&(1<<SPIF)))

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
        CSACTIVE;
    1996:	2c 98       	cbi	0x05, 4	; 5
        // issue read command
        SPDR = op | (address & ADDR_MASK);
    1998:	96 2f       	mov	r25, r22
    199a:	9f 71       	andi	r25, 0x1F	; 31
    199c:	98 2b       	or	r25, r24
    199e:	9e bd       	out	0x2e, r25	; 46
        waitspi();
    19a0:	0d b4       	in	r0, 0x2d	; 45
    19a2:	07 fe       	sbrs	r0, 7
    19a4:	fd cf       	rjmp	.-6      	; 0x19a0 <enc28j60ReadOp+0xa>
        // read data
        SPDR = 0x00;
    19a6:	1e bc       	out	0x2e, r1	; 46
        waitspi();
    19a8:	0d b4       	in	r0, 0x2d	; 45
    19aa:	07 fe       	sbrs	r0, 7
    19ac:	fd cf       	rjmp	.-6      	; 0x19a8 <enc28j60ReadOp+0x12>
        // do dummy read if needed (for mac and mii, see datasheet page 29)
        if(address & 0x80)
    19ae:	67 fd       	sbrc	r22, 7
    19b0:	03 c0       	rjmp	.+6      	; 0x19b8 <enc28j60ReadOp+0x22>
        {
                SPDR = 0x00;
                waitspi();
        }
        // release CS
        CSPASSIVE;
    19b2:	2c 9a       	sbi	0x05, 4	; 5
        return(SPDR);
    19b4:	8e b5       	in	r24, 0x2e	; 46
    19b6:	08 95       	ret
        SPDR = 0x00;
        waitspi();
        // do dummy read if needed (for mac and mii, see datasheet page 29)
        if(address & 0x80)
        {
                SPDR = 0x00;
    19b8:	1e bc       	out	0x2e, r1	; 46
                waitspi();
    19ba:	0d b4       	in	r0, 0x2d	; 45
    19bc:	07 fe       	sbrs	r0, 7
    19be:	fd cf       	rjmp	.-6      	; 0x19ba <enc28j60ReadOp+0x24>
    19c0:	f8 cf       	rjmp	.-16     	; 0x19b2 <enc28j60ReadOp+0x1c>

000019c2 <enc28j60WriteOp>:
        return(SPDR);
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
        CSACTIVE;
    19c2:	2c 98       	cbi	0x05, 4	; 5
        // issue write command
        SPDR = op | (address & ADDR_MASK);
    19c4:	6f 71       	andi	r22, 0x1F	; 31
    19c6:	68 2b       	or	r22, r24
    19c8:	6e bd       	out	0x2e, r22	; 46
        waitspi();
    19ca:	0d b4       	in	r0, 0x2d	; 45
    19cc:	07 fe       	sbrs	r0, 7
    19ce:	fd cf       	rjmp	.-6      	; 0x19ca <enc28j60WriteOp+0x8>
        // write data
        SPDR = data;
    19d0:	4e bd       	out	0x2e, r20	; 46
        waitspi();
    19d2:	0d b4       	in	r0, 0x2d	; 45
    19d4:	07 fe       	sbrs	r0, 7
    19d6:	fd cf       	rjmp	.-6      	; 0x19d2 <enc28j60WriteOp+0x10>
        CSPASSIVE;
    19d8:	2c 9a       	sbi	0x05, 4	; 5
    19da:	08 95       	ret

000019dc <enc28j60ReadBuffer>:
}

void enc28j60ReadBuffer(uint16_t len, uint8_t* data)
{
    19dc:	fb 01       	movw	r30, r22
        CSACTIVE;
    19de:	2c 98       	cbi	0x05, 4	; 5
        // issue read command
        SPDR = ENC28J60_READ_BUF_MEM;
    19e0:	2a e3       	ldi	r18, 0x3A	; 58
    19e2:	2e bd       	out	0x2e, r18	; 46
        waitspi();
    19e4:	0d b4       	in	r0, 0x2d	; 45
    19e6:	07 fe       	sbrs	r0, 7
    19e8:	fd cf       	rjmp	.-6      	; 0x19e4 <enc28j60ReadBuffer+0x8>
    19ea:	8e 0f       	add	r24, r30
    19ec:	9f 1f       	adc	r25, r31
        while(len)
    19ee:	e8 17       	cp	r30, r24
    19f0:	f9 07       	cpc	r31, r25
    19f2:	39 f0       	breq	.+14     	; 0x1a02 <enc28j60ReadBuffer+0x26>
        {
                len--;
                // read data
                SPDR = 0x00;
    19f4:	1e bc       	out	0x2e, r1	; 46
                waitspi();
    19f6:	0d b4       	in	r0, 0x2d	; 45
    19f8:	07 fe       	sbrs	r0, 7
    19fa:	fd cf       	rjmp	.-6      	; 0x19f6 <enc28j60ReadBuffer+0x1a>
                *data = SPDR;
    19fc:	2e b5       	in	r18, 0x2e	; 46
    19fe:	21 93       	st	Z+, r18
    1a00:	f6 cf       	rjmp	.-20     	; 0x19ee <enc28j60ReadBuffer+0x12>
                data++;
        }
        *data='\0';
    1a02:	10 82       	st	Z, r1
        CSPASSIVE;
    1a04:	2c 9a       	sbi	0x05, 4	; 5
    1a06:	08 95       	ret

00001a08 <enc28j60WriteBuffer>:
}

void enc28j60WriteBuffer(uint16_t len, uint8_t* data)
{
        CSACTIVE;
    1a08:	2c 98       	cbi	0x05, 4	; 5
        // issue write command
        SPDR = ENC28J60_WRITE_BUF_MEM;
    1a0a:	2a e7       	ldi	r18, 0x7A	; 122
    1a0c:	2e bd       	out	0x2e, r18	; 46
        waitspi();
    1a0e:	0d b4       	in	r0, 0x2d	; 45
    1a10:	07 fe       	sbrs	r0, 7
    1a12:	fd cf       	rjmp	.-6      	; 0x1a0e <enc28j60WriteBuffer+0x6>
    1a14:	86 0f       	add	r24, r22
    1a16:	97 1f       	adc	r25, r23
        while(len)
    1a18:	68 17       	cp	r22, r24
    1a1a:	79 07       	cpc	r23, r25
    1a1c:	41 f0       	breq	.+16     	; 0x1a2e <enc28j60WriteBuffer+0x26>
        {
                len--;
                // write data
                SPDR = *data;
    1a1e:	fb 01       	movw	r30, r22
    1a20:	21 91       	ld	r18, Z+
    1a22:	bf 01       	movw	r22, r30
    1a24:	2e bd       	out	0x2e, r18	; 46
                data++;
                waitspi();
    1a26:	0d b4       	in	r0, 0x2d	; 45
    1a28:	07 fe       	sbrs	r0, 7
    1a2a:	fd cf       	rjmp	.-6      	; 0x1a26 <enc28j60WriteBuffer+0x1e>
    1a2c:	f5 cf       	rjmp	.-22     	; 0x1a18 <enc28j60WriteBuffer+0x10>
        }
        CSPASSIVE;
    1a2e:	2c 9a       	sbi	0x05, 4	; 5
    1a30:	08 95       	ret

00001a32 <enc28j60SetBank>:
}

void enc28j60SetBank(uint8_t address)
{
    1a32:	1f 93       	push	r17
    1a34:	cf 93       	push	r28
    1a36:	df 93       	push	r29
        // set the bank (if needed)
        if((address & BANK_MASK) != Enc28j60Bank)
    1a38:	18 2f       	mov	r17, r24
    1a3a:	10 76       	andi	r17, 0x60	; 96
    1a3c:	c1 2f       	mov	r28, r17
    1a3e:	d0 e0       	ldi	r29, 0x00	; 0
    1a40:	20 91 4a 05 	lds	r18, 0x054A
    1a44:	30 e0       	ldi	r19, 0x00	; 0
    1a46:	c2 17       	cp	r28, r18
    1a48:	d3 07       	cpc	r29, r19
    1a4a:	89 f0       	breq	.+34     	; 0x1a6e <enc28j60SetBank+0x3c>
        {
                // set the bank
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    1a4c:	43 e0       	ldi	r20, 0x03	; 3
    1a4e:	6f e1       	ldi	r22, 0x1F	; 31
    1a50:	80 ea       	ldi	r24, 0xA0	; 160
    1a52:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    1a56:	ae 01       	movw	r20, r28
    1a58:	85 e0       	ldi	r24, 0x05	; 5
    1a5a:	55 95       	asr	r21
    1a5c:	47 95       	ror	r20
    1a5e:	8a 95       	dec	r24
    1a60:	e1 f7       	brne	.-8      	; 0x1a5a <enc28j60SetBank+0x28>
    1a62:	6f e1       	ldi	r22, 0x1F	; 31
    1a64:	80 e8       	ldi	r24, 0x80	; 128
    1a66:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
                Enc28j60Bank = (address & BANK_MASK);
    1a6a:	10 93 4a 05 	sts	0x054A, r17
        }
}
    1a6e:	df 91       	pop	r29
    1a70:	cf 91       	pop	r28
    1a72:	1f 91       	pop	r17
    1a74:	08 95       	ret

00001a76 <enc28j60Read>:

uint8_t enc28j60Read(uint8_t address)
{
    1a76:	cf 93       	push	r28
    1a78:	df 93       	push	r29
    1a7a:	1f 92       	push	r1
    1a7c:	cd b7       	in	r28, 0x3d	; 61
    1a7e:	de b7       	in	r29, 0x3e	; 62
    1a80:	68 2f       	mov	r22, r24
        // set the bank
        enc28j60SetBank(address);
    1a82:	69 83       	std	Y+1, r22	; 0x01
    1a84:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <enc28j60SetBank>
        // do the read
        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    1a88:	69 81       	ldd	r22, Y+1	; 0x01
    1a8a:	80 e0       	ldi	r24, 0x00	; 0
}
    1a8c:	0f 90       	pop	r0
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
uint8_t enc28j60Read(uint8_t address)
{
        // set the bank
        enc28j60SetBank(address);
        // do the read
        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    1a92:	0c 94 cb 0c 	jmp	0x1996	; 0x1996 <enc28j60ReadOp>

00001a96 <enc28j60Write>:
	
	return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    1a96:	1f 93       	push	r17
    1a98:	cf 93       	push	r28
    1a9a:	df 93       	push	r29
    1a9c:	1f 92       	push	r1
    1a9e:	cd b7       	in	r28, 0x3d	; 61
    1aa0:	de b7       	in	r29, 0x3e	; 62
    1aa2:	18 2f       	mov	r17, r24
        // set the bank
        enc28j60SetBank(address);
    1aa4:	69 83       	std	Y+1, r22	; 0x01
    1aa6:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <enc28j60SetBank>
        // do the write
        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    1aaa:	49 81       	ldd	r20, Y+1	; 0x01
    1aac:	61 2f       	mov	r22, r17
    1aae:	80 e4       	ldi	r24, 0x40	; 64
}
    1ab0:	0f 90       	pop	r0
    1ab2:	df 91       	pop	r29
    1ab4:	cf 91       	pop	r28
    1ab6:	1f 91       	pop	r17
void enc28j60Write(uint8_t address, uint8_t data)
{
        // set the bank
        enc28j60SetBank(address);
        // do the write
        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    1ab8:	0c 94 e1 0c 	jmp	0x19c2	; 0x19c2 <enc28j60WriteOp>

00001abc <enc28j60PhyReadH>:
// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{

	// Set the right address and start the register read operation
	enc28j60Write(MIREGADR, address);
    1abc:	68 2f       	mov	r22, r24
    1abe:	84 ed       	ldi	r24, 0xD4	; 212
    1ac0:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(MICMD, MICMD_MIIRD);
    1ac4:	61 e0       	ldi	r22, 0x01	; 1
    1ac6:	82 ed       	ldi	r24, 0xD2	; 210
    1ac8:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1acc:	88 e2       	ldi	r24, 0x28	; 40
    1ace:	8a 95       	dec	r24
    1ad0:	f1 f7       	brne	.-4      	; 0x1ace <enc28j60PhyReadH+0x12>
        _delay_loop_1(40); // 10us

	// wait until the PHY read completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY);
    1ad2:	8a ee       	ldi	r24, 0xEA	; 234
    1ad4:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <enc28j60Read>
    1ad8:	80 fd       	sbrc	r24, 0
    1ada:	fb cf       	rjmp	.-10     	; 0x1ad2 <enc28j60PhyReadH+0x16>

	// reset reading bit
	enc28j60Write(MICMD, 0x00);
    1adc:	60 e0       	ldi	r22, 0x00	; 0
    1ade:	82 ed       	ldi	r24, 0xD2	; 210
    1ae0:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	
	return (enc28j60Read(MIRDH));
    1ae4:	89 ed       	ldi	r24, 0xD9	; 217
    1ae6:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <enc28j60Read>
}
    1aea:	90 e0       	ldi	r25, 0x00	; 0
    1aec:	08 95       	ret

00001aee <enc28j60PhyWrite>:
        // do the write
        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    1aee:	1f 93       	push	r17
    1af0:	cf 93       	push	r28
    1af2:	df 93       	push	r29
    1af4:	1f 92       	push	r1
    1af6:	cd b7       	in	r28, 0x3d	; 61
    1af8:	de b7       	in	r29, 0x3e	; 62
    1afa:	16 2f       	mov	r17, r22
        // set the PHY register address
        enc28j60Write(MIREGADR, address);
    1afc:	68 2f       	mov	r22, r24
    1afe:	84 ed       	ldi	r24, 0xD4	; 212
    1b00:	79 83       	std	Y+1, r23	; 0x01
    1b02:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        // write the PHY data
        enc28j60Write(MIWRL, data);
    1b06:	61 2f       	mov	r22, r17
    1b08:	86 ed       	ldi	r24, 0xD6	; 214
    1b0a:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        enc28j60Write(MIWRH, data>>8);
    1b0e:	79 81       	ldd	r23, Y+1	; 0x01
    1b10:	67 2f       	mov	r22, r23
    1b12:	87 ed       	ldi	r24, 0xD7	; 215
    1b14:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
    1b18:	18 e2       	ldi	r17, 0x28	; 40
        // wait until the PHY write completes
        while(enc28j60Read(MISTAT) & MISTAT_BUSY){
    1b1a:	8a ee       	ldi	r24, 0xEA	; 234
    1b1c:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <enc28j60Read>
    1b20:	80 ff       	sbrs	r24, 0
    1b22:	04 c0       	rjmp	.+8      	; 0x1b2c <enc28j60PhyWrite+0x3e>
    1b24:	81 2f       	mov	r24, r17
    1b26:	8a 95       	dec	r24
    1b28:	f1 f7       	brne	.-4      	; 0x1b26 <enc28j60PhyWrite+0x38>
    1b2a:	f7 cf       	rjmp	.-18     	; 0x1b1a <enc28j60PhyWrite+0x2c>
                _delay_loop_1(40); // 10us
        }
}
    1b2c:	0f 90       	pop	r0
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	1f 91       	pop	r17
    1b34:	08 95       	ret

00001b36 <enc28j60clkout>:

void enc28j60clkout(uint8_t clk)
{
        //setup clkout: 2 is 12.5MHz:
	enc28j60Write(ECOCON, clk & 0x7);
    1b36:	68 2f       	mov	r22, r24
    1b38:	67 70       	andi	r22, 0x07	; 7
    1b3a:	85 e7       	ldi	r24, 0x75	; 117
    1b3c:	0c 94 4b 0d 	jmp	0x1a96	; 0x1a96 <enc28j60Write>

00001b40 <enc28j60Init>:
}

void enc28j60Init(uint8_t* macaddr)
{
    1b40:	cf 93       	push	r28
    1b42:	df 93       	push	r29
    1b44:	ec 01       	movw	r28, r24
	// initialize I/O
        // ss as output:
	ENC28J60_CONTROL_DDR |= 1<<ENC28J60_CONTROL_CS;
    1b46:	24 9a       	sbi	0x04, 4	; 4
	CSPASSIVE; // ss=0
    1b48:	2c 9a       	sbi	0x05, 4	; 5
        //	
	ENC28J60_CONTROL_DDR  |= 1<<ENC28J60_CONTROL_SI | 1<<ENC28J60_CONTROL_SCK; // mosi, sck output
    1b4a:	84 b1       	in	r24, 0x04	; 4
    1b4c:	80 6a       	ori	r24, 0xA0	; 160
    1b4e:	84 b9       	out	0x04, r24	; 4
	ENC28J60_CONTROL_DDR|= 1<<ENC28J60_CONTROL_SO; // MISO is input
    1b50:	26 9a       	sbi	0x04, 6	; 4
        //
        ENC28J60_CONTROL_PORT|= 1<<ENC28J60_CONTROL_SI; // MOSI low
    1b52:	2d 9a       	sbi	0x05, 5	; 5
        ENC28J60_CONTROL_PORT|= 1<<ENC28J60_CONTROL_SCK; // SCK low
    1b54:	2f 9a       	sbi	0x05, 7	; 5
	//
	// initialize SPI interface
	// master mode and Fosc/2 clock:
        SPCR = (1<<SPE)|(1<<MSTR);
    1b56:	80 e5       	ldi	r24, 0x50	; 80
    1b58:	8c bd       	out	0x2c, r24	; 44
        SPSR |= (0<<SPI2X);
    1b5a:	8d b5       	in	r24, 0x2d	; 45
    1b5c:	8d bd       	out	0x2d, r24	; 45
	// perform system reset
	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
    1b5e:	4f ef       	ldi	r20, 0xFF	; 255
    1b60:	60 e0       	ldi	r22, 0x00	; 0
    1b62:	8f ef       	ldi	r24, 0xFF	; 255
    1b64:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1b68:	80 e0       	ldi	r24, 0x00	; 0
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	01 97       	sbiw	r24, 0x01	; 1
    1b6e:	f1 f7       	brne	.-4      	; 0x1b6c <enc28j60Init+0x2c>
	//while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	gNextPacketPtr = RXSTART_INIT;
    1b70:	10 92 49 05 	sts	0x0549, r1
    1b74:	10 92 48 05 	sts	0x0548, r1
        // Rx start
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
    1b78:	60 e0       	ldi	r22, 0x00	; 0
    1b7a:	88 e0       	ldi	r24, 0x08	; 8
    1b7c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
    1b80:	60 e0       	ldi	r22, 0x00	; 0
    1b82:	89 e0       	ldi	r24, 0x09	; 9
    1b84:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
    1b88:	60 e0       	ldi	r22, 0x00	; 0
    1b8a:	8c e0       	ldi	r24, 0x0C	; 12
    1b8c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
    1b90:	60 e0       	ldi	r22, 0x00	; 0
    1b92:	8d e0       	ldi	r24, 0x0D	; 13
    1b94:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// RX end
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
    1b98:	6f ef       	ldi	r22, 0xFF	; 255
    1b9a:	8a e0       	ldi	r24, 0x0A	; 10
    1b9c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
    1ba0:	69 e1       	ldi	r22, 0x19	; 25
    1ba2:	8b e0       	ldi	r24, 0x0B	; 11
    1ba4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// TX start
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
    1ba8:	60 e0       	ldi	r22, 0x00	; 0
    1baa:	84 e0       	ldi	r24, 0x04	; 4
    1bac:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
    1bb0:	6a e1       	ldi	r22, 0x1A	; 26
    1bb2:	85 e0       	ldi	r24, 0x05	; 5
    1bb4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// TX end
	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
    1bb8:	6f ef       	ldi	r22, 0xFF	; 255
    1bba:	86 e0       	ldi	r24, 0x06	; 6
    1bbc:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
    1bc0:	6f e1       	ldi	r22, 0x1F	; 31
    1bc2:	87 e0       	ldi	r24, 0x07	; 7
    1bc4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        // Type     ETH.DST
        // ARP      BROADCAST
        // 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
        // in binary these poitions are:11 0000 0011 1111
        // This is hex 303F->EPMM0=0x3f,EPMM1=0x30
	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
    1bc8:	60 eb       	ldi	r22, 0xB0	; 176
    1bca:	88 e3       	ldi	r24, 0x38	; 56
    1bcc:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(EPMM0, 0x3f);
    1bd0:	6f e3       	ldi	r22, 0x3F	; 63
    1bd2:	88 e2       	ldi	r24, 0x28	; 40
    1bd4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(EPMM1, 0x30);
    1bd8:	60 e3       	ldi	r22, 0x30	; 48
    1bda:	89 e2       	ldi	r24, 0x29	; 41
    1bdc:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(EPMCSL, 0xf9);
    1be0:	69 ef       	ldi	r22, 0xF9	; 249
    1be2:	80 e3       	ldi	r24, 0x30	; 48
    1be4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(EPMCSH, 0xf7);
    1be8:	67 ef       	ldi	r22, 0xF7	; 247
    1bea:	81 e3       	ldi	r24, 0x31	; 49
    1bec:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        //
        //
	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
    1bf0:	6d e0       	ldi	r22, 0x0D	; 13
    1bf2:	80 ec       	ldi	r24, 0xC0	; 192
    1bf4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// bring MAC out of reset
	enc28j60Write(MACON2, 0x00);
    1bf8:	60 e0       	ldi	r22, 0x00	; 0
    1bfa:	81 ec       	ldi	r24, 0xC1	; 193
    1bfc:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// enable automatic padding to 60bytes and CRC operations
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
    1c00:	42 e3       	ldi	r20, 0x32	; 50
    1c02:	62 ec       	ldi	r22, 0xC2	; 194
    1c04:	80 e8       	ldi	r24, 0x80	; 128
    1c06:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
	// set inter-frame gap (non-back-to-back)
	enc28j60Write(MAIPGL, 0x12);
    1c0a:	62 e1       	ldi	r22, 0x12	; 18
    1c0c:	86 ec       	ldi	r24, 0xC6	; 198
    1c0e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(MAIPGH, 0x0C);
    1c12:	6c e0       	ldi	r22, 0x0C	; 12
    1c14:	87 ec       	ldi	r24, 0xC7	; 199
    1c16:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
    1c1a:	62 e1       	ldi	r22, 0x12	; 18
    1c1c:	84 ec       	ldi	r24, 0xC4	; 196
    1c1e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// Set the maximum packet size which the controller will accept
        // Do not send packets longer than MAX_FRAMELEN:
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
    1c22:	6c ed       	ldi	r22, 0xDC	; 220
    1c24:	8a ec       	ldi	r24, 0xCA	; 202
    1c26:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
    1c2a:	65 e0       	ldi	r22, 0x05	; 5
    1c2c:	8b ec       	ldi	r24, 0xCB	; 203
    1c2e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// do bank 3 stuff
        // write MAC address
        // NOTE: MAC address in ENC28J60 is byte-backward
        enc28j60Write(MAADR5, macaddr[0]);
    1c32:	68 81       	ld	r22, Y
    1c34:	84 ee       	ldi	r24, 0xE4	; 228
    1c36:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        enc28j60Write(MAADR4, macaddr[1]);
    1c3a:	69 81       	ldd	r22, Y+1	; 0x01
    1c3c:	85 ee       	ldi	r24, 0xE5	; 229
    1c3e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        enc28j60Write(MAADR3, macaddr[2]);
    1c42:	6a 81       	ldd	r22, Y+2	; 0x02
    1c44:	82 ee       	ldi	r24, 0xE2	; 226
    1c46:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        enc28j60Write(MAADR2, macaddr[3]);
    1c4a:	6b 81       	ldd	r22, Y+3	; 0x03
    1c4c:	83 ee       	ldi	r24, 0xE3	; 227
    1c4e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        enc28j60Write(MAADR1, macaddr[4]);
    1c52:	6c 81       	ldd	r22, Y+4	; 0x04
    1c54:	80 ee       	ldi	r24, 0xE0	; 224
    1c56:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        enc28j60Write(MAADR0, macaddr[5]);
    1c5a:	6d 81       	ldd	r22, Y+5	; 0x05
    1c5c:	81 ee       	ldi	r24, 0xE1	; 225
    1c5e:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
    1c62:	60 e0       	ldi	r22, 0x00	; 0
    1c64:	71 e0       	ldi	r23, 0x01	; 1
    1c66:	80 e1       	ldi	r24, 0x10	; 16
    1c68:	0e 94 77 0d 	call	0x1aee	; 0x1aee <enc28j60PhyWrite>
	// switch to bank 0
	enc28j60SetBank(ECON1);
    1c6c:	8f e1       	ldi	r24, 0x1F	; 31
    1c6e:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <enc28j60SetBank>
	// enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
    1c72:	40 ec       	ldi	r20, 0xC0	; 192
    1c74:	6b e1       	ldi	r22, 0x1B	; 27
    1c76:	80 e8       	ldi	r24, 0x80	; 128
    1c78:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
    1c7c:	44 e0       	ldi	r20, 0x04	; 4
    1c7e:	6f e1       	ldi	r22, 0x1F	; 31
    1c80:	80 e8       	ldi	r24, 0x80	; 128
}
    1c82:	df 91       	pop	r29
    1c84:	cf 91       	pop	r28
	// switch to bank 0
	enc28j60SetBank(ECON1);
	// enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
    1c86:	0c 94 e1 0c 	jmp	0x19c2	; 0x19c2 <enc28j60WriteOp>

00001c8a <enc28j60getrev>:

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
        uint8_t rev;
        rev=enc28j60Read(EREVID);
    1c8a:	82 e7       	ldi	r24, 0x72	; 114
    1c8c:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <enc28j60Read>
        // microchip forgott to step the number on the silcon when they
        // released the revision B7. 6 is now rev B7. We still have
        // to see what they do when they release B8. At the moment
        // there is no B8 out yet
        if (rev>5) rev++;
    1c90:	86 30       	cpi	r24, 0x06	; 6
    1c92:	08 f0       	brcs	.+2      	; 0x1c96 <enc28j60getrev+0xc>
    1c94:	8f 5f       	subi	r24, 0xFF	; 255
	return(rev);
}
    1c96:	08 95       	ret

00001c98 <enc28j60linkup>:

// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
    1c98:	81 e1       	ldi	r24, 0x11	; 17
    1c9a:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <enc28j60PhyReadH>
    1c9e:	21 e0       	ldi	r18, 0x01	; 1
    1ca0:	89 2b       	or	r24, r25
    1ca2:	09 f4       	brne	.+2      	; 0x1ca6 <enc28j60linkup+0xe>
    1ca4:	20 e0       	ldi	r18, 0x00	; 0
}
    1ca6:	82 2f       	mov	r24, r18
    1ca8:	08 95       	ret

00001caa <enc28j60PacketSend>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
    1caa:	0f 93       	push	r16
    1cac:	1f 93       	push	r17
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
    1cb2:	ec 01       	movw	r28, r24
    1cb4:	8b 01       	movw	r16, r22
        // Check no transmit in progress
        while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
    1cb6:	6f e1       	ldi	r22, 0x1F	; 31
    1cb8:	80 e0       	ldi	r24, 0x00	; 0
    1cba:	0e 94 cb 0c 	call	0x1996	; 0x1996 <enc28j60ReadOp>
    1cbe:	83 ff       	sbrs	r24, 3
    1cc0:	10 c0       	rjmp	.+32     	; 0x1ce2 <enc28j60PacketSend+0x38>
        {
                // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
                if( (enc28j60Read(EIR) & EIR_TXERIF) ) {
    1cc2:	8c e1       	ldi	r24, 0x1C	; 28
    1cc4:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <enc28j60Read>
    1cc8:	81 ff       	sbrs	r24, 1
    1cca:	f5 cf       	rjmp	.-22     	; 0x1cb6 <enc28j60PacketSend+0xc>
                        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
    1ccc:	40 e8       	ldi	r20, 0x80	; 128
    1cce:	6f e1       	ldi	r22, 0x1F	; 31
    1cd0:	80 e8       	ldi	r24, 0x80	; 128
    1cd2:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
                        enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
    1cd6:	40 e8       	ldi	r20, 0x80	; 128
    1cd8:	6f e1       	ldi	r22, 0x1F	; 31
    1cda:	80 ea       	ldi	r24, 0xA0	; 160
    1cdc:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
    1ce0:	ea cf       	rjmp	.-44     	; 0x1cb6 <enc28j60PacketSend+0xc>
                }
        }
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
    1ce2:	60 e0       	ldi	r22, 0x00	; 0
    1ce4:	82 e0       	ldi	r24, 0x02	; 2
    1ce6:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
    1cea:	6a e1       	ldi	r22, 0x1A	; 26
    1cec:	83 e0       	ldi	r24, 0x03	; 3
    1cee:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
    1cf2:	6c 2f       	mov	r22, r28
    1cf4:	86 e0       	ldi	r24, 0x06	; 6
    1cf6:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
    1cfa:	ce 01       	movw	r24, r28
    1cfc:	96 5e       	subi	r25, 0xE6	; 230
    1cfe:	69 2f       	mov	r22, r25
    1d00:	87 e0       	ldi	r24, 0x07	; 7
    1d02:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
    1d06:	40 e0       	ldi	r20, 0x00	; 0
    1d08:	60 e0       	ldi	r22, 0x00	; 0
    1d0a:	8a e7       	ldi	r24, 0x7A	; 122
    1d0c:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
    1d10:	b8 01       	movw	r22, r16
    1d12:	ce 01       	movw	r24, r28
    1d14:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <enc28j60WriteBuffer>
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    1d18:	48 e0       	ldi	r20, 0x08	; 8
    1d1a:	6f e1       	ldi	r22, 0x1F	; 31
    1d1c:	80 e8       	ldi	r24, 0x80	; 128
}
    1d1e:	df 91       	pop	r29
    1d20:	cf 91       	pop	r28
    1d22:	1f 91       	pop	r17
    1d24:	0f 91       	pop	r16
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    1d26:	0c 94 e1 0c 	jmp	0x19c2	; 0x19c2 <enc28j60WriteOp>

00001d2a <enc28j60PacketReceive>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
    1d2a:	9f 92       	push	r9
    1d2c:	af 92       	push	r10
    1d2e:	bf 92       	push	r11
    1d30:	cf 92       	push	r12
    1d32:	df 92       	push	r13
    1d34:	ef 92       	push	r14
    1d36:	ff 92       	push	r15
    1d38:	0f 93       	push	r16
    1d3a:	1f 93       	push	r17
    1d3c:	cf 93       	push	r28
    1d3e:	df 93       	push	r29
    1d40:	7c 01       	movw	r14, r24
    1d42:	6b 01       	movw	r12, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) )
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
    1d44:	89 e3       	ldi	r24, 0x39	; 57
    1d46:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <enc28j60Read>
    1d4a:	88 23       	and	r24, r24
    1d4c:	09 f4       	brne	.+2      	; 0x1d50 <enc28j60PacketReceive+0x26>
    1d4e:	5b c0       	rjmp	.+182    	; 0x1e06 <enc28j60PacketReceive+0xdc>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (gNextPacketPtr &0xFF));
    1d50:	60 91 48 05 	lds	r22, 0x0548
    1d54:	c0 91 49 05 	lds	r28, 0x0549
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	enc28j60Write(ERDPTH, (gNextPacketPtr)>>8);
    1d5e:	6c 2f       	mov	r22, r28
    1d60:	81 e0       	ldi	r24, 0x01	; 1
    1d62:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
	// read the next packet pointer
	gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1d66:	60 e0       	ldi	r22, 0x00	; 0
    1d68:	8a e3       	ldi	r24, 0x3A	; 58
    1d6a:	0e 94 cb 0c 	call	0x1996	; 0x1996 <enc28j60ReadOp>
    1d6e:	08 2f       	mov	r16, r24
	gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1d70:	60 e0       	ldi	r22, 0x00	; 0
    1d72:	8a e3       	ldi	r24, 0x3A	; 58
    1d74:	0e 94 cb 0c 	call	0x1996	; 0x1996 <enc28j60ReadOp>
    1d78:	10 e0       	ldi	r17, 0x00	; 0
    1d7a:	18 2b       	or	r17, r24
    1d7c:	10 93 49 05 	sts	0x0549, r17
    1d80:	00 93 48 05 	sts	0x0548, r16
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1d84:	60 e0       	ldi	r22, 0x00	; 0
    1d86:	8a e3       	ldi	r24, 0x3A	; 58
    1d88:	0e 94 cb 0c 	call	0x1996	; 0x1996 <enc28j60ReadOp>
    1d8c:	c8 2f       	mov	r28, r24
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1d8e:	60 e0       	ldi	r22, 0x00	; 0
    1d90:	8a e3       	ldi	r24, 0x3A	; 58
    1d92:	0e 94 cb 0c 	call	0x1996	; 0x1996 <enc28j60ReadOp>
    1d96:	98 2e       	mov	r9, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1d98:	60 e0       	ldi	r22, 0x00	; 0
    1d9a:	8a e3       	ldi	r24, 0x3A	; 58
    1d9c:	0e 94 cb 0c 	call	0x1996	; 0x1996 <enc28j60ReadOp>
    1da0:	a8 2e       	mov	r10, r24
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
    1da2:	60 e0       	ldi	r22, 0x00	; 0
    1da4:	8a e3       	ldi	r24, 0x3A	; 58
    1da6:	0e 94 cb 0c 	call	0x1996	; 0x1996 <enc28j60ReadOp>
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
    1daa:	a7 fe       	sbrs	r10, 7
    1dac:	0f c0       	rjmp	.+30     	; 0x1dcc <enc28j60PacketReceive+0xa2>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
    1dae:	97 01       	movw	r18, r14
    1db0:	21 50       	subi	r18, 0x01	; 1
    1db2:	31 09       	sbc	r19, r1
	// read the next packet pointer
	gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1db4:	d0 e0       	ldi	r29, 0x00	; 0
    1db6:	d9 29       	or	r29, r9
    1db8:	24 97       	sbiw	r28, 0x04	; 4
    1dba:	2c 17       	cp	r18, r28
    1dbc:	3d 07       	cpc	r19, r29
    1dbe:	08 f4       	brcc	.+2      	; 0x1dc2 <enc28j60PacketReceive+0x98>
    1dc0:	e9 01       	movw	r28, r18
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
    1dc2:	b6 01       	movw	r22, r12
    1dc4:	ce 01       	movw	r24, r28
    1dc6:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <enc28j60ReadBuffer>
    1dca:	02 c0       	rjmp	.+4      	; 0x1dd0 <enc28j60PacketReceive+0xa6>
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
    1dcc:	c0 e0       	ldi	r28, 0x00	; 0
    1dce:	d0 e0       	ldi	r29, 0x00	; 0
        // Move the RX read pointer to the start of the next received packet
        // This frees the memory we just read out. 
        // However, compensate for the errata point 13, rev B4: never write an even address!
        // gNextPacketPtr is always an even address if RXSTOP_INIT is odd.
        if (gNextPacketPtr -1 > RXSTOP_INIT){ // RXSTART_INIT is zero, no test for gNextPacketPtr less than RXSTART_INIT.
                enc28j60Write(ERXRDPTL, (RXSTOP_INIT)&0xFF);
    1dd0:	6f ef       	ldi	r22, 0xFF	; 255
        //
        // Move the RX read pointer to the start of the next received packet
        // This frees the memory we just read out. 
        // However, compensate for the errata point 13, rev B4: never write an even address!
        // gNextPacketPtr is always an even address if RXSTOP_INIT is odd.
        if (gNextPacketPtr -1 > RXSTOP_INIT){ // RXSTART_INIT is zero, no test for gNextPacketPtr less than RXSTART_INIT.
    1dd2:	01 30       	cpi	r16, 0x01	; 1
    1dd4:	8a e1       	ldi	r24, 0x1A	; 26
    1dd6:	18 07       	cpc	r17, r24
    1dd8:	2c f0       	brlt	.+10     	; 0x1de4 <enc28j60PacketReceive+0xba>
                enc28j60Write(ERXRDPTL, (RXSTOP_INIT)&0xFF);
    1dda:	8c e0       	ldi	r24, 0x0C	; 12
    1ddc:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
                enc28j60Write(ERXRDPTH, (RXSTOP_INIT)>>8);
    1de0:	69 e1       	ldi	r22, 0x19	; 25
    1de2:	07 c0       	rjmp	.+14     	; 0x1df2 <enc28j60PacketReceive+0xc8>
        } else {
                enc28j60Write(ERXRDPTL, (gNextPacketPtr-1)&0xFF);
    1de4:	60 0f       	add	r22, r16
    1de6:	8c e0       	ldi	r24, 0x0C	; 12
    1de8:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
                enc28j60Write(ERXRDPTH, (gNextPacketPtr-1)>>8);
    1dec:	01 50       	subi	r16, 0x01	; 1
    1dee:	11 09       	sbc	r17, r1
    1df0:	61 2f       	mov	r22, r17
    1df2:	8d e0       	ldi	r24, 0x0D	; 13
    1df4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <enc28j60Write>
        }
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    1df8:	40 e4       	ldi	r20, 0x40	; 64
    1dfa:	6e e1       	ldi	r22, 0x1E	; 30
    1dfc:	80 e8       	ldi	r24, 0x80	; 128
    1dfe:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <enc28j60WriteOp>
	return(len);
    1e02:	ce 01       	movw	r24, r28
    1e04:	02 c0       	rjmp	.+4      	; 0x1e0a <enc28j60PacketReceive+0xe0>
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) )
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	90 e0       	ldi	r25, 0x00	; 0
                enc28j60Write(ERXRDPTH, (gNextPacketPtr-1)>>8);
        }
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
    1e0a:	df 91       	pop	r29
    1e0c:	cf 91       	pop	r28
    1e0e:	1f 91       	pop	r17
    1e10:	0f 91       	pop	r16
    1e12:	ff 90       	pop	r15
    1e14:	ef 90       	pop	r14
    1e16:	df 90       	pop	r13
    1e18:	cf 90       	pop	r12
    1e1a:	bf 90       	pop	r11
    1e1c:	af 90       	pop	r10
    1e1e:	9f 90       	pop	r9
    1e20:	08 95       	ret

00001e22 <find_key_val>:
//
// The returned value is stored in strbuf. You must allocate
// enough storage for strbuf, maxlen is the size of strbuf.
// I.e the value it is declated with: strbuf[5]-> maxlen=5
uint8_t find_key_val(char *str,char *strbuf, uint8_t maxlen,char *key)
{
    1e22:	cf 93       	push	r28
    1e24:	df 93       	push	r29
        uint8_t found=0;
        uint8_t i=0;
        char *kp;
        kp=key;
    1e26:	f9 01       	movw	r30, r18
// The returned value is stored in strbuf. You must allocate
// enough storage for strbuf, maxlen is the size of strbuf.
// I.e the value it is declated with: strbuf[5]-> maxlen=5
uint8_t find_key_val(char *str,char *strbuf, uint8_t maxlen,char *key)
{
        uint8_t found=0;
    1e28:	50 e0       	ldi	r21, 0x00	; 0
        uint8_t i=0;
        char *kp;
        kp=key;
        while(*str &&  *str!=' ' && *str!='\n' && found==0){
    1e2a:	ec 01       	movw	r28, r24
    1e2c:	a8 81       	ld	r26, Y
    1e2e:	ba 2f       	mov	r27, r26
    1e30:	bf 7d       	andi	r27, 0xDF	; 223
    1e32:	01 f1       	breq	.+64     	; 0x1e74 <find_key_val+0x52>
    1e34:	aa 30       	cpi	r26, 0x0A	; 10
    1e36:	f1 f0       	breq	.+60     	; 0x1e74 <find_key_val+0x52>
    1e38:	51 11       	cpse	r21, r1
    1e3a:	16 c0       	rjmp	.+44     	; 0x1e68 <find_key_val+0x46>
                if (*str == *kp){
    1e3c:	b0 81       	ld	r27, Z
    1e3e:	ab 13       	cpse	r26, r27
    1e40:	10 c0       	rjmp	.+32     	; 0x1e62 <find_key_val+0x40>
                        kp++;
                        if (*kp == '\0'){
    1e42:	a1 81       	ldd	r26, Z+1	; 0x01
    1e44:	aa 23       	and	r26, r26
    1e46:	11 f0       	breq	.+4      	; 0x1e4c <find_key_val+0x2a>
        uint8_t i=0;
        char *kp;
        kp=key;
        while(*str &&  *str!=' ' && *str!='\n' && found==0){
                if (*str == *kp){
                        kp++;
    1e48:	31 96       	adiw	r30, 0x01	; 1
    1e4a:	0c c0       	rjmp	.+24     	; 0x1e64 <find_key_val+0x42>
                        if (*kp == '\0'){
                                str++;
    1e4c:	dc 01       	movw	r26, r24
    1e4e:	11 96       	adiw	r26, 0x01	; 1
                                kp=key;
                                if (*str == '='){
    1e50:	51 e0       	ldi	r21, 0x01	; 1
    1e52:	ec 01       	movw	r28, r24
    1e54:	89 81       	ldd	r24, Y+1	; 0x01
    1e56:	8d 33       	cpi	r24, 0x3D	; 61
    1e58:	09 f0       	breq	.+2      	; 0x1e5c <find_key_val+0x3a>
    1e5a:	50 e0       	ldi	r21, 0x00	; 0
        while(*str &&  *str!=' ' && *str!='\n' && found==0){
                if (*str == *kp){
                        kp++;
                        if (*kp == '\0'){
                                str++;
                                kp=key;
    1e5c:	f9 01       	movw	r30, r18
        kp=key;
        while(*str &&  *str!=' ' && *str!='\n' && found==0){
                if (*str == *kp){
                        kp++;
                        if (*kp == '\0'){
                                str++;
    1e5e:	cd 01       	movw	r24, r26
    1e60:	01 c0       	rjmp	.+2      	; 0x1e64 <find_key_val+0x42>
                                if (*str == '='){
                                        found=1;
                                }
                        }
                }else{
                        kp=key;
    1e62:	f9 01       	movw	r30, r18
                }
                str++;
    1e64:	01 96       	adiw	r24, 0x01	; 1
    1e66:	e1 cf       	rjmp	.-62     	; 0x1e2a <find_key_val+0x8>
    1e68:	dc 01       	movw	r26, r24
// The returned value is stored in strbuf. You must allocate
// enough storage for strbuf, maxlen is the size of strbuf.
// I.e the value it is declated with: strbuf[5]-> maxlen=5
uint8_t find_key_val(char *str,char *strbuf, uint8_t maxlen,char *key)
{
        uint8_t found=0;
    1e6a:	fb 01       	movw	r30, r22
                }
                str++;
        }
        if (found==1){
                // copy the value to a buffer and terminate it with '\0'
                while(*str &&  *str!=' ' && *str!='\n' && *str!='&' && i<maxlen-1){
    1e6c:	50 e0       	ldi	r21, 0x00	; 0
    1e6e:	41 50       	subi	r20, 0x01	; 1
    1e70:	51 09       	sbc	r21, r1
    1e72:	0e c0       	rjmp	.+28     	; 0x1e90 <find_key_val+0x6e>
                }else{
                        kp=key;
                }
                str++;
        }
        if (found==1){
    1e74:	51 30       	cpi	r21, 0x01	; 1
    1e76:	c1 f3       	breq	.-16     	; 0x1e68 <find_key_val+0x46>
// enough storage for strbuf, maxlen is the size of strbuf.
// I.e the value it is declated with: strbuf[5]-> maxlen=5
uint8_t find_key_val(char *str,char *strbuf, uint8_t maxlen,char *key)
{
        uint8_t found=0;
        uint8_t i=0;
    1e78:	80 e0       	ldi	r24, 0x00	; 0
    1e7a:	11 c0       	rjmp	.+34     	; 0x1e9e <find_key_val+0x7c>
                }
                str++;
        }
        if (found==1){
                // copy the value to a buffer and terminate it with '\0'
                while(*str &&  *str!=' ' && *str!='\n' && *str!='&' && i<maxlen-1){
    1e7c:	9a 30       	cpi	r25, 0x0A	; 10
    1e7e:	71 f0       	breq	.+28     	; 0x1e9c <find_key_val+0x7a>
    1e80:	96 32       	cpi	r25, 0x26	; 38
    1e82:	61 f0       	breq	.+24     	; 0x1e9c <find_key_val+0x7a>
    1e84:	28 2f       	mov	r18, r24
    1e86:	30 e0       	ldi	r19, 0x00	; 0
    1e88:	24 17       	cp	r18, r20
    1e8a:	35 07       	cpc	r19, r21
    1e8c:	3c f4       	brge	.+14     	; 0x1e9c <find_key_val+0x7a>
                        *strbuf=*str;
    1e8e:	91 93       	st	Z+, r25
    1e90:	8e 2f       	mov	r24, r30
    1e92:	86 1b       	sub	r24, r22
                }
                str++;
        }
        if (found==1){
                // copy the value to a buffer and terminate it with '\0'
                while(*str &&  *str!=' ' && *str!='\n' && *str!='&' && i<maxlen-1){
    1e94:	9d 91       	ld	r25, X+
    1e96:	29 2f       	mov	r18, r25
    1e98:	2f 7d       	andi	r18, 0xDF	; 223
    1e9a:	81 f7       	brne	.-32     	; 0x1e7c <find_key_val+0x5a>
                        *strbuf=*str;
                        i++;
                        str++;
                        strbuf++;
                }
                *strbuf='\0';
    1e9c:	10 82       	st	Z, r1
        }
        // return the length of the value
        return(i);
}
    1e9e:	df 91       	pop	r29
    1ea0:	cf 91       	pop	r28
    1ea2:	08 95       	ret

00001ea4 <dnslkup_haveanswer>:


uint8_t dnslkup_haveanswer(void)
{       
        return(haveDNSanswer);
}
    1ea4:	80 91 50 05 	lds	r24, 0x0550
    1ea8:	08 95       	ret

00001eaa <dnslkup_getip>:
}

uint8_t *dnslkup_getip(void)
{       
        return(dns_answerip);
}
    1eaa:	8c e4       	ldi	r24, 0x4C	; 76
    1eac:	95 e0       	ldi	r25, 0x05	; 5
    1eae:	08 95       	ret

00001eb0 <dnslkup_request>:
// send a DNS udp request packet
// See http://www.ietf.org/rfc/rfc1034.txt 
// and http://www.ietf.org/rfc/rfc1035.txt
//
void dnslkup_request(uint8_t *buf,const char *progmem_hostname)
{
    1eb0:	0f 93       	push	r16
    1eb2:	1f 93       	push	r17
    1eb4:	cf 93       	push	r28
    1eb6:	df 93       	push	r29
    1eb8:	ec 01       	movw	r28, r24
    1eba:	16 2f       	mov	r17, r22
    1ebc:	07 2f       	mov	r16, r23
        uint8_t i,lenpos,lencnt;
        char c;
        haveDNSanswer=0;
    1ebe:	10 92 50 05 	sts	0x0550, r1
        dns_ansError=0;
    1ec2:	10 92 4b 05 	sts	0x054B, r1
        dnstid_l++; // increment for next request, finally wrap
    1ec6:	80 91 51 05 	lds	r24, 0x0551
    1eca:	8f 5f       	subi	r24, 0xFF	; 255
    1ecc:	80 93 51 05 	sts	0x0551, r24
        send_udp_prepare(buf,(DNSCLIENT_SRC_PORT_H<<8)|(dnstid_l&0xff),dnsip,53);
    1ed0:	68 2f       	mov	r22, r24
    1ed2:	70 e0       	ldi	r23, 0x00	; 0
    1ed4:	70 6e       	ori	r23, 0xE0	; 224
    1ed6:	25 e3       	ldi	r18, 0x35	; 53
    1ed8:	30 e0       	ldi	r19, 0x00	; 0
    1eda:	43 e1       	ldi	r20, 0x13	; 19
    1edc:	51 e0       	ldi	r21, 0x01	; 1
    1ede:	ce 01       	movw	r24, r28
    1ee0:	0e 94 a5 13 	call	0x274a	; 0x274a <send_udp_prepare>
        // fill tid:
        //buf[UDP_DATA_P] see below
        buf[UDP_DATA_P+1]=dnstid_l;
    1ee4:	80 91 51 05 	lds	r24, 0x0551
    1ee8:	8b a7       	std	Y+43, r24	; 0x2b
        buf[UDP_DATA_P+2]=1; // flags, standard recursive query
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	8c a7       	std	Y+44, r24	; 0x2c
    1eee:	fe 01       	movw	r30, r28
    1ef0:	bd 96       	adiw	r30, 0x2d	; 45
        i=3;
    1ef2:	83 e0       	ldi	r24, 0x03	; 3
        // most fields are zero, here we zero everything and fill later
        while(i<10){ 
                buf[UDP_DATA_P+i]=0;
    1ef4:	11 92       	st	Z+, r1
                i++;
    1ef6:	8f 5f       	subi	r24, 0xFF	; 255
        //buf[UDP_DATA_P] see below
        buf[UDP_DATA_P+1]=dnstid_l;
        buf[UDP_DATA_P+2]=1; // flags, standard recursive query
        i=3;
        // most fields are zero, here we zero everything and fill later
        while(i<10){ 
    1ef8:	8a 30       	cpi	r24, 0x0A	; 10
    1efa:	e1 f7       	brne	.-8      	; 0x1ef4 <dnslkup_request+0x44>
                buf[UDP_DATA_P+i]=0;
                i++;
        }
        buf[UDP_DATA_P+5]=1; // 1 question
    1efc:	81 e0       	ldi	r24, 0x01	; 1
    1efe:	8f a7       	std	Y+47, r24	; 0x2f
        // 
        // the first len starts at i=12
        lenpos=12;
        i=13;
        lencnt=0;
        while ((c = pgm_read_byte(progmem_hostname++))) {
    1f00:	e1 2f       	mov	r30, r17
    1f02:	f0 2f       	mov	r31, r16
        // www.twitter.com would become: 3www7twitter3com
        // 
        // the first len starts at i=12
        lenpos=12;
        i=13;
        lencnt=0;
    1f04:	20 e0       	ldi	r18, 0x00	; 0
        // we ask for is always length, string, length, string, ...
        // for earch portion of the name.
        // www.twitter.com would become: 3www7twitter3com
        // 
        // the first len starts at i=12
        lenpos=12;
    1f06:	3c e0       	ldi	r19, 0x0C	; 12
    1f08:	4d e0       	ldi	r20, 0x0D	; 13
    1f0a:	41 1b       	sub	r20, r17
    1f0c:	64 2f       	mov	r22, r20
    1f0e:	6e 0f       	add	r22, r30
        i=13;
        lencnt=0;
        while ((c = pgm_read_byte(progmem_hostname++))) {
    1f10:	54 91       	lpm	r21, Z
    1f12:	86 2f       	mov	r24, r22
    1f14:	90 e0       	ldi	r25, 0x00	; 0
    1f16:	55 23       	and	r21, r21
    1f18:	89 f0       	breq	.+34     	; 0x1f3c <dnslkup_request+0x8c>
                if (c=='.'){
    1f1a:	5e 32       	cpi	r21, 0x2E	; 46
    1f1c:	39 f4       	brne	.+14     	; 0x1f2c <dnslkup_request+0x7c>
                        buf[UDP_DATA_P+lenpos]=lencnt;
    1f1e:	de 01       	movw	r26, r28
    1f20:	a3 0f       	add	r26, r19
    1f22:	b1 1d       	adc	r27, r1
    1f24:	9a 96       	adiw	r26, 0x2a	; 42
    1f26:	2c 93       	st	X, r18
    1f28:	36 2f       	mov	r19, r22
                        lencnt=0;
    1f2a:	20 e0       	ldi	r18, 0x00	; 0
                        lenpos=i;
                }
                buf[UDP_DATA_P+i]=c;
    1f2c:	de 01       	movw	r26, r28
    1f2e:	a8 0f       	add	r26, r24
    1f30:	b9 1f       	adc	r27, r25
    1f32:	9a 96       	adiw	r26, 0x2a	; 42
    1f34:	5c 93       	st	X, r21
                lencnt++;
    1f36:	2f 5f       	subi	r18, 0xFF	; 255
    1f38:	31 96       	adiw	r30, 0x01	; 1
    1f3a:	e8 cf       	rjmp	.-48     	; 0x1f0c <dnslkup_request+0x5c>
                i++;
        }
        buf[UDP_DATA_P+lenpos]=lencnt-1;
    1f3c:	fe 01       	movw	r30, r28
    1f3e:	e3 0f       	add	r30, r19
    1f40:	f1 1d       	adc	r31, r1
    1f42:	21 50       	subi	r18, 0x01	; 1
    1f44:	22 a7       	std	Z+42, r18	; 0x2a
        buf[UDP_DATA_P+i]=0; // terminate with zero, means root domain.
    1f46:	fe 01       	movw	r30, r28
    1f48:	e8 0f       	add	r30, r24
    1f4a:	f9 1f       	adc	r31, r25
    1f4c:	12 a6       	std	Z+42, r1	; 0x2a
        i++;
    1f4e:	81 e0       	ldi	r24, 0x01	; 1
    1f50:	86 0f       	add	r24, r22
        buf[UDP_DATA_P+i]=0;
    1f52:	fe 01       	movw	r30, r28
    1f54:	e8 0f       	add	r30, r24
    1f56:	f1 1d       	adc	r31, r1
    1f58:	12 a6       	std	Z+42, r1	; 0x2a
        i++;
    1f5a:	82 e0       	ldi	r24, 0x02	; 2
    1f5c:	86 0f       	add	r24, r22
        buf[UDP_DATA_P+i]=1; // type A
    1f5e:	fe 01       	movw	r30, r28
    1f60:	e8 0f       	add	r30, r24
    1f62:	f1 1d       	adc	r31, r1
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	82 a7       	std	Z+42, r24	; 0x2a
        i++;
    1f68:	93 e0       	ldi	r25, 0x03	; 3
    1f6a:	96 0f       	add	r25, r22
        buf[UDP_DATA_P+i]=0; 
    1f6c:	fe 01       	movw	r30, r28
    1f6e:	e9 0f       	add	r30, r25
    1f70:	f1 1d       	adc	r31, r1
    1f72:	12 a6       	std	Z+42, r1	; 0x2a
        i++;
    1f74:	94 e0       	ldi	r25, 0x04	; 4
    1f76:	96 0f       	add	r25, r22
        buf[UDP_DATA_P+i]=1; // class IN
    1f78:	fe 01       	movw	r30, r28
    1f7a:	e9 0f       	add	r30, r25
    1f7c:	f1 1d       	adc	r31, r1
    1f7e:	82 a7       	std	Z+42, r24	; 0x2a
        i++;
        // we encode the length into the upper byte of the TID
        // this way we can easily jump over the query section
        // of the answer:
        buf[UDP_DATA_P]=i-12;
    1f80:	89 ef       	ldi	r24, 0xF9	; 249
    1f82:	86 0f       	add	r24, r22
    1f84:	8a a7       	std	Y+42, r24	; 0x2a
        buf[UDP_DATA_P+i]=1; // type A
        i++;
        buf[UDP_DATA_P+i]=0; 
        i++;
        buf[UDP_DATA_P+i]=1; // class IN
        i++;
    1f86:	6b 5f       	subi	r22, 0xFB	; 251
        // we encode the length into the upper byte of the TID
        // this way we can easily jump over the query section
        // of the answer:
        buf[UDP_DATA_P]=i-12;
        send_udp_transmit(buf,i);
    1f88:	ce 01       	movw	r24, r28
}
    1f8a:	df 91       	pop	r29
    1f8c:	cf 91       	pop	r28
    1f8e:	1f 91       	pop	r17
    1f90:	0f 91       	pop	r16
        i++;
        // we encode the length into the upper byte of the TID
        // this way we can easily jump over the query section
        // of the answer:
        buf[UDP_DATA_P]=i-12;
        send_udp_transmit(buf,i);
    1f92:	0c 94 1a 14 	jmp	0x2834	; 0x2834 <send_udp_transmit>

00001f96 <udp_client_check_for_dns_answer>:
}

// process the answer from the ntp server:
// return 1 on sucessful processing of answer.
// We set also the variable haveDNSanswer
uint8_t udp_client_check_for_dns_answer(uint8_t *buf,uint16_t plen){
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	fc 01       	movw	r30, r24
        uint8_t j,i;
        if (plen<70){
    1f9c:	66 34       	cpi	r22, 0x46	; 70
    1f9e:	71 05       	cpc	r23, r1
    1fa0:	08 f4       	brcc	.+2      	; 0x1fa4 <udp_client_check_for_dns_answer+0xe>
    1fa2:	55 c0       	rjmp	.+170    	; 0x204e <udp_client_check_for_dns_answer+0xb8>
                return(0);
        }
        if (buf[UDP_SRC_PORT_L_P]!=53){
    1fa4:	83 a1       	ldd	r24, Z+35	; 0x23
    1fa6:	85 33       	cpi	r24, 0x35	; 53
    1fa8:	09 f0       	breq	.+2      	; 0x1fac <udp_client_check_for_dns_answer+0x16>
    1faa:	51 c0       	rjmp	.+162    	; 0x204e <udp_client_check_for_dns_answer+0xb8>
                // not from a DNS
                return(0);
        }
        if (buf[UDP_DST_PORT_H_P]!=DNSCLIENT_SRC_PORT_H){ 
    1fac:	84 a1       	ldd	r24, Z+36	; 0x24
    1fae:	80 3e       	cpi	r24, 0xE0	; 224
    1fb0:	09 f0       	breq	.+2      	; 0x1fb4 <udp_client_check_for_dns_answer+0x1e>
    1fb2:	4d c0       	rjmp	.+154    	; 0x204e <udp_client_check_for_dns_answer+0xb8>
                return(0);
        }
        // we use the TID also as port:
        if (buf[UDP_DST_PORT_L_P]!=dnstid_l){ 
    1fb4:	85 a1       	ldd	r24, Z+37	; 0x25
    1fb6:	90 91 51 05 	lds	r25, 0x0551
    1fba:	89 13       	cpse	r24, r25
    1fbc:	48 c0       	rjmp	.+144    	; 0x204e <udp_client_check_for_dns_answer+0xb8>
        // is the packet for my IP:
        if(eth_type_is_ip_and_my_ip(buf,plen)==0){
                return(0);
        }
        */
        if (buf[UDP_DATA_P+1]!=dnstid_l){ 
    1fbe:	93 a5       	ldd	r25, Z+43	; 0x2b
    1fc0:	98 13       	cpse	r25, r24
    1fc2:	45 c0       	rjmp	.+138    	; 0x204e <udp_client_check_for_dns_answer+0xb8>
                return(0);
        }
        // check flags lower byte:
        if ((buf[UDP_DATA_P+3]&0x8F)!=0x80){ 
    1fc4:	85 a5       	ldd	r24, Z+45	; 0x2d
    1fc6:	8f 78       	andi	r24, 0x8F	; 143
    1fc8:	80 38       	cpi	r24, 0x80	; 128
    1fca:	11 f0       	breq	.+4      	; 0x1fd0 <udp_client_check_for_dns_answer+0x3a>
                // there is an error or server does not support recursive
                // queries. We can only work with servers that support recursive
                // queries.
                dns_ansError=1;
    1fcc:	81 e0       	ldi	r24, 0x01	; 1
    1fce:	28 c0       	rjmp	.+80     	; 0x2020 <udp_client_check_for_dns_answer+0x8a>
        //
        // UDP_DATA_P+12+querylen is first byte of first answer.
        // The answer contains again the domain name and we need to
        // jump over it to find the IP. This part can be abbreviated by
        // the use of 2 byte pointers. See RFC 1035.
        i=12+buf[UDP_DATA_P]; // we encoded the query len into tid
    1fd0:	92 a5       	ldd	r25, Z+42	; 0x2a
    1fd2:	2c e0       	ldi	r18, 0x0C	; 12
    1fd4:	29 0f       	add	r18, r25
        if (buf[UDP_DATA_P+i] & 0xc0){
    1fd6:	df 01       	movw	r26, r30
    1fd8:	a2 0f       	add	r26, r18
    1fda:	b1 1d       	adc	r27, r1
    1fdc:	9a 96       	adiw	r26, 0x2a	; 42
    1fde:	8c 91       	ld	r24, X
    1fe0:	80 7c       	andi	r24, 0xC0	; 192
    1fe2:	19 f0       	breq	.+6      	; 0x1fea <udp_client_check_for_dns_answer+0x54>
                // pointer
                i+=2;
    1fe4:	2e e0       	ldi	r18, 0x0E	; 14
    1fe6:	29 0f       	add	r18, r25
    1fe8:	13 c0       	rjmp	.+38     	; 0x2010 <udp_client_check_for_dns_answer+0x7a>
        }else{
                // we just search for the first, zero=root domain
                // all other octets must be non zero
                while(i<plen-UDP_DATA_P-7){
    1fea:	61 53       	subi	r22, 0x31	; 49
    1fec:	71 09       	sbc	r23, r1
    1fee:	82 2f       	mov	r24, r18
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	86 17       	cp	r24, r22
    1ff4:	97 07       	cpc	r25, r23
    1ff6:	60 f4       	brcc	.+24     	; 0x2010 <udp_client_check_for_dns_answer+0x7a>
                        i++;
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	82 0f       	add	r24, r18
                        if (buf[UDP_DATA_P+i]==0){
    1ffc:	df 01       	movw	r26, r30
    1ffe:	a8 0f       	add	r26, r24
    2000:	b1 1d       	adc	r27, r1
    2002:	9a 96       	adiw	r26, 0x2a	; 42
    2004:	9c 91       	ld	r25, X
    2006:	99 23       	and	r25, r25
    2008:	11 f0       	breq	.+4      	; 0x200e <udp_client_check_for_dns_answer+0x78>
                i+=2;
        }else{
                // we just search for the first, zero=root domain
                // all other octets must be non zero
                while(i<plen-UDP_DATA_P-7){
                        i++;
    200a:	28 2f       	mov	r18, r24
    200c:	f0 cf       	rjmp	.-32     	; 0x1fee <udp_client_check_for_dns_answer+0x58>
                        if (buf[UDP_DATA_P+i]==0){
                                i++;
    200e:	2e 5f       	subi	r18, 0xFE	; 254
                                break;
                        }
                }
        }
        // i is now pointing to the high octet of the type field
        if (buf[UDP_DATA_P+i+9] !=4 ){
    2010:	df 01       	movw	r26, r30
    2012:	a2 0f       	add	r26, r18
    2014:	b1 1d       	adc	r27, r1
    2016:	d3 96       	adiw	r26, 0x33	; 51
    2018:	8c 91       	ld	r24, X
    201a:	84 30       	cpi	r24, 0x04	; 4
    201c:	21 f0       	breq	.+8      	; 0x2026 <udp_client_check_for_dns_answer+0x90>
                dns_ansError=2; // not IPv4
    201e:	82 e0       	ldi	r24, 0x02	; 2
    2020:	80 93 4b 05 	sts	0x054B, r24
    2024:	14 c0       	rjmp	.+40     	; 0x204e <udp_client_check_for_dns_answer+0xb8>
                return(0);
        }
        i+=10;
    2026:	26 5f       	subi	r18, 0xF6	; 246
    2028:	ac e4       	ldi	r26, 0x4C	; 76
    202a:	b5 e0       	ldi	r27, 0x05	; 5
    202c:	80 e0       	ldi	r24, 0x00	; 0
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	e2 0f       	add	r30, r18
    2032:	f1 1d       	adc	r31, r1
    2034:	ef 01       	movw	r28, r30
    2036:	c8 0f       	add	r28, r24
    2038:	d9 1f       	adc	r29, r25
        j=0;
        while(j<4){
                dns_answerip[j]=buf[UDP_DATA_P+i+j];
    203a:	2a a5       	ldd	r18, Y+42	; 0x2a
    203c:	2d 93       	st	X+, r18
    203e:	01 96       	adiw	r24, 0x01	; 1
                dns_ansError=2; // not IPv4
                return(0);
        }
        i+=10;
        j=0;
        while(j<4){
    2040:	84 30       	cpi	r24, 0x04	; 4
    2042:	91 05       	cpc	r25, r1
    2044:	b9 f7       	brne	.-18     	; 0x2034 <udp_client_check_for_dns_answer+0x9e>
                dns_answerip[j]=buf[UDP_DATA_P+i+j];
                j++;
        }
        haveDNSanswer=1;
    2046:	81 e0       	ldi	r24, 0x01	; 1
    2048:	80 93 50 05 	sts	0x0550, r24
        return(1);
    204c:	01 c0       	rjmp	.+2      	; 0x2050 <udp_client_check_for_dns_answer+0xba>
// return 1 on sucessful processing of answer.
// We set also the variable haveDNSanswer
uint8_t udp_client_check_for_dns_answer(uint8_t *buf,uint16_t plen){
        uint8_t j,i;
        if (plen<70){
                return(0);
    204e:	80 e0       	ldi	r24, 0x00	; 0
                dns_answerip[j]=buf[UDP_DATA_P+i+j];
                j++;
        }
        haveDNSanswer=1;
        return(1);
}
    2050:	df 91       	pop	r29
    2052:	cf 91       	pop	r28
    2054:	08 95       	ret

00002056 <www_client_internal_result_callback>:
                return(len);
        }
        return(0);
}

uint8_t www_client_internal_result_callback(uint8_t fd, uint8_t statuscode, uint16_t datapos, uint16_t len_of_data){
    2056:	ef 92       	push	r14
    2058:	ff 92       	push	r15
    205a:	0f 93       	push	r16
    205c:	1f 93       	push	r17
    205e:	cf 93       	push	r28
    2060:	df 93       	push	r29
    2062:	89 01       	movw	r16, r18
        if (fd!=www_fd){
    2064:	90 91 76 05 	lds	r25, 0x0576
    2068:	89 17       	cp	r24, r25
    206a:	51 f0       	breq	.+20     	; 0x2080 <www_client_internal_result_callback+0x2a>
                (*client_browser_callback)(4,0,0);
    206c:	e0 91 73 05 	lds	r30, 0x0573
    2070:	f0 91 74 05 	lds	r31, 0x0574
    2074:	40 e0       	ldi	r20, 0x00	; 0
    2076:	50 e0       	ldi	r21, 0x00	; 0
    2078:	60 e0       	ldi	r22, 0x00	; 0
    207a:	70 e0       	ldi	r23, 0x00	; 0
    207c:	84 e0       	ldi	r24, 0x04	; 4
    207e:	2b c0       	rjmp	.+86     	; 0x20d6 <www_client_internal_result_callback+0x80>
                return(0);
        }
        if (statuscode==0 && len_of_data>12){
    2080:	61 11       	cpse	r22, r1
    2082:	2a c0       	rjmp	.+84     	; 0x20d8 <www_client_internal_result_callback+0x82>
    2084:	2d 30       	cpi	r18, 0x0D	; 13
    2086:	31 05       	cpc	r19, r1
    2088:	38 f1       	brcs	.+78     	; 0x20d8 <www_client_internal_result_callback+0x82>
                // we might have a http status code
                if (client_browser_callback){
    208a:	c0 91 73 05 	lds	r28, 0x0573
    208e:	d0 91 74 05 	lds	r29, 0x0574
    2092:	20 97       	sbiw	r28, 0x00	; 0
    2094:	09 f1       	breq	.+66     	; 0x20d8 <www_client_internal_result_callback+0x82>
                        if (strncmp("200",(char *)&(bufptr[datapos+9]),3)==0){
    2096:	e0 90 67 05 	lds	r14, 0x0567
    209a:	f0 90 68 05 	lds	r15, 0x0568
    209e:	ba 01       	movw	r22, r20
    20a0:	67 5f       	subi	r22, 0xF7	; 247
    20a2:	7f 4f       	sbci	r23, 0xFF	; 255
    20a4:	6e 0d       	add	r22, r14
    20a6:	7f 1d       	adc	r23, r15
    20a8:	43 e0       	ldi	r20, 0x03	; 3
    20aa:	50 e0       	ldi	r21, 0x00	; 0
    20ac:	83 e4       	ldi	r24, 0x43	; 67
    20ae:	91 e0       	ldi	r25, 0x01	; 1
    20b0:	0e 94 e8 3d 	call	0x7bd0	; 0x7bd0 <strncmp>
    20b4:	f7 01       	movw	r30, r14
    20b6:	66 a5       	ldd	r22, Z+46	; 0x2e
                                (*client_browser_callback)(0,((uint16_t)TCP_SRC_PORT_H_P+(bufptr[TCP_HEADER_LEN_P]>>4)*4),len_of_data);
    20b8:	62 95       	swap	r22
    20ba:	6f 70       	andi	r22, 0x0F	; 15
    20bc:	f4 e0       	ldi	r31, 0x04	; 4
    20be:	6f 9f       	mul	r22, r31
    20c0:	b0 01       	movw	r22, r0
    20c2:	11 24       	eor	r1, r1
    20c4:	6e 5d       	subi	r22, 0xDE	; 222
    20c6:	7f 4f       	sbci	r23, 0xFF	; 255
    20c8:	a8 01       	movw	r20, r16
                return(0);
        }
        if (statuscode==0 && len_of_data>12){
                // we might have a http status code
                if (client_browser_callback){
                        if (strncmp("200",(char *)&(bufptr[datapos+9]),3)==0){
    20ca:	89 2b       	or	r24, r25
    20cc:	11 f4       	brne	.+4      	; 0x20d2 <www_client_internal_result_callback+0x7c>
                                (*client_browser_callback)(0,((uint16_t)TCP_SRC_PORT_H_P+(bufptr[TCP_HEADER_LEN_P]>>4)*4),len_of_data);
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	01 c0       	rjmp	.+2      	; 0x20d4 <www_client_internal_result_callback+0x7e>
                        }else{
                                (*client_browser_callback)(1,((uint16_t)TCP_SRC_PORT_H_P+(bufptr[TCP_HEADER_LEN_P]>>4)*4),len_of_data);
    20d2:	81 e0       	ldi	r24, 0x01	; 1
    20d4:	fe 01       	movw	r30, r28
    20d6:	09 95       	icall
                        }
                }
        }
        return(0);
}
    20d8:	80 e0       	ldi	r24, 0x00	; 0
    20da:	df 91       	pop	r29
    20dc:	cf 91       	pop	r28
    20de:	1f 91       	pop	r17
    20e0:	0f 91       	pop	r16
    20e2:	ff 90       	pop	r15
    20e4:	ef 90       	pop	r14
    20e6:	08 95       	ret

000020e8 <checksum>:
//
// For more information on how this algorithm works see:
// http://www.netfor2.com/checksum.html
// http://www.msc.uky.edu/ken/cs471/notes/chap3.htm
// The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
uint16_t checksum(uint8_t *buf, uint16_t len,uint8_t type){
    20e8:	ff 92       	push	r15
    20ea:	0f 93       	push	r16
    20ec:	1f 93       	push	r17
    20ee:	cf 93       	push	r28
    20f0:	df 93       	push	r29
    20f2:	fb 01       	movw	r30, r22

        //if(type==0){    
        //        // do not add anything, standard IP checksum as described above
        //        // Usable for ICMP and IP header
        //}
        if(type==1){
    20f4:	41 30       	cpi	r20, 0x01	; 1
    20f6:	51 f4       	brne	.+20     	; 0x210c <checksum+0x24>
                sum+=IP_PROTO_UDP_V; // protocol udp
                // the length here is the length of udp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real udp len
    20f8:	ab 01       	movw	r20, r22
    20fa:	48 50       	subi	r20, 0x08	; 8
    20fc:	51 09       	sbc	r21, r1
    20fe:	60 e0       	ldi	r22, 0x00	; 0
    2100:	70 e0       	ldi	r23, 0x00	; 0
    2102:	4f 5e       	subi	r20, 0xEF	; 239
    2104:	5f 4f       	sbci	r21, 0xFF	; 255
    2106:	6f 4f       	sbci	r22, 0xFF	; 255
    2108:	7f 4f       	sbci	r23, 0xFF	; 255
    210a:	0f c0       	rjmp	.+30     	; 0x212a <checksum+0x42>
        }
        if(type==2){
    210c:	42 30       	cpi	r20, 0x02	; 2
    210e:	51 f4       	brne	.+20     	; 0x2124 <checksum+0x3c>
                sum+=IP_PROTO_TCP_V; 
                // the length here is the length of tcp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
    2110:	ab 01       	movw	r20, r22
    2112:	48 50       	subi	r20, 0x08	; 8
    2114:	51 09       	sbc	r21, r1
    2116:	60 e0       	ldi	r22, 0x00	; 0
    2118:	70 e0       	ldi	r23, 0x00	; 0
    211a:	4a 5f       	subi	r20, 0xFA	; 250
    211c:	5f 4f       	sbci	r21, 0xFF	; 255
    211e:	6f 4f       	sbci	r22, 0xFF	; 255
    2120:	7f 4f       	sbci	r23, 0xFF	; 255
    2122:	03 c0       	rjmp	.+6      	; 0x212a <checksum+0x42>
// The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
uint16_t checksum(uint8_t *buf, uint16_t len,uint8_t type){
        // type 0=ip , icmp
        //      1=udp
        //      2=tcp
        uint32_t sum = 0;
    2124:	40 e0       	ldi	r20, 0x00	; 0
    2126:	50 e0       	ldi	r21, 0x00	; 0
    2128:	ba 01       	movw	r22, r20
    212a:	ef 01       	movw	r28, r30
    212c:	dc 01       	movw	r26, r24
                // the length here is the length of tcp (data+header len)
                // =length given to this function - (IP.scr+IP.dst length)
                sum+=len-8; // = real tcp len
        }
        // build the sum of 16bit words
        while(len >1){
    212e:	c2 30       	cpi	r28, 0x02	; 2
    2130:	d1 05       	cpc	r29, r1
    2132:	98 f0       	brcs	.+38     	; 0x215a <checksum+0x72>
                sum += 0xFFFF & (((uint32_t)*buf<<8)|*(buf+1));
    2134:	0c 91       	ld	r16, X
    2136:	10 e0       	ldi	r17, 0x00	; 0
    2138:	20 e0       	ldi	r18, 0x00	; 0
    213a:	30 e0       	ldi	r19, 0x00	; 0
    213c:	32 2f       	mov	r19, r18
    213e:	21 2f       	mov	r18, r17
    2140:	10 2f       	mov	r17, r16
    2142:	00 27       	eor	r16, r16
    2144:	11 96       	adiw	r26, 0x01	; 1
    2146:	fc 90       	ld	r15, X
    2148:	11 97       	sbiw	r26, 0x01	; 1
    214a:	0f 29       	or	r16, r15
    214c:	40 0f       	add	r20, r16
    214e:	51 1f       	adc	r21, r17
    2150:	62 1f       	adc	r22, r18
    2152:	73 1f       	adc	r23, r19
                buf+=2;
    2154:	12 96       	adiw	r26, 0x02	; 2
                len-=2;
    2156:	22 97       	sbiw	r28, 0x02	; 2
    2158:	ea cf       	rjmp	.-44     	; 0x212e <checksum+0x46>
    215a:	df 01       	movw	r26, r30
    215c:	ae 7f       	andi	r26, 0xFE	; 254
    215e:	a8 0f       	add	r26, r24
    2160:	b9 1f       	adc	r27, r25
        }
        // if there is a byte left then add it (padded with zero)
        if (len){
    2162:	e0 ff       	sbrs	r30, 0
    2164:	0c c0       	rjmp	.+24     	; 0x217e <checksum+0x96>
                sum += ((uint32_t)(0xFF & *buf))<<8;
    2166:	8c 91       	ld	r24, X
    2168:	90 e0       	ldi	r25, 0x00	; 0
    216a:	a0 e0       	ldi	r26, 0x00	; 0
    216c:	b0 e0       	ldi	r27, 0x00	; 0
    216e:	ba 2f       	mov	r27, r26
    2170:	a9 2f       	mov	r26, r25
    2172:	98 2f       	mov	r25, r24
    2174:	88 27       	eor	r24, r24
        }
        // now calculate the sum over the bytes in the sum
        // until the result is only 16bit long
        while (sum>>16){
                sum = (sum & 0xFFFF)+(sum >> 16);
    2176:	48 0f       	add	r20, r24
    2178:	59 1f       	adc	r21, r25
    217a:	6a 1f       	adc	r22, r26
    217c:	7b 1f       	adc	r23, r27
        if (len){
                sum += ((uint32_t)(0xFF & *buf))<<8;
        }
        // now calculate the sum over the bytes in the sum
        // until the result is only 16bit long
        while (sum>>16){
    217e:	cb 01       	movw	r24, r22
    2180:	aa 27       	eor	r26, r26
    2182:	bb 27       	eor	r27, r27
    2184:	00 97       	sbiw	r24, 0x00	; 0
    2186:	a1 05       	cpc	r26, r1
    2188:	b1 05       	cpc	r27, r1
    218a:	19 f0       	breq	.+6      	; 0x2192 <checksum+0xaa>
                sum = (sum & 0xFFFF)+(sum >> 16);
    218c:	66 27       	eor	r22, r22
    218e:	77 27       	eor	r23, r23
    2190:	f2 cf       	rjmp	.-28     	; 0x2176 <checksum+0x8e>
        }
        // build 1's complement:
        return( (uint16_t) sum ^ 0xFFFF);
    2192:	ca 01       	movw	r24, r20
    2194:	80 95       	com	r24
    2196:	90 95       	com	r25
}
    2198:	df 91       	pop	r29
    219a:	cf 91       	pop	r28
    219c:	1f 91       	pop	r17
    219e:	0f 91       	pop	r16
    21a0:	ff 90       	pop	r15
    21a2:	08 95       	ret

000021a4 <init_ip_arp_udp_tcp>:

// This initializes the web server
// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint16_t port){
        uint8_t i=0;
        wwwport_h=(port>>8)&0xff;
    21a4:	50 93 83 05 	sts	0x0583, r21
        wwwport_l=(port&0xff);
    21a8:	40 93 04 01 	sts	0x0104, r20
    21ac:	fb 01       	movw	r30, r22
    21ae:	a4 e5       	ldi	r26, 0x54	; 84
    21b0:	b5 e0       	ldi	r27, 0x05	; 5
        while(i<4){
                ipaddr[i]=myip[i];
    21b2:	21 91       	ld	r18, Z+
    21b4:	2d 93       	st	X+, r18
// you must call this function once before you use any of the other functions:
void init_ip_arp_udp_tcp(uint8_t *mymac,uint8_t *myip,uint16_t port){
        uint8_t i=0;
        wwwport_h=(port>>8)&0xff;
        wwwport_l=(port&0xff);
        while(i<4){
    21b6:	25 e0       	ldi	r18, 0x05	; 5
    21b8:	a8 35       	cpi	r26, 0x58	; 88
    21ba:	b2 07       	cpc	r27, r18
    21bc:	d1 f7       	brne	.-12     	; 0x21b2 <init_ip_arp_udp_tcp+0xe>
    21be:	fc 01       	movw	r30, r24
    21c0:	a8 e5       	ldi	r26, 0x58	; 88
    21c2:	b5 e0       	ldi	r27, 0x05	; 5
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
                macaddr[i]=mymac[i];
    21c4:	81 91       	ld	r24, Z+
    21c6:	8d 93       	st	X+, r24
        while(i<4){
                ipaddr[i]=myip[i];
                i++;
        }
        i=0;
        while(i<6){
    21c8:	85 e0       	ldi	r24, 0x05	; 5
    21ca:	ae 35       	cpi	r26, 0x5E	; 94
    21cc:	b8 07       	cpc	r27, r24
    21ce:	d1 f7       	brne	.-12     	; 0x21c4 <init_ip_arp_udp_tcp+0x20>
                macaddr[i]=mymac[i];
                i++;
        }
}
    21d0:	08 95       	ret

000021d2 <check_ip_message_is_from>:

uint8_t check_ip_message_is_from(uint8_t *buf,uint8_t *ip)
{
    21d2:	dc 01       	movw	r26, r24
    21d4:	5a 96       	adiw	r26, 0x1a	; 26
    21d6:	fb 01       	movw	r30, r22
        uint8_t i=0;
    21d8:	80 e0       	ldi	r24, 0x00	; 0
        while(i<4){
                if(buf[IP_SRC_P+i]!=ip[i]){
    21da:	2d 91       	ld	r18, X+
    21dc:	91 91       	ld	r25, Z+
    21de:	29 13       	cpse	r18, r25
    21e0:	05 c0       	rjmp	.+10     	; 0x21ec <check_ip_message_is_from+0x1a>
                        return(0);
                }
                i++;
    21e2:	8f 5f       	subi	r24, 0xFF	; 255
}

uint8_t check_ip_message_is_from(uint8_t *buf,uint8_t *ip)
{
        uint8_t i=0;
        while(i<4){
    21e4:	84 30       	cpi	r24, 0x04	; 4
    21e6:	c9 f7       	brne	.-14     	; 0x21da <check_ip_message_is_from+0x8>
                if(buf[IP_SRC_P+i]!=ip[i]){
                        return(0);
                }
                i++;
        }
        return(1);
    21e8:	81 e0       	ldi	r24, 0x01	; 1
}
    21ea:	08 95       	ret
uint8_t check_ip_message_is_from(uint8_t *buf,uint8_t *ip)
{
        uint8_t i=0;
        while(i<4){
                if(buf[IP_SRC_P+i]!=ip[i]){
                        return(0);
    21ec:	80 e0       	ldi	r24, 0x00	; 0
    21ee:	08 95       	ret

000021f0 <eth_type_is_arp_and_my_ip>:
}

uint8_t eth_type_is_arp_and_my_ip(uint8_t *buf,uint16_t len){
        uint8_t i=0;
        //  
        if (len<41){
    21f0:	69 32       	cpi	r22, 0x29	; 41
    21f2:	71 05       	cpc	r23, r1
    21f4:	a8 f0       	brcs	.+42     	; 0x2220 <eth_type_is_arp_and_my_ip+0x30>
                return(0);
        }
        if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || 
    21f6:	fc 01       	movw	r30, r24
    21f8:	24 85       	ldd	r18, Z+12	; 0x0c
    21fa:	28 30       	cpi	r18, 0x08	; 8
    21fc:	89 f4       	brne	.+34     	; 0x2220 <eth_type_is_arp_and_my_ip+0x30>
    21fe:	25 85       	ldd	r18, Z+13	; 0x0d
    2200:	26 30       	cpi	r18, 0x06	; 6
    2202:	71 f4       	brne	.+28     	; 0x2220 <eth_type_is_arp_and_my_ip+0x30>
    2204:	dc 01       	movw	r26, r24
    2206:	96 96       	adiw	r26, 0x26	; 38
    2208:	e4 e5       	ldi	r30, 0x54	; 84
    220a:	f5 e0       	ldi	r31, 0x05	; 5
           buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V){
                return(0);
        }
        while(i<4){
                if(buf[ETH_ARP_DST_IP_P+i] != ipaddr[i]){
    220c:	9d 91       	ld	r25, X+
    220e:	81 91       	ld	r24, Z+
    2210:	98 13       	cpse	r25, r24
    2212:	06 c0       	rjmp	.+12     	; 0x2220 <eth_type_is_arp_and_my_ip+0x30>
        }
        if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || 
           buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V){
                return(0);
        }
        while(i<4){
    2214:	85 e0       	ldi	r24, 0x05	; 5
    2216:	e8 35       	cpi	r30, 0x58	; 88
    2218:	f8 07       	cpc	r31, r24
    221a:	c1 f7       	brne	.-16     	; 0x220c <eth_type_is_arp_and_my_ip+0x1c>
                if(buf[ETH_ARP_DST_IP_P+i] != ipaddr[i]){
                        return(0);
                }
                i++;
        }
        return(1);
    221c:	81 e0       	ldi	r24, 0x01	; 1
}
    221e:	08 95       	ret

uint8_t eth_type_is_arp_and_my_ip(uint8_t *buf,uint16_t len){
        uint8_t i=0;
        //  
        if (len<41){
                return(0);
    2220:	80 e0       	ldi	r24, 0x00	; 0
    2222:	08 95       	ret

00002224 <eth_type_is_ip_and_my_ip>:
                i++;
        }
        return(1);
}

uint8_t eth_type_is_ip_and_my_ip(uint8_t *buf,uint16_t len){
    2224:	fc 01       	movw	r30, r24
        uint8_t i=0;
        //eth+ip+udp header is 42
        if (len<42){
    2226:	6a 32       	cpi	r22, 0x2A	; 42
    2228:	71 05       	cpc	r23, r1
    222a:	b0 f0       	brcs	.+44     	; 0x2258 <eth_type_is_ip_and_my_ip+0x34>
                return(0);
        }
        if(buf[ETH_TYPE_H_P]!=ETHTYPE_IP_H_V || 
    222c:	84 85       	ldd	r24, Z+12	; 0x0c
    222e:	88 30       	cpi	r24, 0x08	; 8
    2230:	99 f4       	brne	.+38     	; 0x2258 <eth_type_is_ip_and_my_ip+0x34>
    2232:	85 85       	ldd	r24, Z+13	; 0x0d
    2234:	81 11       	cpse	r24, r1
    2236:	10 c0       	rjmp	.+32     	; 0x2258 <eth_type_is_ip_and_my_ip+0x34>
           buf[ETH_TYPE_L_P]!=ETHTYPE_IP_L_V){
                return(0);
        }
        if (buf[IP_HEADER_LEN_VER_P]!=0x45){
    2238:	86 85       	ldd	r24, Z+14	; 0x0e
    223a:	85 34       	cpi	r24, 0x45	; 69
    223c:	69 f4       	brne	.+26     	; 0x2258 <eth_type_is_ip_and_my_ip+0x34>
    223e:	7e 96       	adiw	r30, 0x1e	; 30
    2240:	a4 e5       	ldi	r26, 0x54	; 84
    2242:	b5 e0       	ldi	r27, 0x05	; 5
                // must be IP V4 and 20 byte header
                return(0);
        }
        while(i<4){
                if(buf[IP_DST_P+i]!=ipaddr[i]){
    2244:	91 91       	ld	r25, Z+
    2246:	8d 91       	ld	r24, X+
    2248:	98 13       	cpse	r25, r24
    224a:	06 c0       	rjmp	.+12     	; 0x2258 <eth_type_is_ip_and_my_ip+0x34>
        }
        if (buf[IP_HEADER_LEN_VER_P]!=0x45){
                // must be IP V4 and 20 byte header
                return(0);
        }
        while(i<4){
    224c:	85 e0       	ldi	r24, 0x05	; 5
    224e:	a8 35       	cpi	r26, 0x58	; 88
    2250:	b8 07       	cpc	r27, r24
    2252:	c1 f7       	brne	.-16     	; 0x2244 <eth_type_is_ip_and_my_ip+0x20>
                if(buf[IP_DST_P+i]!=ipaddr[i]){
                        return(0);
                }
                i++;
        }
        return(1);
    2254:	81 e0       	ldi	r24, 0x01	; 1
}
    2256:	08 95       	ret

uint8_t eth_type_is_ip_and_my_ip(uint8_t *buf,uint16_t len){
        uint8_t i=0;
        //eth+ip+udp header is 42
        if (len<42){
                return(0);
    2258:	80 e0       	ldi	r24, 0x00	; 0
    225a:	08 95       	ret

0000225c <make_eth>:
        }
        return(1);
}
// make a return eth header from a received eth packet
void make_eth(uint8_t *buf)
{
    225c:	cf 93       	push	r28
    225e:	df 93       	push	r29
    2260:	e8 e5       	ldi	r30, 0x58	; 88
    2262:	f5 e0       	ldi	r31, 0x05	; 5
    2264:	dc 01       	movw	r26, r24
    2266:	16 96       	adiw	r26, 0x06	; 6
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
    2268:	2c 91       	ld	r18, X
    226a:	ec 01       	movw	r28, r24
    226c:	29 93       	st	Y+, r18
    226e:	ce 01       	movw	r24, r28
                buf[ETH_SRC_MAC +i]=macaddr[i];
    2270:	21 91       	ld	r18, Z+
    2272:	2d 93       	st	X+, r18
void make_eth(uint8_t *buf)
{
        uint8_t i=0;
        //
        //copy the destination mac from the source and fill my mac into src
        while(i<6){
    2274:	d5 e0       	ldi	r29, 0x05	; 5
    2276:	ee 35       	cpi	r30, 0x5E	; 94
    2278:	fd 07       	cpc	r31, r29
    227a:	b1 f7       	brne	.-20     	; 0x2268 <make_eth+0xc>
                buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
}
    227c:	df 91       	pop	r29
    227e:	cf 91       	pop	r28
    2280:	08 95       	ret

00002282 <fill_ip_hdr_checksum>:
void fill_ip_hdr_checksum(uint8_t *buf)
{
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
    2286:	ec 01       	movw	r28, r24
        uint16_t ck;
        // clear the 2 byte checksum
        buf[IP_CHECKSUM_P]=0;
    2288:	18 8e       	std	Y+24, r1	; 0x18
        buf[IP_CHECKSUM_P+1]=0;
    228a:	19 8e       	std	Y+25, r1	; 0x19
        buf[IP_FLAGS_P]=0x40; // don't fragment
    228c:	80 e4       	ldi	r24, 0x40	; 64
    228e:	8c 8b       	std	Y+20, r24	; 0x14
        buf[IP_FLAGS_P+1]=0;  // fragement offset
    2290:	1d 8a       	std	Y+21, r1	; 0x15
        buf[IP_TTL_P]=64; // ttl
    2292:	8e 8b       	std	Y+22, r24	; 0x16
        // calculate the checksum:
        ck=checksum(&buf[IP_P], IP_HEADER_LEN,0);
    2294:	40 e0       	ldi	r20, 0x00	; 0
    2296:	64 e1       	ldi	r22, 0x14	; 20
    2298:	70 e0       	ldi	r23, 0x00	; 0
    229a:	ce 01       	movw	r24, r28
    229c:	0e 96       	adiw	r24, 0x0e	; 14
    229e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <checksum>
        buf[IP_CHECKSUM_P]=ck>>8;
    22a2:	98 8f       	std	Y+24, r25	; 0x18
        buf[IP_CHECKSUM_P+1]=ck& 0xff;
    22a4:	89 8f       	std	Y+25, r24	; 0x19
}
    22a6:	df 91       	pop	r29
    22a8:	cf 91       	pop	r28
    22aa:	08 95       	ret

000022ac <make_ip>:

// make a return ip header from a received ip packet
void make_ip(uint8_t *buf)
{
    22ac:	cf 93       	push	r28
    22ae:	df 93       	push	r29
    22b0:	ec 01       	movw	r28, r24
    22b2:	6e 96       	adiw	r28, 0x1e	; 30
    22b4:	e4 e5       	ldi	r30, 0x54	; 84
    22b6:	f5 e0       	ldi	r31, 0x05	; 5
    22b8:	dc 01       	movw	r26, r24
    22ba:	5a 96       	adiw	r26, 0x1a	; 26
        uint8_t i=0;
        while(i<4){
                buf[IP_DST_P+i]=buf[IP_SRC_P+i];
    22bc:	2c 91       	ld	r18, X
    22be:	29 93       	st	Y+, r18
                buf[IP_SRC_P+i]=ipaddr[i];
    22c0:	21 91       	ld	r18, Z+
    22c2:	2d 93       	st	X+, r18

// make a return ip header from a received ip packet
void make_ip(uint8_t *buf)
{
        uint8_t i=0;
        while(i<4){
    22c4:	25 e0       	ldi	r18, 0x05	; 5
    22c6:	e8 35       	cpi	r30, 0x58	; 88
    22c8:	f2 07       	cpc	r31, r18
    22ca:	c1 f7       	brne	.-16     	; 0x22bc <make_ip+0x10>
                buf[IP_DST_P+i]=buf[IP_SRC_P+i];
                buf[IP_SRC_P+i]=ipaddr[i];
                i++;
        }
        fill_ip_hdr_checksum(buf);
}
    22cc:	df 91       	pop	r29
    22ce:	cf 91       	pop	r28
        while(i<4){
                buf[IP_DST_P+i]=buf[IP_SRC_P+i];
                buf[IP_SRC_P+i]=ipaddr[i];
                i++;
        }
        fill_ip_hdr_checksum(buf);
    22d0:	0c 94 41 11 	jmp	0x2282	; 0x2282 <fill_ip_hdr_checksum>

000022d4 <step_seq>:
}

// swap seq and ack number and count ack number up
void step_seq(uint8_t *buf,uint16_t rel_ack_num,uint8_t cp_seq)
{
    22d4:	fc 01       	movw	r30, r24
    22d6:	ba 96       	adiw	r30, 0x2a	; 42
    22d8:	dc 01       	movw	r26, r24
    22da:	9e 96       	adiw	r26, 0x2e	; 46
    22dc:	86 96       	adiw	r24, 0x26	; 38
        uint8_t tseq;
        i=4;
        // sequence numbers:
        // add the rel ack num to SEQACK
        while(i>0){
                rel_ack_num=buf[TCP_SEQ_H_P+i-1]+rel_ack_num;
    22de:	22 91       	ld	r18, -Z
    22e0:	62 0f       	add	r22, r18
    22e2:	71 1d       	adc	r23, r1
                tseq=buf[TCP_SEQACK_H_P+i-1];
    22e4:	2e 91       	ld	r18, -X
                buf[TCP_SEQACK_H_P+i-1]=0xff&rel_ack_num;
    22e6:	6c 93       	st	X, r22
                if (cp_seq){
    22e8:	44 23       	and	r20, r20
    22ea:	11 f0       	breq	.+4      	; 0x22f0 <step_seq+0x1c>
                        // copy the acknum sent to us into the sequence number
                        buf[TCP_SEQ_H_P+i-1]=tseq;
    22ec:	20 83       	st	Z, r18
    22ee:	01 c0       	rjmp	.+2      	; 0x22f2 <step_seq+0x1e>
                }else{
                        buf[TCP_SEQ_H_P+i-1]= 0; // some preset value
    22f0:	10 82       	st	Z, r1
                }
                rel_ack_num=rel_ack_num>>8;
    22f2:	67 2f       	mov	r22, r23
    22f4:	77 27       	eor	r23, r23
        uint8_t i;
        uint8_t tseq;
        i=4;
        // sequence numbers:
        // add the rel ack num to SEQACK
        while(i>0){
    22f6:	e8 17       	cp	r30, r24
    22f8:	f9 07       	cpc	r31, r25
    22fa:	89 f7       	brne	.-30     	; 0x22de <step_seq+0xa>
                        buf[TCP_SEQ_H_P+i-1]= 0; // some preset value
                }
                rel_ack_num=rel_ack_num>>8;
                i--;
        }
}
    22fc:	08 95       	ret

000022fe <make_tcphead>:
//
// After calling this function you can fill in the first data byte at TCP_OPTIONS_P+4
// If cp_seq=0 then an initial sequence number is used (should be use in synack)
// otherwise it is copied from the packet we received
void make_tcphead(uint8_t *buf,uint16_t rel_ack_num,uint8_t cp_seq)
{
    22fe:	cf 93       	push	r28
    2300:	df 93       	push	r29
    2302:	ec 01       	movw	r28, r24
        uint8_t i;
        // copy ports:
        i=buf[TCP_DST_PORT_H_P];
    2304:	8c a1       	ldd	r24, Y+36	; 0x24
        buf[TCP_DST_PORT_H_P]=buf[TCP_SRC_PORT_H_P];
    2306:	9a a1       	ldd	r25, Y+34	; 0x22
    2308:	9c a3       	std	Y+36, r25	; 0x24
        buf[TCP_SRC_PORT_H_P]=i;
    230a:	8a a3       	std	Y+34, r24	; 0x22
        //
        i=buf[TCP_DST_PORT_L_P];
    230c:	8d a1       	ldd	r24, Y+37	; 0x25
        buf[TCP_DST_PORT_L_P]=buf[TCP_SRC_PORT_L_P];
    230e:	9b a1       	ldd	r25, Y+35	; 0x23
    2310:	9d a3       	std	Y+37, r25	; 0x25
        buf[TCP_SRC_PORT_L_P]=i;
    2312:	8b a3       	std	Y+35, r24	; 0x23
        step_seq(buf,rel_ack_num,cp_seq);
    2314:	ce 01       	movw	r24, r28
    2316:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <step_seq>
        // zero the checksum
        buf[TCP_CHECKSUM_H_P]=0;
    231a:	1a aa       	std	Y+50, r1	; 0x32
        buf[TCP_CHECKSUM_L_P]=0;
    231c:	1b aa       	std	Y+51, r1	; 0x33
        // no options:
        // 20 bytes:
        // The tcp header length is only a 4 bit field (the upper 4 bits).
        // It is calculated in units of 4 bytes.
        // E.g 20 bytes: 20/4=6 => 0x50=header len field
        buf[TCP_HEADER_LEN_P]=0x50;
    231e:	80 e5       	ldi	r24, 0x50	; 80
    2320:	8e a7       	std	Y+46, r24	; 0x2e
}
    2322:	df 91       	pop	r29
    2324:	cf 91       	pop	r28
    2326:	08 95       	ret

00002328 <make_arp_answer_from_request>:

void make_arp_answer_from_request(uint8_t *buf)
{
    2328:	cf 93       	push	r28
    232a:	df 93       	push	r29
    232c:	ec 01       	movw	r28, r24
        uint8_t i=0;
        //
        make_eth(buf);
    232e:	0e 94 2e 11 	call	0x225c	; 0x225c <make_eth>
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    2332:	1c 8a       	std	Y+20, r1	; 0x14
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    2334:	82 e0       	ldi	r24, 0x02	; 2
    2336:	8d 8b       	std	Y+21, r24	; 0x15
    2338:	ce 01       	movw	r24, r28
    233a:	80 96       	adiw	r24, 0x20	; 32
    233c:	48 e5       	ldi	r20, 0x58	; 88
    233e:	55 e0       	ldi	r21, 0x05	; 5
    2340:	de 01       	movw	r26, r28
    2342:	56 96       	adiw	r26, 0x16	; 22
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
    2344:	2c 91       	ld	r18, X
    2346:	fc 01       	movw	r30, r24
    2348:	21 93       	st	Z+, r18
    234a:	cf 01       	movw	r24, r30
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    234c:	fa 01       	movw	r30, r20
    234e:	21 91       	ld	r18, Z+
    2350:	af 01       	movw	r20, r30
    2352:	2d 93       	st	X+, r18
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    2354:	f5 e0       	ldi	r31, 0x05	; 5
    2356:	4e 35       	cpi	r20, 0x5E	; 94
    2358:	5f 07       	cpc	r21, r31
    235a:	a1 f7       	brne	.-24     	; 0x2344 <make_arp_answer_from_request+0x1c>
    235c:	ce 01       	movw	r24, r28
    235e:	86 96       	adiw	r24, 0x26	; 38
    2360:	44 e5       	ldi	r20, 0x54	; 84
    2362:	55 e0       	ldi	r21, 0x05	; 5
    2364:	de 01       	movw	r26, r28
    2366:	5c 96       	adiw	r26, 0x1c	; 28
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    2368:	2c 91       	ld	r18, X
    236a:	fc 01       	movw	r30, r24
    236c:	21 93       	st	Z+, r18
    236e:	cf 01       	movw	r24, r30
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    2370:	fa 01       	movw	r30, r20
    2372:	21 91       	ld	r18, Z+
    2374:	af 01       	movw	r20, r30
    2376:	2d 93       	st	X+, r18
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    2378:	f5 e0       	ldi	r31, 0x05	; 5
    237a:	48 35       	cpi	r20, 0x58	; 88
    237c:	5f 07       	cpc	r21, r31
    237e:	a1 f7       	brne	.-24     	; 0x2368 <make_arp_answer_from_request+0x40>
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    2380:	be 01       	movw	r22, r28
    2382:	8a e2       	ldi	r24, 0x2A	; 42
    2384:	90 e0       	ldi	r25, 0x00	; 0
}
    2386:	df 91       	pop	r29
    2388:	cf 91       	pop	r28
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    238a:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

0000238e <make_echo_reply_from_request>:
}

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    238e:	0f 93       	push	r16
    2390:	1f 93       	push	r17
    2392:	cf 93       	push	r28
    2394:	df 93       	push	r29
    2396:	ec 01       	movw	r28, r24
    2398:	8b 01       	movw	r16, r22
        make_eth(buf);
    239a:	0e 94 2e 11 	call	0x225c	; 0x225c <make_eth>
        make_ip(buf);
    239e:	ce 01       	movw	r24, r28
    23a0:	0e 94 56 11 	call	0x22ac	; 0x22ac <make_ip>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    23a4:	1a a2       	std	Y+34, r1	; 0x22
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    23a6:	9c a1       	ldd	r25, Y+36	; 0x24
    23a8:	98 3f       	cpi	r25, 0xF8	; 248
    23aa:	18 f0       	brcs	.+6      	; 0x23b2 <make_echo_reply_from_request+0x24>
                buf[ICMP_CHECKSUM_P+1]++;
    23ac:	8d a1       	ldd	r24, Y+37	; 0x25
    23ae:	8f 5f       	subi	r24, 0xFF	; 255
    23b0:	8d a3       	std	Y+37, r24	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    23b2:	98 5f       	subi	r25, 0xF8	; 248
    23b4:	9c a3       	std	Y+36, r25	; 0x24
        //
        enc28j60PacketSend(len,buf);
    23b6:	be 01       	movw	r22, r28
    23b8:	c8 01       	movw	r24, r16
}
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	1f 91       	pop	r17
    23c0:	0f 91       	pop	r16
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
                buf[ICMP_CHECKSUM_P+1]++;
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
        //
        enc28j60PacketSend(len,buf);
    23c2:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

000023c6 <make_tcp_synack_from_syn>:
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
}

// this is for the server not the client:
void make_tcp_synack_from_syn(uint8_t *buf)
{
    23c6:	cf 93       	push	r28
    23c8:	df 93       	push	r29
    23ca:	ec 01       	movw	r28, r24
        uint16_t ck;
        make_eth(buf);
    23cc:	0e 94 2e 11 	call	0x225c	; 0x225c <make_eth>
        // total length field in the IP header must be set:
        // 20 bytes IP + 24 bytes (20tcp+4tcp options)
        buf[IP_TOTLEN_H_P]=0;
    23d0:	18 8a       	std	Y+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4;
    23d2:	8c e2       	ldi	r24, 0x2C	; 44
    23d4:	89 8b       	std	Y+17, r24	; 0x11
        make_ip(buf);
    23d6:	ce 01       	movw	r24, r28
    23d8:	0e 94 56 11 	call	0x22ac	; 0x22ac <make_ip>
        buf[TCP_FLAGS_P]=TCP_FLAGS_SYNACK_V;
    23dc:	82 e1       	ldi	r24, 0x12	; 18
    23de:	8f a7       	std	Y+47, r24	; 0x2f
        make_tcphead(buf,1,0);
    23e0:	40 e0       	ldi	r20, 0x00	; 0
    23e2:	61 e0       	ldi	r22, 0x01	; 1
    23e4:	70 e0       	ldi	r23, 0x00	; 0
    23e6:	ce 01       	movw	r24, r28
    23e8:	0e 94 7f 11 	call	0x22fe	; 0x22fe <make_tcphead>
        // put an inital seq number
        buf[TCP_SEQ_H_P+0]= 0;
    23ec:	1e a2       	std	Y+38, r1	; 0x26
        buf[TCP_SEQ_H_P+1]= 0;
    23ee:	1f a2       	std	Y+39, r1	; 0x27
        // we step only the second byte, this allows us to send packts 
        // with 255 bytes, 512  or 765 (step by 3) without generating
        // overlapping numbers.
        buf[TCP_SEQ_H_P+2]= seqnum; 
    23f0:	80 91 00 01 	lds	r24, 0x0100
    23f4:	88 a7       	std	Y+40, r24	; 0x28
        buf[TCP_SEQ_H_P+3]= 0;
    23f6:	19 a6       	std	Y+41, r1	; 0x29
        // step the inititial seq num by something we will not use
        // during this tcp session:
        seqnum+=3;
    23f8:	8d 5f       	subi	r24, 0xFD	; 253
    23fa:	80 93 00 01 	sts	0x0100, r24
        // add an mss options field with MSS to 1280:
        // 1280 in hex is 0x500
        buf[TCP_OPTIONS_P]=2;
    23fe:	82 e0       	ldi	r24, 0x02	; 2
    2400:	8e ab       	std	Y+54, r24	; 0x36
        buf[TCP_OPTIONS_P+1]=4;
    2402:	84 e0       	ldi	r24, 0x04	; 4
    2404:	8f ab       	std	Y+55, r24	; 0x37
        buf[TCP_OPTIONS_P+2]=0x05;
    2406:	85 e0       	ldi	r24, 0x05	; 5
    2408:	88 af       	std	Y+56, r24	; 0x38
        buf[TCP_OPTIONS_P+3]=0x0;
    240a:	19 ae       	std	Y+57, r1	; 0x39
        // The tcp header length is only a 4 bit field (the upper 4 bits).
        // It is calculated in units of 4 bytes.
        // E.g 24 bytes: 24/4=6 => 0x60=header len field
        buf[TCP_HEADER_LEN_P]=0x60;
    240c:	90 e6       	ldi	r25, 0x60	; 96
    240e:	9e a7       	std	Y+46, r25	; 0x2e
        // here we must just be sure that the web browser contacting us
        // will send only one get packet
        buf[TCP_WIN_SIZE]=0x5; // 1400=0x578
    2410:	88 ab       	std	Y+48, r24	; 0x30
        buf[TCP_WIN_SIZE+1]=0x78;
    2412:	88 e7       	ldi	r24, 0x78	; 120
    2414:	89 ab       	std	Y+49, r24	; 0x31
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + 4 (one option: mss)
        ck=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+4,2);
    2416:	42 e0       	ldi	r20, 0x02	; 2
    2418:	60 e2       	ldi	r22, 0x20	; 32
    241a:	70 e0       	ldi	r23, 0x00	; 0
    241c:	ce 01       	movw	r24, r28
    241e:	4a 96       	adiw	r24, 0x1a	; 26
    2420:	0e 94 74 10 	call	0x20e8	; 0x20e8 <checksum>
        buf[TCP_CHECKSUM_H_P]=ck>>8;
    2424:	9a ab       	std	Y+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=ck& 0xff;
    2426:	8b ab       	std	Y+51, r24	; 0x33
        // add 4 for option mss:
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN,buf);
    2428:	be 01       	movw	r22, r28
    242a:	8a e3       	ldi	r24, 0x3A	; 58
    242c:	90 e0       	ldi	r25, 0x00	; 0
}
    242e:	df 91       	pop	r29
    2430:	cf 91       	pop	r28
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + 4 (one option: mss)
        ck=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+4,2);
        buf[TCP_CHECKSUM_H_P]=ck>>8;
        buf[TCP_CHECKSUM_L_P]=ck& 0xff;
        // add 4 for option mss:
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN,buf);
    2432:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

00002436 <get_tcp_data_len>:
}

// do some basic length calculations 
uint16_t get_tcp_data_len(uint8_t *buf)
{
    2436:	fc 01       	movw	r30, r24
        int16_t i;
        i=(((int16_t)buf[IP_TOTLEN_H_P])<<8)|(buf[IP_TOTLEN_L_P]&0xff);
    2438:	80 89       	ldd	r24, Z+16	; 0x10
    243a:	90 e0       	ldi	r25, 0x00	; 0
    243c:	98 2f       	mov	r25, r24
    243e:	88 27       	eor	r24, r24
    2440:	21 89       	ldd	r18, Z+17	; 0x11
    2442:	82 2b       	or	r24, r18
        i-=IP_HEADER_LEN;
    2444:	44 97       	sbiw	r24, 0x14	; 20
        i-=(buf[TCP_HEADER_LEN_P]>>4)*4; // generate len in bytes;
    2446:	26 a5       	ldd	r18, Z+46	; 0x2e
    2448:	22 95       	swap	r18
    244a:	2f 70       	andi	r18, 0x0F	; 15
    244c:	34 e0       	ldi	r19, 0x04	; 4
    244e:	23 9f       	mul	r18, r19
    2450:	80 19       	sub	r24, r0
    2452:	91 09       	sbc	r25, r1
    2454:	11 24       	eor	r1, r1
    2456:	97 ff       	sbrs	r25, 7
    2458:	02 c0       	rjmp	.+4      	; 0x245e <get_tcp_data_len+0x28>
    245a:	80 e0       	ldi	r24, 0x00	; 0
    245c:	90 e0       	ldi	r25, 0x00	; 0
        if (i<=0){
                i=0;
        }
        return((uint16_t)i);
}
    245e:	08 95       	ret

00002460 <fill_tcp_data_p>:

// fill in tcp data at position pos. pos=0 means start of
// tcp data. Returns the position at which the string after
// this string could be filled.
uint16_t fill_tcp_data_p(uint8_t *buf,uint16_t pos, const char *progmem_s)
{
    2460:	9c 01       	movw	r18, r24
        char c;
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while ((c = pgm_read_byte(progmem_s++))) {
    2462:	cb 01       	movw	r24, r22
    2464:	46 1b       	sub	r20, r22
    2466:	57 0b       	sbc	r21, r23
    2468:	fa 01       	movw	r30, r20
    246a:	e8 0f       	add	r30, r24
    246c:	f9 1f       	adc	r31, r25
    246e:	e4 91       	lpm	r30, Z
    2470:	ee 23       	and	r30, r30
    2472:	39 f0       	breq	.+14     	; 0x2482 <fill_tcp_data_p+0x22>
    2474:	d9 01       	movw	r26, r18
    2476:	a8 0f       	add	r26, r24
    2478:	b9 1f       	adc	r27, r25
                buf[TCP_CHECKSUM_L_P+3+pos]=c;
    247a:	d6 96       	adiw	r26, 0x36	; 54
    247c:	ec 93       	st	X, r30
                pos++;
    247e:	01 96       	adiw	r24, 0x01	; 1
    2480:	f3 cf       	rjmp	.-26     	; 0x2468 <fill_tcp_data_p+0x8>
        }
        return(pos);
}
    2482:	08 95       	ret

00002484 <fill_tcp_data_len>:

// fill a binary string of len data into the tcp packet
uint16_t fill_tcp_data_len(uint8_t *buf,uint16_t pos, const uint8_t *s, uint8_t len)
{
    2484:	db 01       	movw	r26, r22
    2486:	d6 96       	adiw	r26, 0x36	; 54
    2488:	a8 0f       	add	r26, r24
    248a:	b9 1f       	adc	r27, r25
        // fill in tcp data at position pos
        //
        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
        while (len) {
    248c:	fa 01       	movw	r30, r20
    248e:	42 0f       	add	r20, r18
    2490:	4e 17       	cp	r20, r30
    2492:	19 f0       	breq	.+6      	; 0x249a <fill_tcp_data_len+0x16>
                buf[TCP_CHECKSUM_L_P+3+pos]=*s;
    2494:	81 91       	ld	r24, Z+
    2496:	8d 93       	st	X+, r24
    2498:	fb cf       	rjmp	.-10     	; 0x2490 <fill_tcp_data_len+0xc>
                pos++;
                s++;
                len--;
        }
        return(pos);
}
    249a:	cb 01       	movw	r24, r22
    249c:	82 0f       	add	r24, r18
    249e:	91 1d       	adc	r25, r1
    24a0:	08 95       	ret

000024a2 <fill_tcp_data>:
// fill in tcp data at position pos. pos=0 means start of
// tcp data. Returns the position at which the string after
// this string could be filled.
uint16_t fill_tcp_data(uint8_t *buf,uint16_t pos, const char *s)
{
        return(fill_tcp_data_len(buf,pos,(uint8_t*)s,strlen(s)));
    24a2:	fa 01       	movw	r30, r20
    24a4:	01 90       	ld	r0, Z+
    24a6:	00 20       	and	r0, r0
    24a8:	e9 f7       	brne	.-6      	; 0x24a4 <fill_tcp_data+0x2>
    24aa:	9f 01       	movw	r18, r30
    24ac:	21 50       	subi	r18, 0x01	; 1
    24ae:	31 09       	sbc	r19, r1
    24b0:	24 1b       	sub	r18, r20
    24b2:	35 0b       	sbc	r19, r21
    24b4:	0c 94 42 12 	jmp	0x2484	; 0x2484 <fill_tcp_data_len>

000024b8 <www_client_internal_datafill_callback>:
        return(tcp_fd);
}
#endif //  TCP_client

#if defined (WWW_client) 
uint16_t www_client_internal_datafill_callback(uint8_t fd){
    24b8:	ef 92       	push	r14
    24ba:	ff 92       	push	r15
    24bc:	0f 93       	push	r16
    24be:	1f 93       	push	r17
    24c0:	cf 93       	push	r28
    24c2:	df 93       	push	r29
    24c4:	00 d0       	rcall	.+0      	; 0x24c6 <www_client_internal_datafill_callback+0xe>
    24c6:	00 d0       	rcall	.+0      	; 0x24c8 <www_client_internal_datafill_callback+0x10>
    24c8:	1f 92       	push	r1
    24ca:	cd b7       	in	r28, 0x3d	; 61
    24cc:	de b7       	in	r29, 0x3e	; 62
        char strbuf[5];
        uint16_t len=0;
        if (fd==www_fd){
    24ce:	90 91 76 05 	lds	r25, 0x0576
    24d2:	89 13       	cpse	r24, r25
    24d4:	a4 c0       	rjmp	.+328    	; 0x261e <www_client_internal_datafill_callback+0x166>
                if (browsertype==0){
    24d6:	80 91 75 05 	lds	r24, 0x0575
    24da:	00 91 67 05 	lds	r16, 0x0567
    24de:	10 91 68 05 	lds	r17, 0x0568
    24e2:	81 11       	cpse	r24, r1
    24e4:	34 c0       	rjmp	.+104    	; 0x254e <www_client_internal_datafill_callback+0x96>
                        // GET
                        len=fill_tcp_data_p(bufptr,0,PSTR("GET "));
    24e6:	4a e7       	ldi	r20, 0x7A	; 122
    24e8:	51 e0       	ldi	r21, 0x01	; 1
    24ea:	60 e0       	ldi	r22, 0x00	; 0
    24ec:	70 e0       	ldi	r23, 0x00	; 0
    24ee:	c8 01       	movw	r24, r16
    24f0:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data_p(bufptr,len,client_urlbuf);
    24f4:	40 91 6d 05 	lds	r20, 0x056D
    24f8:	50 91 6e 05 	lds	r21, 0x056E
    24fc:	bc 01       	movw	r22, r24
    24fe:	c8 01       	movw	r24, r16
    2500:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data(bufptr,len,client_urlbuf_var);
    2504:	40 91 6b 05 	lds	r20, 0x056B
    2508:	50 91 6c 05 	lds	r21, 0x056C
    250c:	bc 01       	movw	r22, r24
    250e:	c8 01       	movw	r24, r16
    2510:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>

						len=fill_custom_client_data(bufptr,len);
    2514:	bc 01       	movw	r22, r24
    2516:	c8 01       	movw	r24, r16
    2518:	0e 94 6f 30 	call	0x60de	; 0x60de <fill_custom_client_data>

                        // I would prefer http/1.0 but there is a funny
                        // bug in some apache webservers which causes
                        // them to send two packets (fragmented PDU)
                        // if we don't use HTTP/1.1 + Connection: close
                        len=fill_tcp_data_p(bufptr,len,PSTR(" HTTP/1.1\r\nHost: "));
    251c:	00 91 67 05 	lds	r16, 0x0567
    2520:	10 91 68 05 	lds	r17, 0x0568
    2524:	48 e6       	ldi	r20, 0x68	; 104
    2526:	51 e0       	ldi	r21, 0x01	; 1
    2528:	bc 01       	movw	r22, r24
    252a:	c8 01       	movw	r24, r16
    252c:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data_p(bufptr,len,client_hoststr);
    2530:	40 91 69 05 	lds	r20, 0x0569
    2534:	50 91 6a 05 	lds	r21, 0x056A
    2538:	bc 01       	movw	r22, r24
    253a:	c8 01       	movw	r24, r16
    253c:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data_p(bufptr,len,PSTR("\r\nUser-Agent: SBNG/1.0\r\nAccept: text/html\r\nConnection: close\r\n\r\n"));
    2540:	47 e2       	ldi	r20, 0x27	; 39
    2542:	51 e0       	ldi	r21, 0x01	; 1
    2544:	bc 01       	movw	r22, r24
    2546:	c8 01       	movw	r24, r16
    2548:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    254c:	6a c0       	rjmp	.+212    	; 0x2622 <www_client_internal_datafill_callback+0x16a>
                }else{
                        // POST
                        len=fill_tcp_data_p(bufptr,0,PSTR("POST "));
    254e:	41 e2       	ldi	r20, 0x21	; 33
    2550:	51 e0       	ldi	r21, 0x01	; 1
    2552:	60 e0       	ldi	r22, 0x00	; 0
    2554:	70 e0       	ldi	r23, 0x00	; 0
    2556:	c8 01       	movw	r24, r16
    2558:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data_p(bufptr,len,client_urlbuf);
    255c:	40 91 6d 05 	lds	r20, 0x056D
    2560:	50 91 6e 05 	lds	r21, 0x056E
    2564:	bc 01       	movw	r22, r24
    2566:	c8 01       	movw	r24, r16
    2568:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data_p(bufptr,len,PSTR(" HTTP/1.1\r\nHost: "));
    256c:	4f e0       	ldi	r20, 0x0F	; 15
    256e:	51 e0       	ldi	r21, 0x01	; 1
    2570:	bc 01       	movw	r22, r24
    2572:	c8 01       	movw	r24, r16
    2574:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data_p(bufptr,len,client_hoststr);
    2578:	40 91 69 05 	lds	r20, 0x0569
    257c:	50 91 6a 05 	lds	r21, 0x056A
    2580:	bc 01       	movw	r22, r24
    2582:	c8 01       	movw	r24, r16
    2584:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        if (client_additionalheaderline){
    2588:	e0 90 71 05 	lds	r14, 0x0571
    258c:	f0 90 72 05 	lds	r15, 0x0572
    2590:	e1 14       	cp	r14, r1
    2592:	f1 04       	cpc	r15, r1
    2594:	59 f0       	breq	.+22     	; 0x25ac <www_client_internal_datafill_callback+0xf4>
                                len=fill_tcp_data_p(bufptr,len,PSTR("\r\n"));
    2596:	4c e0       	ldi	r20, 0x0C	; 12
    2598:	51 e0       	ldi	r21, 0x01	; 1
    259a:	bc 01       	movw	r22, r24
    259c:	c8 01       	movw	r24, r16
    259e:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                                len=fill_tcp_data_p(bufptr,len,client_additionalheaderline);
    25a2:	a7 01       	movw	r20, r14
    25a4:	bc 01       	movw	r22, r24
    25a6:	c8 01       	movw	r24, r16
    25a8:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        }
                        len=fill_tcp_data_p(bufptr,len,PSTR("\r\nUser-Agent: SBNG/1.1\r\nAccept: */*\r\nConnection: close\r\n"));
    25ac:	43 ed       	ldi	r20, 0xD3	; 211
    25ae:	50 e0       	ldi	r21, 0x00	; 0
    25b0:	bc 01       	movw	r22, r24
    25b2:	c8 01       	movw	r24, r16
    25b4:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data_p(bufptr,len,PSTR("Content-Length: "));
    25b8:	42 ec       	ldi	r20, 0xC2	; 194
    25ba:	50 e0       	ldi	r21, 0x00	; 0
    25bc:	bc 01       	movw	r22, r24
    25be:	c8 01       	movw	r24, r16
    25c0:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    25c4:	7c 01       	movw	r14, r24
                        itoa(strlen(client_postval),strbuf,10);
    25c6:	a0 91 6f 05 	lds	r26, 0x056F
    25ca:	b0 91 70 05 	lds	r27, 0x0570
    25ce:	fd 01       	movw	r30, r26
    25d0:	01 90       	ld	r0, Z+
    25d2:	00 20       	and	r0, r0
    25d4:	e9 f7       	brne	.-6      	; 0x25d0 <www_client_internal_datafill_callback+0x118>
    25d6:	31 97       	sbiw	r30, 0x01	; 1
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    25d8:	4a e0       	ldi	r20, 0x0A	; 10
    25da:	be 01       	movw	r22, r28
    25dc:	6f 5f       	subi	r22, 0xFF	; 255
    25de:	7f 4f       	sbci	r23, 0xFF	; 255
    25e0:	cf 01       	movw	r24, r30
    25e2:	8a 1b       	sub	r24, r26
    25e4:	9b 0b       	sbc	r25, r27
    25e6:	0e 94 2a 3e 	call	0x7c54	; 0x7c54 <__itoa_ncheck>
                        len=fill_tcp_data(bufptr,len,strbuf);
    25ea:	00 91 67 05 	lds	r16, 0x0567
    25ee:	10 91 68 05 	lds	r17, 0x0568
    25f2:	ae 01       	movw	r20, r28
    25f4:	4f 5f       	subi	r20, 0xFF	; 255
    25f6:	5f 4f       	sbci	r21, 0xFF	; 255
    25f8:	b7 01       	movw	r22, r14
    25fa:	c8 01       	movw	r24, r16
    25fc:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
                        len=fill_tcp_data_p(bufptr,len,PSTR("\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\n"));
    2600:	4c e8       	ldi	r20, 0x8C	; 140
    2602:	50 e0       	ldi	r21, 0x00	; 0
    2604:	bc 01       	movw	r22, r24
    2606:	c8 01       	movw	r24, r16
    2608:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
                        len=fill_tcp_data(bufptr,len,client_postval);
    260c:	40 91 6f 05 	lds	r20, 0x056F
    2610:	50 91 70 05 	lds	r21, 0x0570
    2614:	bc 01       	movw	r22, r24
    2616:	c8 01       	movw	r24, r16
    2618:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    261c:	02 c0       	rjmp	.+4      	; 0x2622 <www_client_internal_datafill_callback+0x16a>
                }
                return(len);
        }
        return(0);
    261e:	80 e0       	ldi	r24, 0x00	; 0
    2620:	90 e0       	ldi	r25, 0x00	; 0
}
    2622:	0f 90       	pop	r0
    2624:	0f 90       	pop	r0
    2626:	0f 90       	pop	r0
    2628:	0f 90       	pop	r0
    262a:	0f 90       	pop	r0
    262c:	df 91       	pop	r29
    262e:	cf 91       	pop	r28
    2630:	1f 91       	pop	r17
    2632:	0f 91       	pop	r16
    2634:	ff 90       	pop	r15
    2636:	ef 90       	pop	r14
    2638:	08 95       	ret

0000263a <make_tcp_ack_from_any>:
}

// Make just an ack packet with no tcp data inside
// This will modify the eth/ip/tcp header 
void make_tcp_ack_from_any(uint8_t *buf,int16_t datlentoack,uint8_t addflags)
{
    263a:	0f 93       	push	r16
    263c:	1f 93       	push	r17
    263e:	cf 93       	push	r28
    2640:	df 93       	push	r29
    2642:	00 d0       	rcall	.+0      	; 0x2644 <make_tcp_ack_from_any+0xa>
    2644:	1f 92       	push	r1
    2646:	cd b7       	in	r28, 0x3d	; 61
    2648:	de b7       	in	r29, 0x3e	; 62
    264a:	8c 01       	movw	r16, r24
        uint16_t j;
        make_eth(buf);
    264c:	4b 83       	std	Y+3, r20	; 0x03
    264e:	69 83       	std	Y+1, r22	; 0x01
    2650:	7a 83       	std	Y+2, r23	; 0x02
    2652:	0e 94 2e 11 	call	0x225c	; 0x225c <make_eth>
        // fill the header:
        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|addflags;
    2656:	4b 81       	ldd	r20, Y+3	; 0x03
    2658:	84 2f       	mov	r24, r20
    265a:	80 61       	ori	r24, 0x10	; 16
    265c:	f8 01       	movw	r30, r16
    265e:	87 a7       	std	Z+47, r24	; 0x2f
        if (addflags==TCP_FLAGS_RST_V){
    2660:	69 81       	ldd	r22, Y+1	; 0x01
    2662:	7a 81       	ldd	r23, Y+2	; 0x02
    2664:	44 30       	cpi	r20, 0x04	; 4
    2666:	29 f0       	breq	.+10     	; 0x2672 <make_tcp_ack_from_any+0x38>
                make_tcphead(buf,datlentoack,1); 
        }else{
                if (datlentoack==0){
    2668:	61 15       	cp	r22, r1
    266a:	71 05       	cpc	r23, r1
    266c:	11 f4       	brne	.+4      	; 0x2672 <make_tcp_ack_from_any+0x38>
                        // if there is no data then we must still acknoledge one packet
                        datlentoack=1;
    266e:	61 e0       	ldi	r22, 0x01	; 1
    2670:	70 e0       	ldi	r23, 0x00	; 0
                }
                // normal case, ack the data:
                make_tcphead(buf,datlentoack,1); // no options
    2672:	41 e0       	ldi	r20, 0x01	; 1
    2674:	c8 01       	movw	r24, r16
    2676:	0e 94 7f 11 	call	0x22fe	; 0x22fe <make_tcphead>
        }
        // total length field in the IP header must be set:
        // 20 bytes IP + 20 bytes tcp (when no options) 
        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN;
        buf[IP_TOTLEN_H_P]=j>>8;
    267a:	f8 01       	movw	r30, r16
    267c:	10 8a       	std	Z+16, r1	; 0x10
        buf[IP_TOTLEN_L_P]=j& 0xff;
    267e:	88 e2       	ldi	r24, 0x28	; 40
    2680:	81 8b       	std	Z+17, r24	; 0x11
        make_ip(buf);
    2682:	c8 01       	movw	r24, r16
    2684:	0e 94 56 11 	call	0x22ac	; 0x22ac <make_ip>
        // use a low window size otherwise we have to have
        // timers and can not just react on every packet.
        buf[TCP_WIN_SIZE]=0x4; // 1024=0x400, 1280=0x500 2048=0x800 768=0x300
    2688:	84 e0       	ldi	r24, 0x04	; 4
    268a:	f8 01       	movw	r30, r16
    268c:	80 ab       	std	Z+48, r24	; 0x30
        buf[TCP_WIN_SIZE+1]=0;
    268e:	11 aa       	std	Z+49, r1	; 0x31
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN,2);
    2690:	42 e0       	ldi	r20, 0x02	; 2
    2692:	6c e1       	ldi	r22, 0x1C	; 28
    2694:	70 e0       	ldi	r23, 0x00	; 0
    2696:	c8 01       	movw	r24, r16
    2698:	4a 96       	adiw	r24, 0x1a	; 26
    269a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <checksum>
        buf[TCP_CHECKSUM_H_P]=j>>8;
    269e:	f8 01       	movw	r30, r16
    26a0:	92 ab       	std	Z+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
    26a2:	83 ab       	std	Z+51, r24	; 0x33
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN,buf);
    26a4:	b8 01       	movw	r22, r16
    26a6:	86 e3       	ldi	r24, 0x36	; 54
    26a8:	90 e0       	ldi	r25, 0x00	; 0
}
    26aa:	0f 90       	pop	r0
    26ac:	0f 90       	pop	r0
    26ae:	0f 90       	pop	r0
    26b0:	df 91       	pop	r29
    26b2:	cf 91       	pop	r28
    26b4:	1f 91       	pop	r17
    26b6:	0f 91       	pop	r16
        buf[TCP_WIN_SIZE+1]=0;
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN,2);
        buf[TCP_CHECKSUM_H_P]=j>>8;
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN,buf);
    26b8:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

000026bc <make_tcp_ack_with_data_noflags>:
// You can use this function only immediately after make_tcp_ack_from_any
// This is because this function will NOT modify the eth/ip/tcp header except for
// length and checksum
// You must set TCP_FLAGS before calling this
void make_tcp_ack_with_data_noflags(uint8_t *buf,uint16_t dlen)
{
    26bc:	0f 93       	push	r16
    26be:	1f 93       	push	r17
    26c0:	cf 93       	push	r28
    26c2:	df 93       	push	r29
    26c4:	ec 01       	movw	r28, r24
    26c6:	8b 01       	movw	r16, r22
        uint16_t j;
        // total length field in the IP header must be set:
        // 20 bytes IP + 20 bytes tcp (when no options) + len of data
        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen;
    26c8:	cb 01       	movw	r24, r22
    26ca:	88 96       	adiw	r24, 0x28	; 40
        buf[IP_TOTLEN_H_P]=j>>8;
    26cc:	98 8b       	std	Y+16, r25	; 0x10
        buf[IP_TOTLEN_L_P]=j& 0xff;
    26ce:	89 8b       	std	Y+17, r24	; 0x11
        fill_ip_hdr_checksum(buf);
    26d0:	ce 01       	movw	r24, r28
    26d2:	0e 94 41 11 	call	0x2282	; 0x2282 <fill_ip_hdr_checksum>
        // zero the checksum
        buf[TCP_CHECKSUM_H_P]=0;
    26d6:	1a aa       	std	Y+50, r1	; 0x32
        buf[TCP_CHECKSUM_L_P]=0;
    26d8:	1b aa       	std	Y+51, r1	; 0x33
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+dlen,2);
    26da:	b8 01       	movw	r22, r16
    26dc:	64 5e       	subi	r22, 0xE4	; 228
    26de:	7f 4f       	sbci	r23, 0xFF	; 255
    26e0:	42 e0       	ldi	r20, 0x02	; 2
    26e2:	ce 01       	movw	r24, r28
    26e4:	4a 96       	adiw	r24, 0x1a	; 26
    26e6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <checksum>
        buf[TCP_CHECKSUM_H_P]=j>>8;
    26ea:	9a ab       	std	Y+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
    26ec:	8b ab       	std	Y+51, r24	; 0x33
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
    26ee:	be 01       	movw	r22, r28
    26f0:	c8 01       	movw	r24, r16
    26f2:	c6 96       	adiw	r24, 0x36	; 54
}
    26f4:	df 91       	pop	r29
    26f6:	cf 91       	pop	r28
    26f8:	1f 91       	pop	r17
    26fa:	0f 91       	pop	r16
        buf[TCP_CHECKSUM_L_P]=0;
        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+dlen,2);
        buf[TCP_CHECKSUM_H_P]=j>>8;
        buf[TCP_CHECKSUM_L_P]=j& 0xff;
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
    26fc:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

00002700 <www_server_reply>:
// dlen is the amount of tcp data (http data) we send in this packet
// You can use this function only immediately after make_tcp_ack_from_any
// This is because this function will NOT modify the eth/ip/tcp header except for
// length and checksum
void www_server_reply(uint8_t *buf,uint16_t dlen)
{
    2700:	0f 93       	push	r16
    2702:	1f 93       	push	r17
    2704:	cf 93       	push	r28
    2706:	df 93       	push	r29
    2708:	ec 01       	movw	r28, r24
    270a:	8b 01       	movw	r16, r22
        make_tcp_ack_from_any(buf,info_data_len,0); // send ack for http get
    270c:	60 91 52 05 	lds	r22, 0x0552
    2710:	70 91 53 05 	lds	r23, 0x0553
    2714:	40 e0       	ldi	r20, 0x00	; 0
    2716:	0e 94 1d 13 	call	0x263a	; 0x263a <make_tcp_ack_from_any>
        // fill the header:
        // This code requires that we send only one data packet
        // because we keep no state information. We must therefore set
        // the fin here:
        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
    271a:	89 e1       	ldi	r24, 0x19	; 25
    271c:	8f a7       	std	Y+47, r24	; 0x2f
        make_tcp_ack_with_data_noflags(buf,dlen); // send data
    271e:	b8 01       	movw	r22, r16
    2720:	ce 01       	movw	r24, r28
}
    2722:	df 91       	pop	r29
    2724:	cf 91       	pop	r28
    2726:	1f 91       	pop	r17
    2728:	0f 91       	pop	r16
        // fill the header:
        // This code requires that we send only one data packet
        // because we keep no state information. We must therefore set
        // the fin here:
        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
        make_tcp_ack_with_data_noflags(buf,dlen); // send data
    272a:	0c 94 5e 13 	jmp	0x26bc	; 0x26bc <make_tcp_ack_with_data_noflags>

0000272e <fill_buf_p>:
}

#if defined (NTP_client) ||  defined (WOL_client) || defined (UDP_client) || defined (TCP_client) || defined (PING_client)
// fill buffer with a prog-mem string
void fill_buf_p(uint8_t *buf,uint16_t len, const char *progmem_s)
{
    272e:	64 0f       	add	r22, r20
    2730:	75 1f       	adc	r23, r21
        while (len){
    2732:	46 17       	cp	r20, r22
    2734:	57 07       	cpc	r21, r23
    2736:	41 f0       	breq	.+16     	; 0x2748 <fill_buf_p+0x1a>
                *buf= pgm_read_byte(progmem_s);
    2738:	fa 01       	movw	r30, r20
    273a:	24 91       	lpm	r18, Z
    273c:	fc 01       	movw	r30, r24
    273e:	21 93       	st	Z+, r18
    2740:	cf 01       	movw	r24, r30
                buf++;
                progmem_s++;
    2742:	4f 5f       	subi	r20, 0xFF	; 255
    2744:	5f 4f       	sbci	r21, 0xFF	; 255
    2746:	f5 cf       	rjmp	.-22     	; 0x2732 <fill_buf_p+0x4>
                len--;
        }
}
    2748:	08 95       	ret

0000274a <send_udp_prepare>:
// 2) You just allocate a large enough buffer for you data and you call send_udp and nothing else
// needs to be done.
//
// send_udp sends via gwip, you must call client_set_gwip at startu
void send_udp_prepare(uint8_t *buf,uint16_t sport, uint8_t *dip, uint16_t dport)
{
    274a:	af 92       	push	r10
    274c:	bf 92       	push	r11
    274e:	cf 92       	push	r12
    2750:	df 92       	push	r13
    2752:	ef 92       	push	r14
    2754:	ff 92       	push	r15
    2756:	0f 93       	push	r16
    2758:	1f 93       	push	r17
    275a:	cf 93       	push	r28
    275c:	df 93       	push	r29
    275e:	00 d0       	rcall	.+0      	; 0x2760 <send_udp_prepare+0x16>
    2760:	cd b7       	in	r28, 0x3d	; 61
    2762:	de b7       	in	r29, 0x3e	; 62
    2764:	5c 01       	movw	r10, r24
    2766:	f6 2e       	mov	r15, r22
    2768:	e7 2e       	mov	r14, r23
    276a:	6a 01       	movw	r12, r20
    276c:	ef e5       	ldi	r30, 0x5F	; 95
    276e:	f5 e0       	ldi	r31, 0x05	; 5
    2770:	8c 01       	movw	r16, r24
    2772:	88 e5       	ldi	r24, 0x58	; 88
    2774:	95 e0       	ldi	r25, 0x05	; 5
    2776:	b5 01       	movw	r22, r10
    2778:	6a 5f       	subi	r22, 0xFA	; 250
    277a:	7f 4f       	sbci	r23, 0xFF	; 255
        uint8_t i=0;
        //
        while(i<6){
                buf[ETH_DST_MAC +i]=gwmacaddr[i]; // gw mac in local lan or host mac
    277c:	41 91       	ld	r20, Z+
    277e:	d8 01       	movw	r26, r16
    2780:	4d 93       	st	X+, r20
    2782:	8d 01       	movw	r16, r26
                buf[ETH_SRC_MAC +i]=macaddr[i];
    2784:	dc 01       	movw	r26, r24
    2786:	4d 91       	ld	r20, X+
    2788:	cd 01       	movw	r24, r26
    278a:	db 01       	movw	r26, r22
    278c:	4d 93       	st	X+, r20
    278e:	bd 01       	movw	r22, r26
// send_udp sends via gwip, you must call client_set_gwip at startu
void send_udp_prepare(uint8_t *buf,uint16_t sport, uint8_t *dip, uint16_t dport)
{
        uint8_t i=0;
        //
        while(i<6){
    2790:	b5 e0       	ldi	r27, 0x05	; 5
    2792:	e5 36       	cpi	r30, 0x65	; 101
    2794:	fb 07       	cpc	r31, r27
    2796:	91 f7       	brne	.-28     	; 0x277c <send_udp_prepare+0x32>
                buf[ETH_DST_MAC +i]=gwmacaddr[i]; // gw mac in local lan or host mac
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
        buf[ETH_TYPE_H_P] = ETHTYPE_IP_H_V;
    2798:	88 e0       	ldi	r24, 0x08	; 8
    279a:	f5 01       	movw	r30, r10
    279c:	84 87       	std	Z+12, r24	; 0x0c
        buf[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
    279e:	15 86       	std	Z+13, r1	; 0x0d
        fill_buf_p(&buf[IP_P],9,iphdr);
    27a0:	4f e7       	ldi	r20, 0x7F	; 127
    27a2:	51 e0       	ldi	r21, 0x01	; 1
    27a4:	69 e0       	ldi	r22, 0x09	; 9
    27a6:	70 e0       	ldi	r23, 0x00	; 0
    27a8:	c5 01       	movw	r24, r10
    27aa:	0e 96       	adiw	r24, 0x0e	; 14
    27ac:	29 83       	std	Y+1, r18	; 0x01
    27ae:	3a 83       	std	Y+2, r19	; 0x02
    27b0:	0e 94 97 13 	call	0x272e	; 0x272e <fill_buf_p>
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    27b4:	d5 01       	movw	r26, r10
    27b6:	50 96       	adiw	r26, 0x10	; 16
    27b8:	1c 92       	st	X, r1
    27ba:	50 97       	sbiw	r26, 0x10	; 16
        // done in transmit: buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
        buf[IP_PROTO_P]=IP_PROTO_UDP_V;
    27bc:	81 e1       	ldi	r24, 0x11	; 17
    27be:	57 96       	adiw	r26, 0x17	; 23
    27c0:	8c 93       	st	X, r24
    27c2:	86 01       	movw	r16, r12
    27c4:	c5 01       	movw	r24, r10
    27c6:	4e 96       	adiw	r24, 0x1e	; 30
    27c8:	a4 e5       	ldi	r26, 0x54	; 84
    27ca:	b5 e0       	ldi	r27, 0x05	; 5
    27cc:	3a 81       	ldd	r19, Y+2	; 0x02
    27ce:	29 81       	ldd	r18, Y+1	; 0x01
        i=0;
        while(i<4){
                buf[IP_DST_P+i]=dip[i];
    27d0:	f8 01       	movw	r30, r16
    27d2:	41 91       	ld	r20, Z+
    27d4:	8f 01       	movw	r16, r30
    27d6:	fc 01       	movw	r30, r24
    27d8:	41 93       	st	Z+, r20
    27da:	cf 01       	movw	r24, r30
                buf[IP_SRC_P+i]=ipaddr[i];
    27dc:	6d 91       	ld	r22, X+
    27de:	af 01       	movw	r20, r30
    27e0:	45 50       	subi	r20, 0x05	; 5
    27e2:	51 09       	sbc	r21, r1
    27e4:	fa 01       	movw	r30, r20
    27e6:	60 83       	st	Z, r22
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
        // done in transmit: buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
        buf[IP_PROTO_P]=IP_PROTO_UDP_V;
        i=0;
        while(i<4){
    27e8:	f5 e0       	ldi	r31, 0x05	; 5
    27ea:	a8 35       	cpi	r26, 0x58	; 88
    27ec:	bf 07       	cpc	r27, r31
    27ee:	81 f7       	brne	.-32     	; 0x27d0 <send_udp_prepare+0x86>
                buf[IP_DST_P+i]=dip[i];
                buf[IP_SRC_P+i]=ipaddr[i];
                i++;
        }
        // done in transmit: fill_ip_hdr_checksum(buf);
        buf[UDP_DST_PORT_H_P]=(dport>>8);
    27f0:	d5 01       	movw	r26, r10
    27f2:	94 96       	adiw	r26, 0x24	; 36
    27f4:	3c 93       	st	X, r19
    27f6:	94 97       	sbiw	r26, 0x24	; 36
        buf[UDP_DST_PORT_L_P]=0xff&dport; 
    27f8:	95 96       	adiw	r26, 0x25	; 37
    27fa:	2c 93       	st	X, r18
    27fc:	95 97       	sbiw	r26, 0x25	; 37
        buf[UDP_SRC_PORT_H_P]=(sport>>8);
    27fe:	92 96       	adiw	r26, 0x22	; 34
    2800:	ec 92       	st	X, r14
    2802:	92 97       	sbiw	r26, 0x22	; 34
        buf[UDP_SRC_PORT_L_P]=sport&0xff; 
    2804:	93 96       	adiw	r26, 0x23	; 35
    2806:	fc 92       	st	X, r15
    2808:	93 97       	sbiw	r26, 0x23	; 35
        buf[UDP_LEN_H_P]=0;
    280a:	96 96       	adiw	r26, 0x26	; 38
    280c:	1c 92       	st	X, r1
    280e:	96 97       	sbiw	r26, 0x26	; 38
        // done in transmit: buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    2810:	98 96       	adiw	r26, 0x28	; 40
    2812:	1c 92       	st	X, r1
    2814:	98 97       	sbiw	r26, 0x28	; 40
        buf[UDP_CHECKSUM_L_P]=0;
    2816:	99 96       	adiw	r26, 0x29	; 41
    2818:	1c 92       	st	X, r1
        // copy the data:
        // now starting with the first byte at buf[UDP_DATA_P]
        //
}
    281a:	0f 90       	pop	r0
    281c:	0f 90       	pop	r0
    281e:	df 91       	pop	r29
    2820:	cf 91       	pop	r28
    2822:	1f 91       	pop	r17
    2824:	0f 91       	pop	r16
    2826:	ff 90       	pop	r15
    2828:	ef 90       	pop	r14
    282a:	df 90       	pop	r13
    282c:	cf 90       	pop	r12
    282e:	bf 90       	pop	r11
    2830:	af 90       	pop	r10
    2832:	08 95       	ret

00002834 <send_udp_transmit>:

void send_udp_transmit(uint8_t *buf,uint8_t datalen)
{
    2834:	0f 93       	push	r16
    2836:	1f 93       	push	r17
    2838:	cf 93       	push	r28
    283a:	df 93       	push	r29
    283c:	ec 01       	movw	r28, r24
    283e:	06 2f       	mov	r16, r22
        uint16_t ck;
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    2840:	8c e1       	ldi	r24, 0x1C	; 28
    2842:	86 0f       	add	r24, r22
    2844:	89 8b       	std	Y+17, r24	; 0x11
        fill_ip_hdr_checksum(buf);
    2846:	ce 01       	movw	r24, r28
    2848:	0e 94 41 11 	call	0x2282	; 0x2282 <fill_ip_hdr_checksum>
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    284c:	88 e0       	ldi	r24, 0x08	; 8
    284e:	80 0f       	add	r24, r16
    2850:	8f a3       	std	Y+39, r24	; 0x27
        //
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    2852:	10 e0       	ldi	r17, 0x00	; 0
    2854:	b8 01       	movw	r22, r16
    2856:	60 5f       	subi	r22, 0xF0	; 240
    2858:	7f 4f       	sbci	r23, 0xFF	; 255
    285a:	41 e0       	ldi	r20, 0x01	; 1
    285c:	ce 01       	movw	r24, r28
    285e:	4a 96       	adiw	r24, 0x1a	; 26
    2860:	0e 94 74 10 	call	0x20e8	; 0x20e8 <checksum>
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    2864:	98 a7       	std	Y+40, r25	; 0x28
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
    2866:	89 a7       	std	Y+41, r24	; 0x29
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    2868:	be 01       	movw	r22, r28
    286a:	c8 01       	movw	r24, r16
    286c:	8a 96       	adiw	r24, 0x2a	; 42
}
    286e:	df 91       	pop	r29
    2870:	cf 91       	pop	r28
    2872:	1f 91       	pop	r17
    2874:	0f 91       	pop	r16
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        //
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
        buf[UDP_CHECKSUM_H_P]=ck>>8;
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    2876:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

0000287a <client_arp_whohas>:
#endif // WOL_client

#if defined (NTP_client) || defined (UDP_client) || defined (TCP_client) || defined (PING_client)
// make a arp request
void client_arp_whohas(uint8_t *buf,uint8_t *ip_we_search)
{
    287a:	0f 93       	push	r16
    287c:	1f 93       	push	r17
    287e:	cf 93       	push	r28
    2880:	df 93       	push	r29
    2882:	ec 01       	movw	r28, r24
    2884:	8b 01       	movw	r16, r22
    2886:	ae 01       	movw	r20, r28
    2888:	4a 5f       	subi	r20, 0xFA	; 250
    288a:	5f 4f       	sbci	r21, 0xFF	; 255
    288c:	e8 e5       	ldi	r30, 0x58	; 88
    288e:	f5 e0       	ldi	r31, 0x05	; 5
        uint8_t i=0;
        //
        while(i<6){
                buf[ETH_DST_MAC +i]=0xff;
    2890:	3f ef       	ldi	r19, 0xFF	; 255
    2892:	dc 01       	movw	r26, r24
    2894:	3d 93       	st	X+, r19
    2896:	cd 01       	movw	r24, r26
                buf[ETH_SRC_MAC +i]=macaddr[i];
    2898:	21 91       	ld	r18, Z+
    289a:	da 01       	movw	r26, r20
    289c:	2d 93       	st	X+, r18
    289e:	ad 01       	movw	r20, r26
// make a arp request
void client_arp_whohas(uint8_t *buf,uint8_t *ip_we_search)
{
        uint8_t i=0;
        //
        while(i<6){
    28a0:	b5 e0       	ldi	r27, 0x05	; 5
    28a2:	ee 35       	cpi	r30, 0x5E	; 94
    28a4:	fb 07       	cpc	r31, r27
    28a6:	a9 f7       	brne	.-22     	; 0x2892 <client_arp_whohas+0x18>
                buf[ETH_DST_MAC +i]=0xff;
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
        buf[ETH_TYPE_H_P] = ETHTYPE_ARP_H_V;
    28a8:	88 e0       	ldi	r24, 0x08	; 8
    28aa:	8c 87       	std	Y+12, r24	; 0x0c
        buf[ETH_TYPE_L_P] = ETHTYPE_ARP_L_V;
    28ac:	86 e0       	ldi	r24, 0x06	; 6
    28ae:	8d 87       	std	Y+13, r24	; 0x0d
        fill_buf_p(&buf[ETH_ARP_P],8,arpreqhdr);
    28b0:	48 e8       	ldi	r20, 0x88	; 136
    28b2:	51 e0       	ldi	r21, 0x01	; 1
    28b4:	68 e0       	ldi	r22, 0x08	; 8
    28b6:	70 e0       	ldi	r23, 0x00	; 0
    28b8:	ce 01       	movw	r24, r28
    28ba:	0e 96       	adiw	r24, 0x0e	; 14
    28bc:	0e 94 97 13 	call	0x272e	; 0x272e <fill_buf_p>
    28c0:	de 01       	movw	r26, r28
    28c2:	90 96       	adiw	r26, 0x20	; 32
    28c4:	48 e5       	ldi	r20, 0x58	; 88
    28c6:	55 e0       	ldi	r21, 0x05	; 5
        i=0;
        while(i<6){
                buf[ETH_ARP_SRC_MAC_P +i]=macaddr[i];
    28c8:	fa 01       	movw	r30, r20
    28ca:	21 91       	ld	r18, Z+
    28cc:	af 01       	movw	r20, r30
    28ce:	cd 01       	movw	r24, r26
    28d0:	0a 97       	sbiw	r24, 0x0a	; 10
    28d2:	fc 01       	movw	r30, r24
    28d4:	20 83       	st	Z, r18
                buf[ETH_ARP_DST_MAC_P+i]=0;
    28d6:	1d 92       	st	X+, r1
        }
        buf[ETH_TYPE_H_P] = ETHTYPE_ARP_H_V;
        buf[ETH_TYPE_L_P] = ETHTYPE_ARP_L_V;
        fill_buf_p(&buf[ETH_ARP_P],8,arpreqhdr);
        i=0;
        while(i<6){
    28d8:	f5 e0       	ldi	r31, 0x05	; 5
    28da:	4e 35       	cpi	r20, 0x5E	; 94
    28dc:	5f 07       	cpc	r21, r31
    28de:	a1 f7       	brne	.-24     	; 0x28c8 <client_arp_whohas+0x4e>
    28e0:	b8 01       	movw	r22, r16
    28e2:	ce 01       	movw	r24, r28
    28e4:	86 96       	adiw	r24, 0x26	; 38
    28e6:	a4 e5       	ldi	r26, 0x54	; 84
    28e8:	b5 e0       	ldi	r27, 0x05	; 5
                buf[ETH_ARP_DST_MAC_P+i]=0;
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=*(ip_we_search +i);
    28ea:	fb 01       	movw	r30, r22
    28ec:	21 91       	ld	r18, Z+
    28ee:	bf 01       	movw	r22, r30
    28f0:	fc 01       	movw	r30, r24
    28f2:	21 93       	st	Z+, r18
    28f4:	cf 01       	movw	r24, r30
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    28f6:	4d 91       	ld	r20, X+
    28f8:	9f 01       	movw	r18, r30
    28fa:	2b 50       	subi	r18, 0x0B	; 11
    28fc:	31 09       	sbc	r19, r1
    28fe:	f9 01       	movw	r30, r18
    2900:	40 83       	st	Z, r20
                buf[ETH_ARP_SRC_MAC_P +i]=macaddr[i];
                buf[ETH_ARP_DST_MAC_P+i]=0;
                i++;
        }
        i=0;
        while(i<4){
    2902:	f5 e0       	ldi	r31, 0x05	; 5
    2904:	a8 35       	cpi	r26, 0x58	; 88
    2906:	bf 07       	cpc	r27, r31
    2908:	81 f7       	brne	.-32     	; 0x28ea <client_arp_whohas+0x70>
                buf[ETH_ARP_DST_IP_P+i]=*(ip_we_search +i);
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        waitgwmac|=WGW_ACCEPT_ARP_REPLY;
    290a:	80 91 5e 05 	lds	r24, 0x055E
    290e:	88 60       	ori	r24, 0x08	; 8
    2910:	80 93 5e 05 	sts	0x055E, r24
        // 0x2a=42=len of packet
        enc28j60PacketSend(0x2a,buf);
    2914:	be 01       	movw	r22, r28
    2916:	8a e2       	ldi	r24, 0x2A	; 42
    2918:	90 e0       	ldi	r25, 0x00	; 0
}
    291a:	df 91       	pop	r29
    291c:	cf 91       	pop	r28
    291e:	1f 91       	pop	r17
    2920:	0f 91       	pop	r16
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        waitgwmac|=WGW_ACCEPT_ARP_REPLY;
        // 0x2a=42=len of packet
        enc28j60PacketSend(0x2a,buf);
    2922:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

00002926 <client_waiting_gw>:
}

uint8_t client_waiting_gw(void)
{
        if (waitgwmac & WGW_HAVE_GW_MAC){
    2926:	80 91 5e 05 	lds	r24, 0x055E
    292a:	86 95       	lsr	r24
    292c:	81 70       	andi	r24, 0x01	; 1
                return(0);
        }
        return(1);
}
    292e:	91 e0       	ldi	r25, 0x01	; 1
    2930:	89 27       	eor	r24, r25
    2932:	08 95       	ret

00002934 <client_store_gw_mac>:

// store the mac addr from an arp reply
// no len check here, you must first call eth_type_is_arp_and_my_ip
uint8_t client_store_gw_mac(uint8_t *buf)
{
    2934:	dc 01       	movw	r26, r24
    2936:	5c 96       	adiw	r26, 0x1c	; 28
    2938:	e3 e2       	ldi	r30, 0x23	; 35
    293a:	f1 e0       	ldi	r31, 0x01	; 1
        uint8_t i=0;
        while(i<4){
                if(buf[ETH_ARP_SRC_IP_P+i]!=gwip[i]){
    293c:	3d 91       	ld	r19, X+
    293e:	21 91       	ld	r18, Z+
    2940:	32 13       	cpse	r19, r18
    2942:	0f c0       	rjmp	.+30     	; 0x2962 <client_store_gw_mac+0x2e>
// store the mac addr from an arp reply
// no len check here, you must first call eth_type_is_arp_and_my_ip
uint8_t client_store_gw_mac(uint8_t *buf)
{
        uint8_t i=0;
        while(i<4){
    2944:	21 e0       	ldi	r18, 0x01	; 1
    2946:	e7 32       	cpi	r30, 0x27	; 39
    2948:	f2 07       	cpc	r31, r18
    294a:	c1 f7       	brne	.-16     	; 0x293c <client_store_gw_mac+0x8>
    294c:	dc 01       	movw	r26, r24
    294e:	56 96       	adiw	r26, 0x16	; 22
    2950:	ef e5       	ldi	r30, 0x5F	; 95
    2952:	f5 e0       	ldi	r31, 0x05	; 5
                }
                i++;
        }
        i=0;
        while(i<6){
                gwmacaddr[i]=buf[ETH_ARP_SRC_MAC_P +i];
    2954:	8d 91       	ld	r24, X+
    2956:	81 93       	st	Z+, r24
                        return(0);
                }
                i++;
        }
        i=0;
        while(i<6){
    2958:	85 e0       	ldi	r24, 0x05	; 5
    295a:	e5 36       	cpi	r30, 0x65	; 101
    295c:	f8 07       	cpc	r31, r24
    295e:	d1 f7       	brne	.-12     	; 0x2954 <client_store_gw_mac+0x20>
    2960:	02 c0       	rjmp	.+4      	; 0x2966 <client_store_gw_mac+0x32>
uint8_t client_store_gw_mac(uint8_t *buf)
{
        uint8_t i=0;
        while(i<4){
                if(buf[ETH_ARP_SRC_IP_P+i]!=gwip[i]){
                        return(0);
    2962:	80 e0       	ldi	r24, 0x00	; 0
    2964:	08 95       	ret
        i=0;
        while(i<6){
                gwmacaddr[i]=buf[ETH_ARP_SRC_MAC_P +i];
                i++;
        }
        return(1);
    2966:	81 e0       	ldi	r24, 0x01	; 1
}
    2968:	08 95       	ret

0000296a <client_set_gwip>:
}

void client_set_gwip(uint8_t *gwipaddr)
{
        uint8_t i=0;
        waitgwmac=WGW_INITIAL_ARP; // causes an arp request in the packet loop
    296a:	21 e0       	ldi	r18, 0x01	; 1
    296c:	20 93 5e 05 	sts	0x055E, r18
    2970:	e3 e2       	ldi	r30, 0x23	; 35
    2972:	f1 e0       	ldi	r31, 0x01	; 1
        while(i<4){
                gwip[i]=gwipaddr[i];
    2974:	dc 01       	movw	r26, r24
    2976:	2d 91       	ld	r18, X+
    2978:	cd 01       	movw	r24, r26
    297a:	21 93       	st	Z+, r18

void client_set_gwip(uint8_t *gwipaddr)
{
        uint8_t i=0;
        waitgwmac=WGW_INITIAL_ARP; // causes an arp request in the packet loop
        while(i<4){
    297c:	b1 e0       	ldi	r27, 0x01	; 1
    297e:	e7 32       	cpi	r30, 0x27	; 39
    2980:	fb 07       	cpc	r31, r27
    2982:	c1 f7       	brne	.-16     	; 0x2974 <client_set_gwip+0xa>
                gwip[i]=gwipaddr[i];
                i++;
        }
}
    2984:	08 95       	ret

00002986 <client_tcp_set_serverip>:
#endif // NTP_client || UDP_client || TCP_client || PING_client

#if defined (TCP_client)
void client_tcp_set_serverip(uint8_t *ipaddr)
{
    2986:	ee e7       	ldi	r30, 0x7E	; 126
    2988:	f5 e0       	ldi	r31, 0x05	; 5
        uint8_t i=0;
        while(i<4){
                tcpsrvip[i]=ipaddr[i];
    298a:	dc 01       	movw	r26, r24
    298c:	2d 91       	ld	r18, X+
    298e:	cd 01       	movw	r24, r26
    2990:	21 93       	st	Z+, r18

#if defined (TCP_client)
void client_tcp_set_serverip(uint8_t *ipaddr)
{
        uint8_t i=0;
        while(i<4){
    2992:	b5 e0       	ldi	r27, 0x05	; 5
    2994:	e2 38       	cpi	r30, 0x82	; 130
    2996:	fb 07       	cpc	r31, r27
    2998:	c1 f7       	brne	.-16     	; 0x298a <client_tcp_set_serverip+0x4>
                tcpsrvip[i]=ipaddr[i];
                i++;
        }
}
    299a:	08 95       	ret

0000299c <client_syn>:
#endif // TCP_client

#if defined (TCP_client)
// Make a tcp syn packet
void client_syn(uint8_t *buf,uint8_t srcport,uint8_t dstport_h,uint8_t dstport_l)
{
    299c:	df 92       	push	r13
    299e:	ef 92       	push	r14
    29a0:	ff 92       	push	r15
    29a2:	0f 93       	push	r16
    29a4:	1f 93       	push	r17
    29a6:	cf 93       	push	r28
    29a8:	df 93       	push	r29
    29aa:	ec 01       	movw	r28, r24
    29ac:	f6 2e       	mov	r15, r22
    29ae:	e4 2e       	mov	r14, r20
    29b0:	d2 2e       	mov	r13, r18
    29b2:	ef e5       	ldi	r30, 0x5F	; 95
    29b4:	f5 e0       	ldi	r31, 0x05	; 5
    29b6:	8c 01       	movw	r16, r24
    29b8:	88 e5       	ldi	r24, 0x58	; 88
    29ba:	95 e0       	ldi	r25, 0x05	; 5
    29bc:	ae 01       	movw	r20, r28
    29be:	4a 5f       	subi	r20, 0xFA	; 250
    29c0:	5f 4f       	sbci	r21, 0xFF	; 255
        uint16_t ck;
        uint8_t i=0;
        // -- make the main part of the eth/IP/tcp header:
        while(i<6){
                buf[ETH_DST_MAC +i]=gwmacaddr[i]; // gw mac in local lan or host mac
    29c2:	21 91       	ld	r18, Z+
    29c4:	d8 01       	movw	r26, r16
    29c6:	2d 93       	st	X+, r18
    29c8:	8d 01       	movw	r16, r26
                buf[ETH_SRC_MAC +i]=macaddr[i];
    29ca:	dc 01       	movw	r26, r24
    29cc:	2d 91       	ld	r18, X+
    29ce:	cd 01       	movw	r24, r26
    29d0:	da 01       	movw	r26, r20
    29d2:	2d 93       	st	X+, r18
    29d4:	ad 01       	movw	r20, r26
void client_syn(uint8_t *buf,uint8_t srcport,uint8_t dstport_h,uint8_t dstport_l)
{
        uint16_t ck;
        uint8_t i=0;
        // -- make the main part of the eth/IP/tcp header:
        while(i<6){
    29d6:	b5 e0       	ldi	r27, 0x05	; 5
    29d8:	e5 36       	cpi	r30, 0x65	; 101
    29da:	fb 07       	cpc	r31, r27
    29dc:	91 f7       	brne	.-28     	; 0x29c2 <client_syn+0x26>
                buf[ETH_DST_MAC +i]=gwmacaddr[i]; // gw mac in local lan or host mac
                buf[ETH_SRC_MAC +i]=macaddr[i];
                i++;
        }
        buf[ETH_TYPE_H_P] = ETHTYPE_IP_H_V;
    29de:	88 e0       	ldi	r24, 0x08	; 8
    29e0:	8c 87       	std	Y+12, r24	; 0x0c
        buf[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
    29e2:	1d 86       	std	Y+13, r1	; 0x0d
        fill_buf_p(&buf[IP_P],9,iphdr);
    29e4:	4f e7       	ldi	r20, 0x7F	; 127
    29e6:	51 e0       	ldi	r21, 0x01	; 1
    29e8:	69 e0       	ldi	r22, 0x09	; 9
    29ea:	70 e0       	ldi	r23, 0x00	; 0
    29ec:	ce 01       	movw	r24, r28
    29ee:	0e 96       	adiw	r24, 0x0e	; 14
    29f0:	0e 94 97 13 	call	0x272e	; 0x272e <fill_buf_p>
        buf[IP_TOTLEN_L_P]=44; // good for syn
    29f4:	8c e2       	ldi	r24, 0x2C	; 44
    29f6:	89 8b       	std	Y+17, r24	; 0x11
        buf[IP_PROTO_P]=IP_PROTO_TCP_V;
    29f8:	86 e0       	ldi	r24, 0x06	; 6
    29fa:	8f 8b       	std	Y+23, r24	; 0x17
    29fc:	6e e7       	ldi	r22, 0x7E	; 126
    29fe:	75 e0       	ldi	r23, 0x05	; 5
    2a00:	de 01       	movw	r26, r28
    2a02:	5e 96       	adiw	r26, 0x1e	; 30
    2a04:	84 e5       	ldi	r24, 0x54	; 84
    2a06:	95 e0       	ldi	r25, 0x05	; 5
        i=0;
        while(i<4){
                buf[IP_DST_P+i]=tcpsrvip[i];
    2a08:	fb 01       	movw	r30, r22
    2a0a:	21 91       	ld	r18, Z+
    2a0c:	bf 01       	movw	r22, r30
    2a0e:	2d 93       	st	X+, r18
                buf[IP_SRC_P+i]=ipaddr[i];
    2a10:	fc 01       	movw	r30, r24
    2a12:	41 91       	ld	r20, Z+
    2a14:	cf 01       	movw	r24, r30
    2a16:	9d 01       	movw	r18, r26
    2a18:	25 50       	subi	r18, 0x05	; 5
    2a1a:	31 09       	sbc	r19, r1
    2a1c:	f9 01       	movw	r30, r18
    2a1e:	40 83       	st	Z, r20
        buf[ETH_TYPE_L_P] = ETHTYPE_IP_L_V;
        fill_buf_p(&buf[IP_P],9,iphdr);
        buf[IP_TOTLEN_L_P]=44; // good for syn
        buf[IP_PROTO_P]=IP_PROTO_TCP_V;
        i=0;
        while(i<4){
    2a20:	f5 e0       	ldi	r31, 0x05	; 5
    2a22:	62 38       	cpi	r22, 0x82	; 130
    2a24:	7f 07       	cpc	r23, r31
    2a26:	81 f7       	brne	.-32     	; 0x2a08 <client_syn+0x6c>
                buf[IP_DST_P+i]=tcpsrvip[i];
                buf[IP_SRC_P+i]=ipaddr[i];
                i++;
        }
        fill_ip_hdr_checksum(buf);
    2a28:	ce 01       	movw	r24, r28
    2a2a:	0e 94 41 11 	call	0x2282	; 0x2282 <fill_ip_hdr_checksum>
        buf[TCP_DST_PORT_H_P]=dstport_h;
    2a2e:	ec a2       	std	Y+36, r14	; 0x24
        buf[TCP_DST_PORT_L_P]=dstport_l;
    2a30:	dd a2       	std	Y+37, r13	; 0x25
        buf[TCP_SRC_PORT_H_P]=TCPCLIENT_SRC_PORT_H;
    2a32:	8b e0       	ldi	r24, 0x0B	; 11
    2a34:	8a a3       	std	Y+34, r24	; 0x22
        buf[TCP_SRC_PORT_L_P]=srcport; // lower 8 bit of src port
    2a36:	fb a2       	std	Y+35, r15	; 0x23
    2a38:	fe 01       	movw	r30, r28
    2a3a:	b6 96       	adiw	r30, 0x26	; 38
    2a3c:	88 e0       	ldi	r24, 0x08	; 8
        i=0;
        // zero out sequence number and acknowledgement number
        while(i<8){
                buf[TCP_SEQ_H_P+i]=0;
    2a3e:	11 92       	st	Z+, r1
    2a40:	81 50       	subi	r24, 0x01	; 1
        buf[TCP_DST_PORT_L_P]=dstport_l;
        buf[TCP_SRC_PORT_H_P]=TCPCLIENT_SRC_PORT_H;
        buf[TCP_SRC_PORT_L_P]=srcport; // lower 8 bit of src port
        i=0;
        // zero out sequence number and acknowledgement number
        while(i<8){
    2a42:	e9 f7       	brne	.-6      	; 0x2a3e <client_syn+0xa2>
        // -- header ready 
        // put inital seq number
        // we step only the second byte, this allows us to send packts 
        // with 255 bytes 512 (if we step the initial seqnum by 2)
        // or 765 (step by 3)
        buf[TCP_SEQ_H_P+2]= seqnum; 
    2a44:	80 91 00 01 	lds	r24, 0x0100
    2a48:	88 a7       	std	Y+40, r24	; 0x28
        // step the inititial seq num by something we will not use
        // during this tcp session:
        seqnum+=3;
    2a4a:	8d 5f       	subi	r24, 0xFD	; 253
    2a4c:	80 93 00 01 	sts	0x0100, r24
        buf[TCP_HEADER_LEN_P]=0x60; // 0x60=24 len: (0x60>>4) * 4
    2a50:	80 e6       	ldi	r24, 0x60	; 96
    2a52:	8e a7       	std	Y+46, r24	; 0x2e
        buf[TCP_FLAGS_P]=TCP_FLAGS_SYN_V;
    2a54:	82 e0       	ldi	r24, 0x02	; 2
    2a56:	8f a7       	std	Y+47, r24	; 0x2f
        // use a low window size otherwise we have to have
        // timers and can not just react on every packet.
        buf[TCP_WIN_SIZE]=0x3; // 1024=0x400 768=0x300, initial window
    2a58:	93 e0       	ldi	r25, 0x03	; 3
    2a5a:	98 ab       	std	Y+48, r25	; 0x30
        buf[TCP_WIN_SIZE+1]=0x0;
    2a5c:	19 aa       	std	Y+49, r1	; 0x31
        // zero the checksum
        buf[TCP_CHECKSUM_H_P]=0;
    2a5e:	1a aa       	std	Y+50, r1	; 0x32
        buf[TCP_CHECKSUM_L_P]=0;
    2a60:	1b aa       	std	Y+51, r1	; 0x33
        // urgent pointer
        buf[TCP_CHECKSUM_L_P+1]=0;
    2a62:	1c aa       	std	Y+52, r1	; 0x34
        buf[TCP_CHECKSUM_L_P+2]=0;
    2a64:	1d aa       	std	Y+53, r1	; 0x35
        // MSS= max IP len that we want to have:
        buf[TCP_OPTIONS_P]=2;
    2a66:	8e ab       	std	Y+54, r24	; 0x36
        buf[TCP_OPTIONS_P+1]=4;
    2a68:	94 e0       	ldi	r25, 0x04	; 4
    2a6a:	9f ab       	std	Y+55, r25	; 0x37
        buf[TCP_OPTIONS_P+2]=(CLIENTMSS>>8);
    2a6c:	88 af       	std	Y+56, r24	; 0x38
        buf[TCP_OPTIONS_P+3]=CLIENTMSS & 0xff;
    2a6e:	86 e2       	ldi	r24, 0x26	; 38
    2a70:	89 af       	std	Y+57, r24	; 0x39
        ck=checksum(&buf[IP_SRC_P], 8 +TCP_HEADER_LEN_PLAIN+4,2);
    2a72:	42 e0       	ldi	r20, 0x02	; 2
    2a74:	60 e2       	ldi	r22, 0x20	; 32
    2a76:	70 e0       	ldi	r23, 0x00	; 0
    2a78:	ce 01       	movw	r24, r28
    2a7a:	4a 96       	adiw	r24, 0x1a	; 26
    2a7c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <checksum>
        buf[TCP_CHECKSUM_H_P]=ck>>8;
    2a80:	9a ab       	std	Y+50, r25	; 0x32
        buf[TCP_CHECKSUM_L_P]=ck& 0xff;
    2a82:	8b ab       	std	Y+51, r24	; 0x33
        // 4 is the tcp mss option:
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN+4,buf);
    2a84:	be 01       	movw	r22, r28
    2a86:	8a e3       	ldi	r24, 0x3A	; 58
    2a88:	90 e0       	ldi	r25, 0x00	; 0
}
    2a8a:	df 91       	pop	r29
    2a8c:	cf 91       	pop	r28
    2a8e:	1f 91       	pop	r17
    2a90:	0f 91       	pop	r16
    2a92:	ff 90       	pop	r15
    2a94:	ef 90       	pop	r14
    2a96:	df 90       	pop	r13
        buf[TCP_OPTIONS_P+3]=CLIENTMSS & 0xff;
        ck=checksum(&buf[IP_SRC_P], 8 +TCP_HEADER_LEN_PLAIN+4,2);
        buf[TCP_CHECKSUM_H_P]=ck>>8;
        buf[TCP_CHECKSUM_L_P]=ck& 0xff;
        // 4 is the tcp mss option:
        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN+4,buf);
    2a98:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <enc28j60PacketSend>

00002a9c <client_tcp_req>:
// We use callback functions because that saves memory and a uC is very
// limited in memory
//
uint8_t client_tcp_req(uint8_t (*result_callback)(uint8_t fd,uint8_t statuscode,uint16_t data_start_pos_in_buf, uint16_t len_of_data),uint16_t (*datafill_callback)(uint8_t fd),uint16_t port)
{
        client_tcp_result_callback=result_callback;
    2a9c:	90 93 7a 05 	sts	0x057A, r25
    2aa0:	80 93 79 05 	sts	0x0579, r24
        client_tcp_datafill_callback=datafill_callback;
    2aa4:	70 93 78 05 	sts	0x0578, r23
    2aa8:	60 93 77 05 	sts	0x0577, r22
        tcp_client_port_h=(port>>8) & 0xff;
    2aac:	50 93 7c 05 	sts	0x057C, r21
        tcp_client_port_l=(port & 0xff);
    2ab0:	40 93 7b 05 	sts	0x057B, r20
        tcp_client_state=1; // send a syn
    2ab4:	81 e0       	ldi	r24, 0x01	; 1
    2ab6:	80 93 7d 05 	sts	0x057D, r24
        tcp_fd++;
    2aba:	80 91 82 05 	lds	r24, 0x0582
    2abe:	8f 5f       	subi	r24, 0xFF	; 255
        if (tcp_fd>7){
    2ac0:	88 30       	cpi	r24, 0x08	; 8
    2ac2:	18 f4       	brcc	.+6      	; 0x2aca <client_tcp_req+0x2e>
        client_tcp_result_callback=result_callback;
        client_tcp_datafill_callback=datafill_callback;
        tcp_client_port_h=(port>>8) & 0xff;
        tcp_client_port_l=(port & 0xff);
        tcp_client_state=1; // send a syn
        tcp_fd++;
    2ac4:	80 93 82 05 	sts	0x0582, r24
    2ac8:	02 c0       	rjmp	.+4      	; 0x2ace <client_tcp_req+0x32>
        if (tcp_fd>7){
                tcp_fd=0;
    2aca:	10 92 82 05 	sts	0x0582, r1
        }
        return(tcp_fd);
}
    2ace:	80 91 82 05 	lds	r24, 0x0582
    2ad2:	08 95       	ret

00002ad4 <client_browse_url>:
// statuscode==1 means there is a valid tcp data but not a "200 OK"
// answer. Any other statuscode than 0 and 1 is a total communication failure.
//
void client_browse_url(char *urlbuf, char *urlbuf_varpart, char *hoststr,void (*callback)(uint8_t,uint16_t,uint16_t))
{
        client_urlbuf=urlbuf;
    2ad4:	90 93 6e 05 	sts	0x056E, r25
    2ad8:	80 93 6d 05 	sts	0x056D, r24
        client_urlbuf_var=urlbuf_varpart;
    2adc:	70 93 6c 05 	sts	0x056C, r23
    2ae0:	60 93 6b 05 	sts	0x056B, r22
        client_hoststr=hoststr;
    2ae4:	50 93 6a 05 	sts	0x056A, r21
    2ae8:	40 93 69 05 	sts	0x0569, r20
        browsertype=0;
    2aec:	10 92 75 05 	sts	0x0575, r1
        client_browser_callback=callback;
    2af0:	30 93 74 05 	sts	0x0574, r19
    2af4:	20 93 73 05 	sts	0x0573, r18
        www_fd=client_tcp_req(&www_client_internal_result_callback,&www_client_internal_datafill_callback,80);
    2af8:	40 e5       	ldi	r20, 0x50	; 80
    2afa:	50 e0       	ldi	r21, 0x00	; 0
    2afc:	6c e5       	ldi	r22, 0x5C	; 92
    2afe:	72 e1       	ldi	r23, 0x12	; 18
    2b00:	8b e2       	ldi	r24, 0x2B	; 43
    2b02:	90 e1       	ldi	r25, 0x10	; 16
    2b04:	0e 94 4e 15 	call	0x2a9c	; 0x2a9c <client_tcp_req>
    2b08:	80 93 76 05 	sts	0x0576, r24
    2b0c:	08 95       	ret

00002b0e <packetloop_icmp_tcp>:


// return 0 to just continue in the packet loop and return the position 
// of the tcp data if there is tcp data part
uint16_t packetloop_icmp_tcp(uint8_t *buf,uint16_t plen)
{
    2b0e:	cf 92       	push	r12
    2b10:	df 92       	push	r13
    2b12:	ef 92       	push	r14
    2b14:	ff 92       	push	r15
    2b16:	0f 93       	push	r16
    2b18:	1f 93       	push	r17
    2b1a:	cf 93       	push	r28
    2b1c:	df 93       	push	r29
    2b1e:	1f 92       	push	r1
    2b20:	cd b7       	in	r28, 0x3d	; 61
    2b22:	de b7       	in	r29, 0x3e	; 62
    2b24:	6c 01       	movw	r12, r24
    2b26:	8b 01       	movw	r16, r22
        uint16_t save_len;
#endif
        //plen will be unequal to zero if there is a valid 
        // packet (without crc error):
#if defined (NTP_client) ||  defined (UDP_client) || defined (TCP_client) || defined (PING_client)
        if(plen==0){
    2b28:	61 15       	cp	r22, r1
    2b2a:	71 05       	cpc	r23, r1
    2b2c:	e9 f5       	brne	.+122    	; 0x2ba8 <packetloop_icmp_tcp+0x9a>
    2b2e:	80 91 5e 05 	lds	r24, 0x055E
    2b32:	85 70       	andi	r24, 0x05	; 5
                if ((waitgwmac & WGW_INITIAL_ARP||waitgwmac & WGW_REFRESHING) && delaycnt==0&& enc28j60linkup()){
    2b34:	79 f0       	breq	.+30     	; 0x2b54 <packetloop_icmp_tcp+0x46>
    2b36:	80 91 01 01 	lds	r24, 0x0101
    2b3a:	90 91 02 01 	lds	r25, 0x0102
    2b3e:	89 2b       	or	r24, r25
    2b40:	49 f4       	brne	.+18     	; 0x2b54 <packetloop_icmp_tcp+0x46>
    2b42:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <enc28j60linkup>
    2b46:	88 23       	and	r24, r24
    2b48:	29 f0       	breq	.+10     	; 0x2b54 <packetloop_icmp_tcp+0x46>
                        client_arp_whohas(buf,gwip);
    2b4a:	63 e2       	ldi	r22, 0x23	; 35
    2b4c:	71 e0       	ldi	r23, 0x01	; 1
    2b4e:	c6 01       	movw	r24, r12
    2b50:	0e 94 3d 14 	call	0x287a	; 0x287a <client_arp_whohas>
                }
                delaycnt++;
    2b54:	80 91 01 01 	lds	r24, 0x0101
    2b58:	90 91 02 01 	lds	r25, 0x0102
    2b5c:	01 96       	adiw	r24, 0x01	; 1
    2b5e:	90 93 02 01 	sts	0x0102, r25
    2b62:	80 93 01 01 	sts	0x0101, r24
#if defined (TCP_client)
                if (tcp_client_state==1 && (waitgwmac & WGW_HAVE_GW_MAC)){ // send a syn
    2b66:	80 91 7d 05 	lds	r24, 0x057D
    2b6a:	81 30       	cpi	r24, 0x01	; 1
    2b6c:	09 f0       	breq	.+2      	; 0x2b70 <packetloop_icmp_tcp+0x62>
    2b6e:	4b c1       	rjmp	.+662    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
    2b70:	80 91 5e 05 	lds	r24, 0x055E
    2b74:	81 ff       	sbrs	r24, 1
    2b76:	47 c1       	rjmp	.+654    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        tcp_client_state=2;
    2b78:	82 e0       	ldi	r24, 0x02	; 2
    2b7a:	80 93 7d 05 	sts	0x057D, r24
                        tcpclient_src_port_l++; // allocate a new port
    2b7e:	60 91 03 01 	lds	r22, 0x0103
    2b82:	6f 5f       	subi	r22, 0xFF	; 255
    2b84:	60 93 03 01 	sts	0x0103, r22
                        // we encode our 3 bit fd into the src port this
                        // way we get it back in every message that comes
                        // from the server:
                        client_syn(buf,((tcp_fd<<5) | (0x1f & tcpclient_src_port_l)),tcp_client_port_h,tcp_client_port_l);
    2b88:	6f 71       	andi	r22, 0x1F	; 31
    2b8a:	80 91 82 05 	lds	r24, 0x0582
    2b8e:	20 e2       	ldi	r18, 0x20	; 32
    2b90:	82 9f       	mul	r24, r18
    2b92:	c0 01       	movw	r24, r0
    2b94:	11 24       	eor	r1, r1
    2b96:	68 2b       	or	r22, r24
    2b98:	20 91 7b 05 	lds	r18, 0x057B
    2b9c:	40 91 7c 05 	lds	r20, 0x057C
    2ba0:	c6 01       	movw	r24, r12
    2ba2:	0e 94 ce 14 	call	0x299c	; 0x299c <client_syn>
    2ba6:	2f c1       	rjmp	.+606    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
        }
#endif // NTP_client||UDP_client||TCP_client||PING_client
        // arp is broadcast if unknown but a host may also
        // verify the mac address by sending it to 
        // a unicast address.
        if(eth_type_is_arp_and_my_ip(buf,plen)){
    2ba8:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <eth_type_is_arp_and_my_ip>
    2bac:	88 23       	and	r24, r24
    2bae:	d1 f0       	breq	.+52     	; 0x2be4 <packetloop_icmp_tcp+0xd6>
                if (buf[ETH_ARP_OPCODE_L_P]==ETH_ARP_OPCODE_REQ_L_V){
    2bb0:	d6 01       	movw	r26, r12
    2bb2:	55 96       	adiw	r26, 0x15	; 21
    2bb4:	8c 91       	ld	r24, X
    2bb6:	81 30       	cpi	r24, 0x01	; 1
    2bb8:	19 f4       	brne	.+6      	; 0x2bc0 <packetloop_icmp_tcp+0xb2>
                        // is it an arp request 
                        make_arp_answer_from_request(buf);
    2bba:	c6 01       	movw	r24, r12
    2bbc:	0e 94 94 11 	call	0x2328	; 0x2328 <make_arp_answer_from_request>
                }
#if defined (NTP_client) || defined (UDP_client) || defined (TCP_client) || defined (PING_client)
                if (waitgwmac & WGW_ACCEPT_ARP_REPLY && (buf[ETH_ARP_OPCODE_L_P]==ETH_ARP_OPCODE_REPLY_L_V)){
    2bc0:	80 91 5e 05 	lds	r24, 0x055E
    2bc4:	83 ff       	sbrs	r24, 3
    2bc6:	1f c1       	rjmp	.+574    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
    2bc8:	f6 01       	movw	r30, r12
    2bca:	15 89       	ldd	r17, Z+21	; 0x15
    2bcc:	12 30       	cpi	r17, 0x02	; 2
    2bce:	09 f0       	breq	.+2      	; 0x2bd2 <packetloop_icmp_tcp+0xc4>
    2bd0:	1a c1       	rjmp	.+564    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        // is it an arp reply 
                        if (client_store_gw_mac(buf)){
    2bd2:	c6 01       	movw	r24, r12
    2bd4:	0e 94 9a 14 	call	0x2934	; 0x2934 <client_store_gw_mac>
    2bd8:	88 23       	and	r24, r24
    2bda:	09 f4       	brne	.+2      	; 0x2bde <packetloop_icmp_tcp+0xd0>
    2bdc:	14 c1       	rjmp	.+552    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                                waitgwmac=WGW_HAVE_GW_MAC;
    2bde:	10 93 5e 05 	sts	0x055E, r17
    2be2:	11 c1       	rjmp	.+546    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
#endif // NTP_client||UDP_client||TCP_client||PING_client
                return(0);

        }
        // check if ip packets are for us:
        if(eth_type_is_ip_and_my_ip(buf,plen)==0){
    2be4:	b8 01       	movw	r22, r16
    2be6:	c6 01       	movw	r24, r12
    2be8:	0e 94 12 11 	call	0x2224	; 0x2224 <eth_type_is_ip_and_my_ip>
    2bec:	88 23       	and	r24, r24
    2bee:	09 f4       	brne	.+2      	; 0x2bf2 <packetloop_icmp_tcp+0xe4>
    2bf0:	0a c1       	rjmp	.+532    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                return(0);
        }
        if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V){
    2bf2:	d6 01       	movw	r26, r12
    2bf4:	57 96       	adiw	r26, 0x17	; 23
    2bf6:	8c 91       	ld	r24, X
    2bf8:	57 97       	sbiw	r26, 0x17	; 23
    2bfa:	81 30       	cpi	r24, 0x01	; 1
    2bfc:	99 f4       	brne	.+38     	; 0x2c24 <packetloop_icmp_tcp+0x116>
    2bfe:	92 96       	adiw	r26, 0x22	; 34
    2c00:	8c 91       	ld	r24, X
    2c02:	88 30       	cpi	r24, 0x08	; 8
    2c04:	09 f0       	breq	.+2      	; 0x2c08 <packetloop_icmp_tcp+0xfa>
    2c06:	04 c1       	rjmp	.+520    	; 0x2e10 <packetloop_icmp_tcp+0x302>
                if (icmp_callback){
    2c08:	e0 91 65 05 	lds	r30, 0x0565
    2c0c:	f0 91 66 05 	lds	r31, 0x0566
    2c10:	30 97       	sbiw	r30, 0x00	; 0
    2c12:	19 f0       	breq	.+6      	; 0x2c1a <packetloop_icmp_tcp+0x10c>
                        (*icmp_callback)(&(buf[IP_SRC_P]));
    2c14:	c6 01       	movw	r24, r12
    2c16:	4a 96       	adiw	r24, 0x1a	; 26
    2c18:	09 95       	icall
                }
                // a ping packet, let's send pong
                make_echo_reply_from_request(buf,plen);
    2c1a:	b8 01       	movw	r22, r16
    2c1c:	c6 01       	movw	r24, r12
    2c1e:	0e 94 c7 11 	call	0x238e	; 0x238e <make_echo_reply_from_request>
    2c22:	f1 c0       	rjmp	.+482    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                return(0);
        }
        if (plen<54 && buf[IP_PROTO_P]!=IP_PROTO_TCP_V ){
    2c24:	06 33       	cpi	r16, 0x36	; 54
    2c26:	11 05       	cpc	r17, r1
    2c28:	18 f4       	brcc	.+6      	; 0x2c30 <packetloop_icmp_tcp+0x122>
    2c2a:	86 30       	cpi	r24, 0x06	; 6
    2c2c:	09 f0       	breq	.+2      	; 0x2c30 <packetloop_icmp_tcp+0x122>
    2c2e:	eb c0       	rjmp	.+470    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                // smaller than the smallest TCP packet and not tcp port
                return(0);
        }
#if defined (TCP_client)
        // a message for the tcp client, tcp_client_state is zero if client was never used
        if ( buf[TCP_DST_PORT_H_P]==TCPCLIENT_SRC_PORT_H){
    2c30:	f6 01       	movw	r30, r12
    2c32:	84 a1       	ldd	r24, Z+36	; 0x24
    2c34:	8b 30       	cpi	r24, 0x0B	; 11
    2c36:	09 f0       	breq	.+2      	; 0x2c3a <packetloop_icmp_tcp+0x12c>
    2c38:	b3 c0       	rjmp	.+358    	; 0x2da0 <packetloop_icmp_tcp+0x292>
#if defined (WWW_client)
                // workaround to pass pointer to www_client_internal..
                bufptr=buf; 
    2c3a:	d0 92 68 05 	sts	0x0568, r13
    2c3e:	c0 92 67 05 	sts	0x0567, r12
#endif // WWW_client
                if (check_ip_message_is_from(buf,tcpsrvip)==0){
    2c42:	6e e7       	ldi	r22, 0x7E	; 126
    2c44:	75 e0       	ldi	r23, 0x05	; 5
    2c46:	c6 01       	movw	r24, r12
    2c48:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <check_ip_message_is_from>
    2c4c:	88 23       	and	r24, r24
    2c4e:	09 f4       	brne	.+2      	; 0x2c52 <packetloop_icmp_tcp+0x144>
    2c50:	da c0       	rjmp	.+436    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        return(0);
                }
                // if we get a reset:
                if (buf[TCP_FLAGS_P] & TCP_FLAGS_RST_V){
    2c52:	d6 01       	movw	r26, r12
    2c54:	9f 96       	adiw	r26, 0x2f	; 47
    2c56:	2c 91       	ld	r18, X
    2c58:	9f 97       	sbiw	r26, 0x2f	; 47
    2c5a:	22 ff       	sbrs	r18, 2
    2c5c:	13 c0       	rjmp	.+38     	; 0x2c84 <packetloop_icmp_tcp+0x176>
                        if (client_tcp_result_callback){
    2c5e:	e0 91 79 05 	lds	r30, 0x0579
    2c62:	f0 91 7a 05 	lds	r31, 0x057A
    2c66:	30 97       	sbiw	r30, 0x00	; 0
    2c68:	09 f4       	brne	.+2      	; 0x2c6c <packetloop_icmp_tcp+0x15e>
    2c6a:	90 c0       	rjmp	.+288    	; 0x2d8c <packetloop_icmp_tcp+0x27e>
                                // parameters in client_tcp_result_callback: fd, status, buf_start, len
                                (*client_tcp_result_callback)((buf[TCP_DST_PORT_L_P]>>5)&0x7,3,0,0);
    2c6c:	95 96       	adiw	r26, 0x25	; 37
    2c6e:	8c 91       	ld	r24, X
    2c70:	20 e0       	ldi	r18, 0x00	; 0
    2c72:	30 e0       	ldi	r19, 0x00	; 0
    2c74:	40 e0       	ldi	r20, 0x00	; 0
    2c76:	50 e0       	ldi	r21, 0x00	; 0
    2c78:	63 e0       	ldi	r22, 0x03	; 3
    2c7a:	82 95       	swap	r24
    2c7c:	86 95       	lsr	r24
    2c7e:	87 70       	andi	r24, 0x07	; 7
    2c80:	09 95       	icall
    2c82:	84 c0       	rjmp	.+264    	; 0x2d8c <packetloop_icmp_tcp+0x27e>
                        }
                        tcp_client_state=5;
                        return(0);
                }
                len=get_tcp_data_len(buf);
    2c84:	c6 01       	movw	r24, r12
    2c86:	29 83       	std	Y+1, r18	; 0x01
    2c88:	0e 94 1b 12 	call	0x2436	; 0x2436 <get_tcp_data_len>
    2c8c:	7c 01       	movw	r14, r24
                if (tcp_client_state==2){
    2c8e:	80 91 7d 05 	lds	r24, 0x057D
    2c92:	29 81       	ldd	r18, Y+1	; 0x01
    2c94:	82 30       	cpi	r24, 0x02	; 2
    2c96:	99 f5       	brne	.+102    	; 0x2cfe <packetloop_icmp_tcp+0x1f0>
                        if ((buf[TCP_FLAGS_P] & TCP_FLAGS_SYN_V) && (buf[TCP_FLAGS_P] &TCP_FLAGS_ACK_V)){
    2c98:	82 2f       	mov	r24, r18
    2c9a:	80 71       	andi	r24, 0x10	; 16
    2c9c:	22 71       	andi	r18, 0x12	; 18
    2c9e:	22 31       	cpi	r18, 0x12	; 18
    2ca0:	09 f5       	brne	.+66     	; 0x2ce4 <packetloop_icmp_tcp+0x1d6>
                                // synack, answer with ack
                                make_tcp_ack_from_any(buf,0,0);
    2ca2:	40 e0       	ldi	r20, 0x00	; 0
    2ca4:	60 e0       	ldi	r22, 0x00	; 0
    2ca6:	70 e0       	ldi	r23, 0x00	; 0
    2ca8:	c6 01       	movw	r24, r12
    2caa:	0e 94 1d 13 	call	0x263a	; 0x263a <make_tcp_ack_from_any>
                                buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V;
    2cae:	88 e1       	ldi	r24, 0x18	; 24
    2cb0:	f6 01       	movw	r30, r12
    2cb2:	87 a7       	std	Z+47, r24	; 0x2f

                                // Make a tcp message with data. When calling this function we must
                                // still have a valid tcp-ack in the buffer. In other words
                                // you have just called make_tcp_ack_from_any(buf,0).
                                if (client_tcp_datafill_callback){
    2cb4:	e0 91 77 05 	lds	r30, 0x0577
    2cb8:	f0 91 78 05 	lds	r31, 0x0578
    2cbc:	30 97       	sbiw	r30, 0x00	; 0
    2cbe:	41 f0       	breq	.+16     	; 0x2cd0 <packetloop_icmp_tcp+0x1c2>
                                        // in this case it is src port because the above 
                                        // make_tcp_ack_from_any swaps the dst and src port:
                                        len=(*client_tcp_datafill_callback)((buf[TCP_SRC_PORT_L_P]>>5)&0x7);
    2cc0:	d6 01       	movw	r26, r12
    2cc2:	93 96       	adiw	r26, 0x23	; 35
    2cc4:	8c 91       	ld	r24, X
    2cc6:	82 95       	swap	r24
    2cc8:	86 95       	lsr	r24
    2cca:	87 70       	andi	r24, 0x07	; 7
    2ccc:	09 95       	icall
    2cce:	02 c0       	rjmp	.+4      	; 0x2cd4 <packetloop_icmp_tcp+0x1c6>
                                }else{
                                        // this is just to prevent a crash
                                        len=0;
    2cd0:	80 e0       	ldi	r24, 0x00	; 0
    2cd2:	90 e0       	ldi	r25, 0x00	; 0
                                }
                                tcp_client_state=3;
    2cd4:	23 e0       	ldi	r18, 0x03	; 3
    2cd6:	20 93 7d 05 	sts	0x057D, r18
                                make_tcp_ack_with_data_noflags(buf,len);
    2cda:	bc 01       	movw	r22, r24
    2cdc:	c6 01       	movw	r24, r12
    2cde:	0e 94 5e 13 	call	0x26bc	; 0x26bc <make_tcp_ack_with_data_noflags>
    2ce2:	91 c0       	rjmp	.+290    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        }else{
                                // reset only if we have sent a syn and don't get syn-ack back.
                                // If we connect to a non listen port then we get a RST
                                // which will be handeled above. In other words there is
                                // normally no danger for an endless loop.
                                tcp_client_state=1; // retry
    2ce4:	91 e0       	ldi	r25, 0x01	; 1
    2ce6:	90 93 7d 05 	sts	0x057D, r25
                                // do not inform application layer as we retry.
                                len++;
                                if (buf[TCP_FLAGS_P] & TCP_FLAGS_ACK_V){
    2cea:	81 11       	cpse	r24, r1
    2cec:	04 c0       	rjmp	.+8      	; 0x2cf6 <packetloop_icmp_tcp+0x1e8>
                                // If we connect to a non listen port then we get a RST
                                // which will be handeled above. In other words there is
                                // normally no danger for an endless loop.
                                tcp_client_state=1; // retry
                                // do not inform application layer as we retry.
                                len++;
    2cee:	b7 01       	movw	r22, r14
    2cf0:	6f 5f       	subi	r22, 0xFF	; 255
    2cf2:	7f 4f       	sbci	r23, 0xFF	; 255
    2cf4:	02 c0       	rjmp	.+4      	; 0x2cfa <packetloop_icmp_tcp+0x1ec>
                                if (buf[TCP_FLAGS_P] & TCP_FLAGS_ACK_V){
                                        // if packet was an ack then do not step the ack number
                                        len=0;
    2cf6:	60 e0       	ldi	r22, 0x00	; 0
    2cf8:	70 e0       	ldi	r23, 0x00	; 0
                                }
                                // refuse and reset the connection
                                make_tcp_ack_from_any(buf,len,TCP_FLAGS_RST_V);
    2cfa:	44 e0       	ldi	r20, 0x04	; 4
    2cfc:	71 c0       	rjmp	.+226    	; 0x2de0 <packetloop_icmp_tcp+0x2d2>
                                return(0);
                        }
                }
                // in tcp_client_state==3 we will normally first get an empty
                // ack-packet and then a ack-packet with data.
                if (tcp_client_state==3 && len>0){ 
    2cfe:	83 30       	cpi	r24, 0x03	; 3
    2d00:	a9 f5       	brne	.+106    	; 0x2d6c <packetloop_icmp_tcp+0x25e>
    2d02:	e1 14       	cp	r14, r1
    2d04:	f1 04       	cpc	r15, r1
    2d06:	91 f1       	breq	.+100    	; 0x2d6c <packetloop_icmp_tcp+0x25e>
                        // our first real data packet
                        tcp_client_state=4;
    2d08:	84 e0       	ldi	r24, 0x04	; 4
    2d0a:	80 93 7d 05 	sts	0x057D, r24
                        // return the data we received
                        if (client_tcp_result_callback){
    2d0e:	e0 91 79 05 	lds	r30, 0x0579
    2d12:	f0 91 7a 05 	lds	r31, 0x057A
    2d16:	30 97       	sbiw	r30, 0x00	; 0
    2d18:	49 f1       	breq	.+82     	; 0x2d6c <packetloop_icmp_tcp+0x25e>
                                tcpstart=TCP_DATA_START; // TCP_DATA_START is a formula
    2d1a:	d6 01       	movw	r26, r12
    2d1c:	9e 96       	adiw	r26, 0x2e	; 46
    2d1e:	4c 91       	ld	r20, X
    2d20:	42 95       	swap	r20
    2d22:	4f 70       	andi	r20, 0x0F	; 15
    2d24:	b4 e0       	ldi	r27, 0x04	; 4
    2d26:	4b 9f       	mul	r20, r27
    2d28:	a0 01       	movw	r20, r0
    2d2a:	11 24       	eor	r1, r1
                                // out of buffer bounds check, needed in case of fragmented IP packets
                                if (tcpstart>plen-8){
    2d2c:	c8 01       	movw	r24, r16
    2d2e:	08 97       	sbiw	r24, 0x08	; 8
    2d30:	4e 5d       	subi	r20, 0xDE	; 222
    2d32:	5f 4f       	sbci	r21, 0xFF	; 255
    2d34:	84 17       	cp	r24, r20
    2d36:	95 07       	cpc	r25, r21
    2d38:	08 f4       	brcc	.+2      	; 0x2d3c <packetloop_icmp_tcp+0x22e>
    2d3a:	ac 01       	movw	r20, r24
                                        tcpstart=plen-8; // dummy but save
                                }
                                save_len=len;
                                if (tcpstart+len>plen){
    2d3c:	c7 01       	movw	r24, r14
    2d3e:	84 0f       	add	r24, r20
    2d40:	95 1f       	adc	r25, r21
    2d42:	08 17       	cp	r16, r24
    2d44:	19 07       	cpc	r17, r25
    2d46:	20 f4       	brcc	.+8      	; 0x2d50 <packetloop_icmp_tcp+0x242>
                                        save_len=plen-tcpstart;
    2d48:	98 01       	movw	r18, r16
    2d4a:	24 1b       	sub	r18, r20
    2d4c:	35 0b       	sbc	r19, r21
    2d4e:	01 c0       	rjmp	.+2      	; 0x2d52 <packetloop_icmp_tcp+0x244>
    2d50:	97 01       	movw	r18, r14
                                }
                                send_fin=(*client_tcp_result_callback)((buf[TCP_DST_PORT_L_P]>>5)&0x7,0,tcpstart,save_len);
    2d52:	d6 01       	movw	r26, r12
    2d54:	95 96       	adiw	r26, 0x25	; 37
    2d56:	8c 91       	ld	r24, X
    2d58:	60 e0       	ldi	r22, 0x00	; 0
    2d5a:	82 95       	swap	r24
    2d5c:	86 95       	lsr	r24
    2d5e:	87 70       	andi	r24, 0x07	; 7
    2d60:	09 95       	icall
                        }
                        if (send_fin){
    2d62:	88 23       	and	r24, r24
    2d64:	19 f0       	breq	.+6      	; 0x2d6c <packetloop_icmp_tcp+0x25e>
                                make_tcp_ack_from_any(buf,len,TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V);
    2d66:	49 e0       	ldi	r20, 0x09	; 9
    2d68:	b7 01       	movw	r22, r14
    2d6a:	0d c0       	rjmp	.+26     	; 0x2d86 <packetloop_icmp_tcp+0x278>
                                tcp_client_state=5;
                                return(0);
                        }
                }
                if(tcp_client_state==5){
    2d6c:	80 91 7d 05 	lds	r24, 0x057D
    2d70:	85 30       	cpi	r24, 0x05	; 5
    2d72:	09 f4       	brne	.+2      	; 0x2d76 <packetloop_icmp_tcp+0x268>
    2d74:	48 c0       	rjmp	.+144    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        // no more ack
                        return(0);
                }
                if (buf[TCP_FLAGS_P] & TCP_FLAGS_FIN_V){
    2d76:	f6 01       	movw	r30, r12
    2d78:	87 a5       	ldd	r24, Z+47	; 0x2f
    2d7a:	80 ff       	sbrs	r24, 0
    2d7c:	0b c0       	rjmp	.+22     	; 0x2d94 <packetloop_icmp_tcp+0x286>
                        make_tcp_ack_from_any(buf,len+1,TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V);
    2d7e:	b7 01       	movw	r22, r14
    2d80:	6f 5f       	subi	r22, 0xFF	; 255
    2d82:	7f 4f       	sbci	r23, 0xFF	; 255
    2d84:	49 e0       	ldi	r20, 0x09	; 9
    2d86:	c6 01       	movw	r24, r12
    2d88:	0e 94 1d 13 	call	0x263a	; 0x263a <make_tcp_ack_from_any>
                        tcp_client_state=5; // connection terminated
    2d8c:	85 e0       	ldi	r24, 0x05	; 5
    2d8e:	80 93 7d 05 	sts	0x057D, r24
    2d92:	39 c0       	rjmp	.+114    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        return(0);
                }
                // ack all data (the web page may be long):
                // if we just get a fragment then len will be zero
                // and we ack only once we have the full packet
                if (len>0){
    2d94:	e1 14       	cp	r14, r1
    2d96:	f1 04       	cpc	r15, r1
    2d98:	b1 f1       	breq	.+108    	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        make_tcp_ack_from_any(buf,len,0);
    2d9a:	40 e0       	ldi	r20, 0x00	; 0
    2d9c:	b7 01       	movw	r22, r14
    2d9e:	20 c0       	rjmp	.+64     	; 0x2de0 <packetloop_icmp_tcp+0x2d2>
                return(0);
        }
#endif // WWW_client||TCP_client
        //
        // tcp port web server start
        if (buf[TCP_DST_PORT_H_P]==wwwport_h && buf[TCP_DST_PORT_L_P]==wwwport_l){
    2da0:	90 91 83 05 	lds	r25, 0x0583
    2da4:	89 13       	cpse	r24, r25
    2da6:	2f c0       	rjmp	.+94     	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
    2da8:	95 a1       	ldd	r25, Z+37	; 0x25
    2daa:	80 91 04 01 	lds	r24, 0x0104
    2dae:	98 13       	cpse	r25, r24
    2db0:	2a c0       	rjmp	.+84     	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                if (buf[TCP_FLAGS_P] & TCP_FLAGS_SYN_V){
    2db2:	f7 a4       	ldd	r15, Z+47	; 0x2f
    2db4:	f1 fe       	sbrs	r15, 1
    2db6:	04 c0       	rjmp	.+8      	; 0x2dc0 <packetloop_icmp_tcp+0x2b2>
                        make_tcp_synack_from_syn(buf);
    2db8:	c6 01       	movw	r24, r12
    2dba:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <make_tcp_synack_from_syn>
    2dbe:	23 c0       	rjmp	.+70     	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        // make_tcp_synack_from_syn does already send the syn,ack
                        return(0);
                }
                if (buf[TCP_FLAGS_P] & TCP_FLAGS_ACK_V){
    2dc0:	f4 fe       	sbrs	r15, 4
    2dc2:	21 c0       	rjmp	.+66     	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                        info_data_len=get_tcp_data_len(buf);
    2dc4:	c6 01       	movw	r24, r12
    2dc6:	0e 94 1b 12 	call	0x2436	; 0x2436 <get_tcp_data_len>
    2dca:	90 93 53 05 	sts	0x0553, r25
    2dce:	80 93 52 05 	sts	0x0552, r24
                        // we can possibly have no data, just ack:
                        // Here we misuse plen for something else to save a variable.
                        // plen is now the position of start of the tcp user data.
                        if (info_data_len==0){
    2dd2:	89 2b       	or	r24, r25
    2dd4:	49 f4       	brne	.+18     	; 0x2de8 <packetloop_icmp_tcp+0x2da>
                                if (buf[TCP_FLAGS_P] & TCP_FLAGS_FIN_V){
    2dd6:	f0 fe       	sbrs	r15, 0
    2dd8:	16 c0       	rjmp	.+44     	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                                        // finack, answer with ack
                                        make_tcp_ack_from_any(buf,0,0);
    2dda:	40 e0       	ldi	r20, 0x00	; 0
    2ddc:	60 e0       	ldi	r22, 0x00	; 0
    2dde:	70 e0       	ldi	r23, 0x00	; 0
    2de0:	c6 01       	movw	r24, r12
    2de2:	0e 94 1d 13 	call	0x263a	; 0x263a <make_tcp_ack_from_any>
    2de6:	0f c0       	rjmp	.+30     	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
                                }
                                // just an ack with no data, wait for next packet
                                return(0);
                        }
                        // Here we misuse len for something else to save a variable
                        len=TCP_DATA_START; // TCP_DATA_START is a formula
    2de8:	f6 01       	movw	r30, r12
    2dea:	26 a5       	ldd	r18, Z+46	; 0x2e
    2dec:	22 95       	swap	r18
    2dee:	2f 70       	andi	r18, 0x0F	; 15
    2df0:	f4 e0       	ldi	r31, 0x04	; 4
    2df2:	2f 9f       	mul	r18, r31
    2df4:	90 01       	movw	r18, r0
    2df6:	11 24       	eor	r1, r1
    2df8:	2e 5d       	subi	r18, 0xDE	; 222
    2dfa:	3f 4f       	sbci	r19, 0xFF	; 255
                        // check for data corruption
                        if (len>plen-8){
    2dfc:	08 50       	subi	r16, 0x08	; 8
    2dfe:	11 09       	sbc	r17, r1
    2e00:	02 17       	cp	r16, r18
    2e02:	13 07       	cpc	r17, r19
    2e04:	18 f4       	brcc	.+6      	; 0x2e0c <packetloop_icmp_tcp+0x2fe>
                                return(0);
    2e06:	80 e0       	ldi	r24, 0x00	; 0
    2e08:	90 e0       	ldi	r25, 0x00	; 0
    2e0a:	06 c0       	rjmp	.+12     	; 0x2e18 <packetloop_icmp_tcp+0x30a>
    2e0c:	c9 01       	movw	r24, r18
    2e0e:	04 c0       	rjmp	.+8      	; 0x2e18 <packetloop_icmp_tcp+0x30a>
                }
                // a ping packet, let's send pong
                make_echo_reply_from_request(buf,plen);
                return(0);
        }
        if (plen<54 && buf[IP_PROTO_P]!=IP_PROTO_TCP_V ){
    2e10:	06 33       	cpi	r16, 0x36	; 54
    2e12:	11 05       	cpc	r17, r1
    2e14:	c0 f3       	brcs	.-16     	; 0x2e06 <packetloop_icmp_tcp+0x2f8>
    2e16:	0c cf       	rjmp	.-488    	; 0x2c30 <packetloop_icmp_tcp+0x122>
                        }
                        return(len);
                }
        }
        return(0);
}
    2e18:	0f 90       	pop	r0
    2e1a:	df 91       	pop	r29
    2e1c:	cf 91       	pop	r28
    2e1e:	1f 91       	pop	r17
    2e20:	0f 91       	pop	r16
    2e22:	ff 90       	pop	r15
    2e24:	ef 90       	pop	r14
    2e26:	df 90       	pop	r13
    2e28:	cf 90       	pop	r12
    2e2a:	08 95       	ret

00002e2c <mywdt_sleep>:
	wdt_reset();
}

static void mywdt_sleep(uint16_t ms)
{
	while (ms > 100)
    2e2c:	85 36       	cpi	r24, 0x65	; 101
    2e2e:	91 05       	cpc	r25, r1
    2e30:	68 f0       	brcs	.+26     	; 0x2e4c <mywdt_sleep+0x20>
	{
		ms -= 100;
    2e32:	84 56       	subi	r24, 0x64	; 100
    2e34:	91 09       	sbc	r25, r1
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    2e36:	a8 95       	wdr
    2e38:	2f ef       	ldi	r18, 0xFF	; 255
    2e3a:	30 e7       	ldi	r19, 0x70	; 112
    2e3c:	42 e0       	ldi	r20, 0x02	; 2
    2e3e:	21 50       	subi	r18, 0x01	; 1
    2e40:	30 40       	sbci	r19, 0x00	; 0
    2e42:	40 40       	sbci	r20, 0x00	; 0
    2e44:	e1 f7       	brne	.-8      	; 0x2e3e <mywdt_sleep+0x12>
    2e46:	00 c0       	rjmp	.+0      	; 0x2e48 <mywdt_sleep+0x1c>
    2e48:	00 00       	nop
    2e4a:	f0 cf       	rjmp	.-32     	; 0x2e2c <mywdt_sleep>
	{
		ms -= 100;
		mywdt_reset();
		_delay_ms(100);
	}
	while (ms > 0)
    2e4c:	00 97       	sbiw	r24, 0x00	; 0
    2e4e:	41 f0       	breq	.+16     	; 0x2e60 <mywdt_sleep+0x34>
    2e50:	ef ec       	ldi	r30, 0xCF	; 207
    2e52:	f7 e0       	ldi	r31, 0x07	; 7
    2e54:	31 97       	sbiw	r30, 0x01	; 1
    2e56:	f1 f7       	brne	.-4      	; 0x2e54 <mywdt_sleep+0x28>
    2e58:	00 c0       	rjmp	.+0      	; 0x2e5a <mywdt_sleep+0x2e>
    2e5a:	00 00       	nop
	{
		_delay_ms(1);
		ms--;
    2e5c:	01 97       	sbiw	r24, 0x01	; 1
    2e5e:	f6 cf       	rjmp	.-20     	; 0x2e4c <mywdt_sleep+0x20>
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    2e60:	a8 95       	wdr
    2e62:	08 95       	ret

00002e64 <read_ip_addresses>:
	mywdt_reset();
}

void read_ip_addresses(void)
{
	myip[0] = eepromReadByte(11);
    2e64:	8b e0       	ldi	r24, 0x0B	; 11
    2e66:	90 e0       	ldi	r25, 0x00	; 0
    2e68:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2e6c:	80 93 1f 01 	sts	0x011F, r24
	myip[1] = eepromReadByte(12);
    2e70:	8c e0       	ldi	r24, 0x0C	; 12
    2e72:	90 e0       	ldi	r25, 0x00	; 0
    2e74:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2e78:	80 93 20 01 	sts	0x0120, r24
	myip[2] = eepromReadByte(13);
    2e7c:	8d e0       	ldi	r24, 0x0D	; 13
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2e84:	80 93 21 01 	sts	0x0121, r24
	myip[3] = eepromReadByte(14);
    2e88:	8e e0       	ldi	r24, 0x0E	; 14
    2e8a:	90 e0       	ldi	r25, 0x00	; 0
    2e8c:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2e90:	80 93 22 01 	sts	0x0122, r24

	gwip[0] = eepromReadByte(15);
    2e94:	8f e0       	ldi	r24, 0x0F	; 15
    2e96:	90 e0       	ldi	r25, 0x00	; 0
    2e98:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2e9c:	80 93 23 01 	sts	0x0123, r24
	gwip[1] = eepromReadByte(16);
    2ea0:	80 e1       	ldi	r24, 0x10	; 16
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
    2ea4:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2ea8:	80 93 24 01 	sts	0x0124, r24
	gwip[2] = eepromReadByte(17);
    2eac:	81 e1       	ldi	r24, 0x11	; 17
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2eb4:	80 93 25 01 	sts	0x0125, r24
	gwip[3] = eepromReadByte(18);
    2eb8:	82 e1       	ldi	r24, 0x12	; 18
    2eba:	90 e0       	ldi	r25, 0x00	; 0
    2ebc:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2ec0:	80 93 26 01 	sts	0x0126, r24

	netmask[0] = eepromReadByte(19);
    2ec4:	83 e1       	ldi	r24, 0x13	; 19
    2ec6:	90 e0       	ldi	r25, 0x00	; 0
    2ec8:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2ecc:	80 93 17 01 	sts	0x0117, r24
	netmask[1] = eepromReadByte(20);
    2ed0:	84 e1       	ldi	r24, 0x14	; 20
    2ed2:	90 e0       	ldi	r25, 0x00	; 0
    2ed4:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2ed8:	80 93 18 01 	sts	0x0118, r24
	netmask[2] = eepromReadByte(21);
    2edc:	85 e1       	ldi	r24, 0x15	; 21
    2ede:	90 e0       	ldi	r25, 0x00	; 0
    2ee0:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2ee4:	80 93 19 01 	sts	0x0119, r24
	netmask[3] = eepromReadByte(22);
    2ee8:	86 e1       	ldi	r24, 0x16	; 22
    2eea:	90 e0       	ldi	r25, 0x00	; 0
    2eec:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2ef0:	80 93 1a 01 	sts	0x011A, r24

	dnsip[0] = eepromReadByte(31);
    2ef4:	8f e1       	ldi	r24, 0x1F	; 31
    2ef6:	90 e0       	ldi	r25, 0x00	; 0
    2ef8:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2efc:	80 93 13 01 	sts	0x0113, r24
	dnsip[1] = eepromReadByte(32);
    2f00:	80 e2       	ldi	r24, 0x20	; 32
    2f02:	90 e0       	ldi	r25, 0x00	; 0
    2f04:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2f08:	80 93 14 01 	sts	0x0114, r24
	dnsip[2] = eepromReadByte(33);
    2f0c:	81 e2       	ldi	r24, 0x21	; 33
    2f0e:	90 e0       	ldi	r25, 0x00	; 0
    2f10:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2f14:	80 93 15 01 	sts	0x0115, r24
	dnsip[3] = eepromReadByte(34);
    2f18:	82 e2       	ldi	r24, 0x22	; 34
    2f1a:	90 e0       	ldi	r25, 0x00	; 0
    2f1c:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    2f20:	80 93 16 01 	sts	0x0116, r24
    2f24:	08 95       	ret

00002f26 <save_ip_addresses>:
}


void save_ip_addresses(void)
{
	eepromWriteByte(11, myip[0]);
    2f26:	60 91 1f 01 	lds	r22, 0x011F
    2f2a:	8b e0       	ldi	r24, 0x0B	; 11
    2f2c:	90 e0       	ldi	r25, 0x00	; 0
    2f2e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(12, myip[1]);
    2f32:	60 91 20 01 	lds	r22, 0x0120
    2f36:	8c e0       	ldi	r24, 0x0C	; 12
    2f38:	90 e0       	ldi	r25, 0x00	; 0
    2f3a:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(13, myip[2]);
    2f3e:	60 91 21 01 	lds	r22, 0x0121
    2f42:	8d e0       	ldi	r24, 0x0D	; 13
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(14, myip[3]);
    2f4a:	60 91 22 01 	lds	r22, 0x0122
    2f4e:	8e e0       	ldi	r24, 0x0E	; 14
    2f50:	90 e0       	ldi	r25, 0x00	; 0
    2f52:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>

	eepromWriteByte(15, gwip[0]);
    2f56:	60 91 23 01 	lds	r22, 0x0123
    2f5a:	8f e0       	ldi	r24, 0x0F	; 15
    2f5c:	90 e0       	ldi	r25, 0x00	; 0
    2f5e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(16, gwip[1]);
    2f62:	60 91 24 01 	lds	r22, 0x0124
    2f66:	80 e1       	ldi	r24, 0x10	; 16
    2f68:	90 e0       	ldi	r25, 0x00	; 0
    2f6a:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(17, gwip[2]);
    2f6e:	60 91 25 01 	lds	r22, 0x0125
    2f72:	81 e1       	ldi	r24, 0x11	; 17
    2f74:	90 e0       	ldi	r25, 0x00	; 0
    2f76:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(18, gwip[3]);
    2f7a:	60 91 26 01 	lds	r22, 0x0126
    2f7e:	82 e1       	ldi	r24, 0x12	; 18
    2f80:	90 e0       	ldi	r25, 0x00	; 0
    2f82:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>

	eepromWriteByte(19, netmask[0]);
    2f86:	60 91 17 01 	lds	r22, 0x0117
    2f8a:	83 e1       	ldi	r24, 0x13	; 19
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(20, netmask[1]);
    2f92:	60 91 18 01 	lds	r22, 0x0118
    2f96:	84 e1       	ldi	r24, 0x14	; 20
    2f98:	90 e0       	ldi	r25, 0x00	; 0
    2f9a:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(21, netmask[2]);
    2f9e:	60 91 19 01 	lds	r22, 0x0119
    2fa2:	85 e1       	ldi	r24, 0x15	; 21
    2fa4:	90 e0       	ldi	r25, 0x00	; 0
    2fa6:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(22, netmask[3]);
    2faa:	60 91 1a 01 	lds	r22, 0x011A
    2fae:	86 e1       	ldi	r24, 0x16	; 22
    2fb0:	90 e0       	ldi	r25, 0x00	; 0
    2fb2:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>

	eepromWriteByte(31, dnsip[0]);
    2fb6:	60 91 13 01 	lds	r22, 0x0113
    2fba:	8f e1       	ldi	r24, 0x1F	; 31
    2fbc:	90 e0       	ldi	r25, 0x00	; 0
    2fbe:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(32, dnsip[1]);
    2fc2:	60 91 14 01 	lds	r22, 0x0114
    2fc6:	80 e2       	ldi	r24, 0x20	; 32
    2fc8:	90 e0       	ldi	r25, 0x00	; 0
    2fca:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(33, dnsip[2]);
    2fce:	60 91 15 01 	lds	r22, 0x0115
    2fd2:	81 e2       	ldi	r24, 0x21	; 33
    2fd4:	90 e0       	ldi	r25, 0x00	; 0
    2fd6:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	eepromWriteByte(34, dnsip[3]);
    2fda:	60 91 16 01 	lds	r22, 0x0116
    2fde:	82 e2       	ldi	r24, 0x22	; 34
    2fe0:	90 e0       	ldi	r25, 0x00	; 0
    2fe2:	0c 94 1c 21 	jmp	0x4238	; 0x4238 <eepromSaveByte>

00002fe6 <loadSimpleSensorData>:
}

void loadSimpleSensorData()    
{
    2fe6:	af 92       	push	r10
    2fe8:	bf 92       	push	r11
    2fea:	cf 92       	push	r12
    2fec:	df 92       	push	r13
    2fee:	ef 92       	push	r14
    2ff0:	ff 92       	push	r15
    2ff2:	0f 93       	push	r16
    2ff4:	1f 93       	push	r17
    2ff6:	cf 93       	push	r28
    2ff8:	df 93       	push	r29
    2ffa:	e0 e1       	ldi	r30, 0x10	; 16
    2ffc:	f6 e0       	ldi	r31, 0x06	; 6
	for (uint16_t i=0; i<MAXSENSORS*SENSORSIZE; i++)
		sensorValues[i] = 0;
    2ffe:	11 92       	st	Z+, r1
	eepromWriteByte(34, dnsip[3]);
}

void loadSimpleSensorData()    
{
	for (uint16_t i=0; i<MAXSENSORS*SENSORSIZE; i++)
    3000:	28 e0       	ldi	r18, 0x08	; 8
    3002:	e4 3a       	cpi	r30, 0xA4	; 164
    3004:	f2 07       	cpc	r31, r18
    3006:	d9 f7       	brne	.-10     	; 0x2ffe <loadSimpleSensorData+0x18>
    3008:	80 e0       	ldi	r24, 0x00	; 0
    300a:	90 e0       	ldi	r25, 0x00	; 0
		sensorValues[i] = 0;

	for (uint16_t i=0; i<MAXSENSORS*8; i++)
		sensorScan[i] = 0;
    300c:	e0 91 08 09 	lds	r30, 0x0908
    3010:	f0 91 09 09 	lds	r31, 0x0909
    3014:	e8 0f       	add	r30, r24
    3016:	f9 1f       	adc	r31, r25
    3018:	10 82       	st	Z, r1
void loadSimpleSensorData()    
{
	for (uint16_t i=0; i<MAXSENSORS*SENSORSIZE; i++)
		sensorValues[i] = 0;

	for (uint16_t i=0; i<MAXSENSORS*8; i++)
    301a:	01 96       	adiw	r24, 0x01	; 1
    301c:	80 3e       	cpi	r24, 0xE0	; 224
    301e:	e1 e0       	ldi	r30, 0x01	; 1
    3020:	9e 07       	cpc	r25, r30
    3022:	a1 f7       	brne	.-24     	; 0x300c <loadSimpleSensorData+0x26>
    3024:	3c ea       	ldi	r19, 0xAC	; 172
    3026:	c3 2e       	mov	r12, r19
    3028:	35 e0       	ldi	r19, 0x05	; 5
    302a:	d3 2e       	mov	r13, r19
    302c:	44 ea       	ldi	r20, 0xA4	; 164
    302e:	a4 2e       	mov	r10, r20
    3030:	48 e0       	ldi	r20, 0x08	; 8
    3032:	b4 2e       	mov	r11, r20
    3034:	0a e0       	ldi	r16, 0x0A	; 10
    3036:	19 e1       	ldi	r17, 0x19	; 25
    3038:	5c e8       	ldi	r21, 0x8C	; 140
    303a:	e5 2e       	mov	r14, r21
    303c:	f1 2c       	mov	r15, r1
    303e:	c4 e6       	ldi	r28, 0x64	; 100
    3040:	d0 e0       	ldi	r29, 0x00	; 0

	//To load initial type values from eeprom
	for (int i=0; i<=7; i++)
	{
		uint8_t pos = 100+i;
		simpleSensorTypes[i] = eepromReadByte(pos);
    3042:	ce 01       	movw	r24, r28
    3044:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3048:	f6 01       	movw	r30, r12
    304a:	81 93       	st	Z+, r24
    304c:	6f 01       	movw	r12, r30
		simpleSensorDebounce[i] = 0;
    304e:	f5 01       	movw	r30, r10
    3050:	11 92       	st	Z+, r1
    3052:	5f 01       	movw	r10, r30

		if (simpleSensorTypes[i] == 3) //counter
    3054:	83 30       	cpi	r24, 0x03	; 3
    3056:	39 f4       	brne	.+14     	; 0x3066 <loadSimpleSensorData+0x80>
		{
			uint8_t eepos = 140 + (i*2);
			simpleSensorValues[i] = eepromReadWord(eepos);
    3058:	c7 01       	movw	r24, r14
    305a:	0e 94 5d 21 	call	0x42ba	; 0x42ba <eepromReadWord>
    305e:	f8 01       	movw	r30, r16
    3060:	91 83       	std	Z+1, r25	; 0x01
    3062:	80 83       	st	Z, r24
    3064:	03 c0       	rjmp	.+6      	; 0x306c <loadSimpleSensorData+0x86>
		} else {
			simpleSensorValues[i] = 0;
    3066:	f8 01       	movw	r30, r16
    3068:	11 82       	std	Z+1, r1	; 0x01
    306a:	10 82       	st	Z, r1
    306c:	21 96       	adiw	r28, 0x01	; 1
    306e:	f2 e0       	ldi	r31, 0x02	; 2
    3070:	ef 0e       	add	r14, r31
    3072:	f1 1c       	adc	r15, r1
    3074:	0e 5f       	subi	r16, 0xFE	; 254
    3076:	1f 4f       	sbci	r17, 0xFF	; 255

	for (uint16_t i=0; i<MAXSENSORS*8; i++)
		sensorScan[i] = 0;

	//To load initial type values from eeprom
	for (int i=0; i<=7; i++)
    3078:	cc 36       	cpi	r28, 0x6C	; 108
    307a:	d1 05       	cpc	r29, r1
    307c:	11 f7       	brne	.-60     	; 0x3042 <loadSimpleSensorData+0x5c>
    307e:	84 eb       	ldi	r24, 0xB4	; 180
    3080:	a8 2e       	mov	r10, r24
    3082:	85 e0       	ldi	r24, 0x05	; 5
    3084:	b8 2e       	mov	r11, r24
    3086:	9c ea       	ldi	r25, 0xAC	; 172
    3088:	c9 2e       	mov	r12, r25
    308a:	98 e0       	ldi	r25, 0x08	; 8
    308c:	d9 2e       	mov	r13, r25
    308e:	0a e1       	ldi	r16, 0x1A	; 26
    3090:	19 e1       	ldi	r17, 0x19	; 25
    3092:	20 ea       	ldi	r18, 0xA0	; 160
    3094:	e2 2e       	mov	r14, r18
    3096:	f1 2c       	mov	r15, r1
    3098:	ce e6       	ldi	r28, 0x6E	; 110
    309a:	d0 e0       	ldi	r29, 0x00	; 0

	//To load initial type values from eeprom
	for (int i=0; i<=3; i++)
	{
		uint8_t pos = 110+i;
		simpleSensorTypes[i+8] = eepromReadByte(pos);
    309c:	ce 01       	movw	r24, r28
    309e:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    30a2:	f5 01       	movw	r30, r10
    30a4:	81 93       	st	Z+, r24
    30a6:	5f 01       	movw	r10, r30
		simpleSensorDebounce[i+8] = 0;
    30a8:	f6 01       	movw	r30, r12
    30aa:	11 92       	st	Z+, r1
    30ac:	6f 01       	movw	r12, r30

		if (simpleSensorTypes[i+8] == 3) //counter
    30ae:	83 30       	cpi	r24, 0x03	; 3
    30b0:	39 f4       	brne	.+14     	; 0x30c0 <loadSimpleSensorData+0xda>
		{
			uint8_t eepos = 160 + (i*2);
			simpleSensorValues[i+8] = eepromReadWord(eepos);
    30b2:	c7 01       	movw	r24, r14
    30b4:	0e 94 5d 21 	call	0x42ba	; 0x42ba <eepromReadWord>
    30b8:	f8 01       	movw	r30, r16
    30ba:	91 83       	std	Z+1, r25	; 0x01
    30bc:	80 83       	st	Z, r24
    30be:	03 c0       	rjmp	.+6      	; 0x30c6 <loadSimpleSensorData+0xe0>
		} else {
			simpleSensorValues[i+8] = 0;
    30c0:	f8 01       	movw	r30, r16
    30c2:	11 82       	std	Z+1, r1	; 0x01
    30c4:	10 82       	st	Z, r1
    30c6:	21 96       	adiw	r28, 0x01	; 1
    30c8:	f2 e0       	ldi	r31, 0x02	; 2
    30ca:	ef 0e       	add	r14, r31
    30cc:	f1 1c       	adc	r15, r1
    30ce:	0e 5f       	subi	r16, 0xFE	; 254
    30d0:	1f 4f       	sbci	r17, 0xFF	; 255
			simpleSensorValues[i] = 0;
		}
	}

	//To load initial type values from eeprom
	for (int i=0; i<=3; i++)
    30d2:	c2 37       	cpi	r28, 0x72	; 114
    30d4:	d1 05       	cpc	r29, r1
    30d6:	11 f7       	brne	.-60     	; 0x309c <loadSimpleSensorData+0xb6>
			simpleSensorValues[i+8] = eepromReadWord(eepos);
		} else {
			simpleSensorValues[i+8] = 0;
		}
	}
}
    30d8:	df 91       	pop	r29
    30da:	cf 91       	pop	r28
    30dc:	1f 91       	pop	r17
    30de:	0f 91       	pop	r16
    30e0:	ff 90       	pop	r15
    30e2:	ef 90       	pop	r14
    30e4:	df 90       	pop	r13
    30e6:	cf 90       	pop	r12
    30e8:	bf 90       	pop	r11
    30ea:	af 90       	pop	r10
    30ec:	08 95       	ret

000030ee <getDHTData>:
        }
        return (0);
}

void getDHTData()
{
    30ee:	af 92       	push	r10
    30f0:	bf 92       	push	r11
    30f2:	cf 92       	push	r12
    30f4:	df 92       	push	r13
    30f6:	ef 92       	push	r14
    30f8:	ff 92       	push	r15
    30fa:	0f 93       	push	r16
    30fc:	1f 93       	push	r17
    30fe:	cf 93       	push	r28
    3100:	df 93       	push	r29
    3102:	00 d0       	rcall	.+0      	; 0x3104 <getDHTData+0x16>
    3104:	00 d0       	rcall	.+0      	; 0x3106 <getDHTData+0x18>
    3106:	cd b7       	in	r28, 0x3d	; 61
    3108:	de b7       	in	r29, 0x3e	; 62
	printf("Reading dht ... \r\n");
    310a:	87 e4       	ldi	r24, 0x47	; 71
    310c:	91 e0       	ldi	r25, 0x01	; 1
    310e:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
	int16_t rawtemperature = 0;
    3112:	1c 82       	std	Y+4, r1	; 0x04
    3114:	1b 82       	std	Y+3, r1	; 0x03
	int16_t rawhumidity = 0;
    3116:	1a 82       	std	Y+2, r1	; 0x02
    3118:	19 82       	std	Y+1, r1	; 0x01
    311a:	6e e6       	ldi	r22, 0x6E	; 110
    311c:	e6 2e       	mov	r14, r22
    311e:	69 e1       	ldi	r22, 0x19	; 25
    3120:	f6 2e       	mov	r15, r22
    3122:	74 eb       	ldi	r23, 0xB4	; 180
    3124:	c7 2e       	mov	r12, r23
    3126:	75 e0       	ldi	r23, 0x05	; 5
    3128:	d7 2e       	mov	r13, r23
    312a:	0e e6       	ldi	r16, 0x6E	; 110
    312c:	10 e0       	ldi	r17, 0x00	; 0

	//Digital pins
	for (uint8_t i=0; i<=3; i++)
	{
		uint8_t eepos = 110 + i;
		simpleSensorTypes[i+8] = eepromReadByte(eepos);
    312e:	c8 01       	movw	r24, r16
    3130:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3134:	56 01       	movw	r10, r12
    3136:	f6 01       	movw	r30, r12
    3138:	80 83       	st	Z, r24

		if (simpleSensorTypes[i+8] == TYPE_DHT11)
    313a:	85 30       	cpi	r24, 0x05	; 5
    313c:	b1 f4       	brne	.+44     	; 0x316a <getDHTData+0x7c>
		{
			if(dht_getdata((i+2), &rawtemperature, &rawhumidity, false) == 0) {
    313e:	20 e0       	ldi	r18, 0x00	; 0
    3140:	ae 01       	movw	r20, r28
    3142:	4f 5f       	subi	r20, 0xFF	; 255
    3144:	5f 4f       	sbci	r21, 0xFF	; 255
    3146:	be 01       	movw	r22, r28
    3148:	6d 5f       	subi	r22, 0xFD	; 253
    314a:	7f 4f       	sbci	r23, 0xFF	; 255
    314c:	84 e9       	ldi	r24, 0x94	; 148
    314e:	80 0f       	add	r24, r16
    3150:	0e 94 c3 0b 	call	0x1786	; 0x1786 <dht_getdata>
    3154:	81 11       	cpse	r24, r1
    3156:	09 c0       	rjmp	.+18     	; 0x316a <getDHTData+0x7c>
				simpleSensorValues[50+(i*2)] = rawtemperature;
    3158:	8b 81       	ldd	r24, Y+3	; 0x03
    315a:	9c 81       	ldd	r25, Y+4	; 0x04
    315c:	f7 01       	movw	r30, r14
    315e:	91 83       	std	Z+1, r25	; 0x01
    3160:	80 83       	st	Z, r24
				simpleSensorValues[50+(i*2)+1] = rawhumidity;
    3162:	89 81       	ldd	r24, Y+1	; 0x01
    3164:	9a 81       	ldd	r25, Y+2	; 0x02
    3166:	93 83       	std	Z+3, r25	; 0x03
    3168:	82 83       	std	Z+2, r24	; 0x02
    316a:	ff ef       	ldi	r31, 0xFF	; 255
    316c:	cf 1a       	sub	r12, r31
    316e:	df 0a       	sbc	r13, r31
			}
		}
		if (simpleSensorTypes[i+8] == TYPE_DHT22)
    3170:	f5 01       	movw	r30, r10
    3172:	80 81       	ld	r24, Z
    3174:	84 30       	cpi	r24, 0x04	; 4
    3176:	b1 f4       	brne	.+44     	; 0x31a4 <getDHTData+0xb6>
		{
			if(dht_getdata((i+2), &rawtemperature, &rawhumidity, true) == 0) {
    3178:	21 e0       	ldi	r18, 0x01	; 1
    317a:	ae 01       	movw	r20, r28
    317c:	4f 5f       	subi	r20, 0xFF	; 255
    317e:	5f 4f       	sbci	r21, 0xFF	; 255
    3180:	be 01       	movw	r22, r28
    3182:	6d 5f       	subi	r22, 0xFD	; 253
    3184:	7f 4f       	sbci	r23, 0xFF	; 255
    3186:	84 e9       	ldi	r24, 0x94	; 148
    3188:	80 0f       	add	r24, r16
    318a:	0e 94 c3 0b 	call	0x1786	; 0x1786 <dht_getdata>
    318e:	81 11       	cpse	r24, r1
    3190:	09 c0       	rjmp	.+18     	; 0x31a4 <getDHTData+0xb6>
				simpleSensorValues[50+(i*2)] = rawtemperature;
    3192:	8b 81       	ldd	r24, Y+3	; 0x03
    3194:	9c 81       	ldd	r25, Y+4	; 0x04
    3196:	f7 01       	movw	r30, r14
    3198:	91 83       	std	Z+1, r25	; 0x01
    319a:	80 83       	st	Z, r24
				simpleSensorValues[50+(i*2)+1] = rawhumidity;
    319c:	89 81       	ldd	r24, Y+1	; 0x01
    319e:	9a 81       	ldd	r25, Y+2	; 0x02
    31a0:	93 83       	std	Z+3, r25	; 0x03
    31a2:	82 83       	std	Z+2, r24	; 0x02
    31a4:	0f 5f       	subi	r16, 0xFF	; 255
    31a6:	1f 4f       	sbci	r17, 0xFF	; 255
    31a8:	f4 e0       	ldi	r31, 0x04	; 4
    31aa:	ef 0e       	add	r14, r31
    31ac:	f1 1c       	adc	r15, r1
	printf("Reading dht ... \r\n");
	int16_t rawtemperature = 0;
	int16_t rawhumidity = 0;

	//Digital pins
	for (uint8_t i=0; i<=3; i++)
    31ae:	02 37       	cpi	r16, 0x72	; 114
    31b0:	11 05       	cpc	r17, r1
    31b2:	09 f0       	breq	.+2      	; 0x31b6 <getDHTData+0xc8>
    31b4:	bc cf       	rjmp	.-136    	; 0x312e <getDHTData+0x40>
				simpleSensorValues[50+(i*2)] = rawtemperature;
				simpleSensorValues[50+(i*2)+1] = rawhumidity;
			}
		}		
	}
}
    31b6:	0f 90       	pop	r0
    31b8:	0f 90       	pop	r0
    31ba:	0f 90       	pop	r0
    31bc:	0f 90       	pop	r0
    31be:	df 91       	pop	r29
    31c0:	cf 91       	pop	r28
    31c2:	1f 91       	pop	r17
    31c4:	0f 91       	pop	r16
    31c6:	ff 90       	pop	r15
    31c8:	ef 90       	pop	r14
    31ca:	df 90       	pop	r13
    31cc:	cf 90       	pop	r12
    31ce:	bf 90       	pop	r11
    31d0:	af 90       	pop	r10
    31d2:	08 95       	ret

000031d4 <timedAlarmCheck>:

void timedAlarmCheck(void)
{
    31d4:	4f 92       	push	r4
    31d6:	5f 92       	push	r5
    31d8:	6f 92       	push	r6
    31da:	7f 92       	push	r7
    31dc:	8f 92       	push	r8
    31de:	9f 92       	push	r9
    31e0:	af 92       	push	r10
    31e2:	cf 92       	push	r12
    31e4:	df 92       	push	r13
    31e6:	ef 92       	push	r14
    31e8:	ff 92       	push	r15
    31ea:	0f 93       	push	r16
    31ec:	1f 93       	push	r17
    31ee:	cf 93       	push	r28
    31f0:	df 93       	push	r29
    31f2:	00 d0       	rcall	.+0      	; 0x31f4 <timedAlarmCheck+0x20>
    31f4:	1f 92       	push	r1
    31f6:	cd b7       	in	r28, 0x3d	; 61
    31f8:	de b7       	in	r29, 0x3e	; 62
    31fa:	eb e9       	ldi	r30, 0x9B	; 155
    31fc:	8e 2e       	mov	r8, r30
    31fe:	99 24       	eor	r9, r9
    3200:	93 94       	inc	r9
    3202:	fc e9       	ldi	r31, 0x9C	; 156
    3204:	4f 2e       	mov	r4, r31
    3206:	55 24       	eor	r5, r5
    3208:	53 94       	inc	r5
				eepromReadByte(pos+5), 
				eepromReadByte(pos+6), 
				eepromReadByte(pos+7), 
				eepromReadByte(pos+8));

				int8_t value = (int8_t)sensorValues[(sensorpos*SENSORSIZE)+VALUE1];
    320a:	ab e0       	ldi	r26, 0x0B	; 11
    320c:	fa 2e       	mov	r15, r26
					if (pin >= 1 && pin <= 4)
					{
						if (eepromReadByte(pos+12) == 1)
							CLEARBIT(PORTC, (1+pin));
						else
							SETBIT(PORTC, (1+pin));
    320e:	66 24       	eor	r6, r6
    3210:	63 94       	inc	r6
    3212:	71 2c       	mov	r7, r1
{
	for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
	{
		uint16_t pos = 400 + ((alarm-1)*15); //400 415 430 445

		if (eepromReadByte(pos+0) == 1)
    3214:	c2 01       	movw	r24, r4
    3216:	0c 97       	sbiw	r24, 0x0c	; 12
    3218:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    321c:	81 30       	cpi	r24, 0x01	; 1
    321e:	09 f0       	breq	.+2      	; 0x3222 <timedAlarmCheck+0x4e>
    3220:	ad c0       	rjmp	.+346    	; 0x337c <timedAlarmCheck+0x1a8>
		{
				uint8_t sensorpos = findSensor(
    3222:	c2 01       	movw	r24, r4
    3224:	04 97       	sbiw	r24, 0x04	; 4
    3226:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    322a:	a8 2e       	mov	r10, r24
    322c:	c2 01       	movw	r24, r4
    322e:	05 97       	sbiw	r24, 0x05	; 5
    3230:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3234:	c8 2e       	mov	r12, r24
    3236:	c2 01       	movw	r24, r4
    3238:	06 97       	sbiw	r24, 0x06	; 6
    323a:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    323e:	e8 2e       	mov	r14, r24
    3240:	c2 01       	movw	r24, r4
    3242:	07 97       	sbiw	r24, 0x07	; 7
    3244:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3248:	08 2f       	mov	r16, r24
    324a:	c2 01       	movw	r24, r4
    324c:	08 97       	sbiw	r24, 0x08	; 8
    324e:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3252:	28 2f       	mov	r18, r24
    3254:	c2 01       	movw	r24, r4
    3256:	09 97       	sbiw	r24, 0x09	; 9
    3258:	2b 83       	std	Y+3, r18	; 0x03
    325a:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    325e:	48 2f       	mov	r20, r24
    3260:	c2 01       	movw	r24, r4
    3262:	0a 97       	sbiw	r24, 0x0a	; 10
    3264:	4a 83       	std	Y+2, r20	; 0x02
    3266:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    326a:	68 2f       	mov	r22, r24
    326c:	c2 01       	movw	r24, r4
    326e:	0b 97       	sbiw	r24, 0x0b	; 11
    3270:	69 83       	std	Y+1, r22	; 0x01
    3272:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3276:	2b 81       	ldd	r18, Y+3	; 0x03
    3278:	4a 81       	ldd	r20, Y+2	; 0x02
    327a:	69 81       	ldd	r22, Y+1	; 0x01
    327c:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <findSensor>
				eepromReadByte(pos+5), 
				eepromReadByte(pos+6), 
				eepromReadByte(pos+7), 
				eepromReadByte(pos+8));

				int8_t value = (int8_t)sensorValues[(sensorpos*SENSORSIZE)+VALUE1];
    3280:	8f 9d       	mul	r24, r15
    3282:	f0 01       	movw	r30, r0
    3284:	11 24       	eor	r1, r1
    3286:	e0 5f       	subi	r30, 0xF0	; 240
    3288:	f9 4f       	sbci	r31, 0xF9	; 249
    328a:	e0 84       	ldd	r14, Z+8	; 0x08
				char sign = sensorValues[(sensorpos*SENSORSIZE)+SIGN];				
				if (sign == '-') value *= -1;
    328c:	82 85       	ldd	r24, Z+10	; 0x0a
    328e:	8d 32       	cpi	r24, 0x2D	; 45
    3290:	09 f4       	brne	.+2      	; 0x3294 <timedAlarmCheck+0xc0>
    3292:	e1 94       	neg	r14

				int8_t target = eepromReadByteSigned(pos+10);
    3294:	c2 01       	movw	r24, r4
    3296:	02 97       	sbiw	r24, 0x02	; 2
    3298:	0e 94 59 21 	call	0x42b2	; 0x42b2 <eepromReadByteSigned>
    329c:	d8 2e       	mov	r13, r24

				if (
					(eepromReadByte(pos+9) == 1 && value < target)
    329e:	82 01       	movw	r16, r4
    32a0:	03 50       	subi	r16, 0x03	; 3
    32a2:	11 09       	sbc	r17, r1
    32a4:	c8 01       	movw	r24, r16
    32a6:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
				char sign = sensorValues[(sensorpos*SENSORSIZE)+SIGN];				
				if (sign == '-') value *= -1;

				int8_t target = eepromReadByteSigned(pos+10);

				if (
    32aa:	81 30       	cpi	r24, 0x01	; 1
    32ac:	61 f4       	brne	.+24     	; 0x32c6 <timedAlarmCheck+0xf2>
					(eepromReadByte(pos+9) == 1 && value < target)
    32ae:	ed 14       	cp	r14, r13
    32b0:	54 f4       	brge	.+20     	; 0x32c6 <timedAlarmCheck+0xf2>
					(eepromReadByte(pos+9) == 3 && value > target)
				)
				{
					//ALARM
					//DDR=in/out PIN=value/pullup PORT=state
					uint8_t pin = eepromReadByte(pos+11);
    32b2:	c4 01       	movw	r24, r8
    32b4:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    32b8:	18 2f       	mov	r17, r24

					if (pin >= 1 && pin <= 4)
    32ba:	8f ef       	ldi	r24, 0xFF	; 255
    32bc:	81 0f       	add	r24, r17
    32be:	84 30       	cpi	r24, 0x04	; 4
    32c0:	08 f0       	brcs	.+2      	; 0x32c4 <timedAlarmCheck+0xf0>
    32c2:	5c c0       	rjmp	.+184    	; 0x337c <timedAlarmCheck+0x1a8>
    32c4:	0f c0       	rjmp	.+30     	; 0x32e4 <timedAlarmCheck+0x110>
				int8_t target = eepromReadByteSigned(pos+10);

				if (
					(eepromReadByte(pos+9) == 1 && value < target)
					||
					(eepromReadByte(pos+9) == 2 && value == target)
    32c6:	c8 01       	movw	r24, r16
    32c8:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>

				int8_t target = eepromReadByteSigned(pos+10);

				if (
					(eepromReadByte(pos+9) == 1 && value < target)
					||
    32cc:	82 30       	cpi	r24, 0x02	; 2
    32ce:	11 f4       	brne	.+4      	; 0x32d4 <timedAlarmCheck+0x100>
					(eepromReadByte(pos+9) == 2 && value == target)
    32d0:	ed 14       	cp	r14, r13
    32d2:	79 f3       	breq	.-34     	; 0x32b2 <timedAlarmCheck+0xde>
					||
					(eepromReadByte(pos+9) == 3 && value > target)
    32d4:	c8 01       	movw	r24, r16
    32d6:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>

				if (
					(eepromReadByte(pos+9) == 1 && value < target)
					||
					(eepromReadByte(pos+9) == 2 && value == target)
					||
    32da:	83 30       	cpi	r24, 0x03	; 3
    32dc:	01 f5       	brne	.+64     	; 0x331e <timedAlarmCheck+0x14a>
					(eepromReadByte(pos+9) == 3 && value > target)
    32de:	de 14       	cp	r13, r14
    32e0:	44 f3       	brlt	.-48     	; 0x32b2 <timedAlarmCheck+0xde>
    32e2:	1d c0       	rjmp	.+58     	; 0x331e <timedAlarmCheck+0x14a>
					//DDR=in/out PIN=value/pullup PORT=state
					uint8_t pin = eepromReadByte(pos+11);

					if (pin >= 1 && pin <= 4)
					{
						if (eepromReadByte(pos+12) == 1)
    32e4:	c2 01       	movw	r24, r4
    32e6:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    32ea:	21 2f       	mov	r18, r17
    32ec:	30 e0       	ldi	r19, 0x00	; 0
    32ee:	81 30       	cpi	r24, 0x01	; 1
    32f0:	59 f4       	brne	.+22     	; 0x3308 <timedAlarmCheck+0x134>
						{
							SETBIT(PORTC, (1+pin));
    32f2:	88 b1       	in	r24, 0x08	; 8
    32f4:	2f 5f       	subi	r18, 0xFF	; 255
    32f6:	3f 4f       	sbci	r19, 0xFF	; 255
    32f8:	a3 01       	movw	r20, r6
    32fa:	02 c0       	rjmp	.+4      	; 0x3300 <timedAlarmCheck+0x12c>
    32fc:	44 0f       	add	r20, r20
    32fe:	55 1f       	adc	r21, r21
    3300:	2a 95       	dec	r18
    3302:	e2 f7       	brpl	.-8      	; 0x32fc <timedAlarmCheck+0x128>
    3304:	9a 01       	movw	r18, r20
    3306:	38 c0       	rjmp	.+112    	; 0x3378 <timedAlarmCheck+0x1a4>
						}
						else
							CLEARBIT(PORTC, (1+pin));
    3308:	88 b1       	in	r24, 0x08	; 8
    330a:	2f 5f       	subi	r18, 0xFF	; 255
    330c:	3f 4f       	sbci	r19, 0xFF	; 255
    330e:	f3 01       	movw	r30, r6
    3310:	02 c0       	rjmp	.+4      	; 0x3316 <timedAlarmCheck+0x142>
    3312:	ee 0f       	add	r30, r30
    3314:	ff 1f       	adc	r31, r31
    3316:	2a 95       	dec	r18
    3318:	e2 f7       	brpl	.-8      	; 0x3312 <timedAlarmCheck+0x13e>
    331a:	9f 01       	movw	r18, r30
    331c:	1f c0       	rjmp	.+62     	; 0x335c <timedAlarmCheck+0x188>
					else if (pin >= 24 && pin <= 27) {
						//MCP driven relay
						simpleSensorValues[pin] = 1;
					}
					#endif
 				} else if (eepromReadByte(pos+13) == 1) {
    331e:	c2 01       	movw	r24, r4
    3320:	01 96       	adiw	r24, 0x01	; 1
    3322:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3326:	81 30       	cpi	r24, 0x01	; 1
    3328:	49 f5       	brne	.+82     	; 0x337c <timedAlarmCheck+0x1a8>
 					//REVERSE
					uint8_t pin = eepromReadByte(pos+11);
    332a:	c4 01       	movw	r24, r8
    332c:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3330:	18 2f       	mov	r17, r24
					if (pin >= 1 && pin <= 4)
    3332:	8f ef       	ldi	r24, 0xFF	; 255
    3334:	81 0f       	add	r24, r17
    3336:	84 30       	cpi	r24, 0x04	; 4
    3338:	08 f5       	brcc	.+66     	; 0x337c <timedAlarmCheck+0x1a8>
					{
						if (eepromReadByte(pos+12) == 1)
    333a:	c2 01       	movw	r24, r4
    333c:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3340:	21 2f       	mov	r18, r17
    3342:	30 e0       	ldi	r19, 0x00	; 0
    3344:	81 30       	cpi	r24, 0x01	; 1
    3346:	71 f4       	brne	.+28     	; 0x3364 <timedAlarmCheck+0x190>
							CLEARBIT(PORTC, (1+pin));
    3348:	88 b1       	in	r24, 0x08	; 8
    334a:	2f 5f       	subi	r18, 0xFF	; 255
    334c:	3f 4f       	sbci	r19, 0xFF	; 255
    334e:	a3 01       	movw	r20, r6
    3350:	02 c0       	rjmp	.+4      	; 0x3356 <timedAlarmCheck+0x182>
    3352:	44 0f       	add	r20, r20
    3354:	55 1f       	adc	r21, r21
    3356:	2a 95       	dec	r18
    3358:	e2 f7       	brpl	.-8      	; 0x3352 <timedAlarmCheck+0x17e>
    335a:	9a 01       	movw	r18, r20
    335c:	20 95       	com	r18
    335e:	28 23       	and	r18, r24
    3360:	28 b9       	out	0x08, r18	; 8
    3362:	0c c0       	rjmp	.+24     	; 0x337c <timedAlarmCheck+0x1a8>
						else
							SETBIT(PORTC, (1+pin));
    3364:	88 b1       	in	r24, 0x08	; 8
    3366:	2f 5f       	subi	r18, 0xFF	; 255
    3368:	3f 4f       	sbci	r19, 0xFF	; 255
    336a:	f3 01       	movw	r30, r6
    336c:	02 c0       	rjmp	.+4      	; 0x3372 <timedAlarmCheck+0x19e>
    336e:	ee 0f       	add	r30, r30
    3370:	ff 1f       	adc	r31, r31
    3372:	2a 95       	dec	r18
    3374:	e2 f7       	brpl	.-8      	; 0x336e <timedAlarmCheck+0x19a>
    3376:	9f 01       	movw	r18, r30
    3378:	82 2b       	or	r24, r18
    337a:	88 b9       	out	0x08, r24	; 8
    337c:	ff e0       	ldi	r31, 0x0F	; 15
    337e:	4f 0e       	add	r4, r31
    3380:	51 1c       	adc	r5, r1
    3382:	4f e0       	ldi	r20, 0x0F	; 15
    3384:	84 0e       	add	r8, r20
    3386:	91 1c       	adc	r9, r1
	}
}

void timedAlarmCheck(void)
{
	for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
    3388:	58 ed       	ldi	r21, 0xD8	; 216
    338a:	45 16       	cp	r4, r21
    338c:	51 e0       	ldi	r21, 0x01	; 1
    338e:	55 06       	cpc	r5, r21
    3390:	09 f0       	breq	.+2      	; 0x3394 <timedAlarmCheck+0x1c0>
    3392:	40 cf       	rjmp	.-384    	; 0x3214 <timedAlarmCheck+0x40>
					}
					#endif
 				}
		}
	}
}
    3394:	0f 90       	pop	r0
    3396:	0f 90       	pop	r0
    3398:	0f 90       	pop	r0
    339a:	df 91       	pop	r29
    339c:	cf 91       	pop	r28
    339e:	1f 91       	pop	r17
    33a0:	0f 91       	pop	r16
    33a2:	ff 90       	pop	r15
    33a4:	ef 90       	pop	r14
    33a6:	df 90       	pop	r13
    33a8:	cf 90       	pop	r12
    33aa:	af 90       	pop	r10
    33ac:	9f 90       	pop	r9
    33ae:	8f 90       	pop	r8
    33b0:	7f 90       	pop	r7
    33b2:	6f 90       	pop	r6
    33b4:	5f 90       	pop	r5
    33b6:	4f 90       	pop	r4
    33b8:	08 95       	ret

000033ba <main>:
	}
}

FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);   

int main(void){      
    33ba:	cf 93       	push	r28
    33bc:	df 93       	push	r29
    33be:	cd b7       	in	r28, 0x3d	; 61
    33c0:	de b7       	in	r29, 0x3e	; 62
    33c2:	69 97       	sbiw	r28, 0x19	; 25
    33c4:	0f b6       	in	r0, 0x3f	; 63
    33c6:	f8 94       	cli
    33c8:	de bf       	out	0x3e, r29	; 62
    33ca:	0f be       	out	0x3f, r0	; 63
    33cc:	cd bf       	out	0x3d, r28	; 61
		SETBIT(DDRB, 2); //hardware watchdog
		FLIPBIT(PORTB, 2);
		_delay_ms(1);
		FLIPBIT(PORTB, 2);	
	#else
		wdt_disable();
    33ce:	88 e1       	ldi	r24, 0x18	; 24
    33d0:	0f b6       	in	r0, 0x3f	; 63
    33d2:	f8 94       	cli
    33d4:	80 93 60 00 	sts	0x0060, r24
    33d8:	10 92 60 00 	sts	0x0060, r1
    33dc:	0f be       	out	0x3f, r0	; 63
		wdt_reset();
    33de:	a8 95       	wdr
		wdt_enable(WDTO_4S); 
    33e0:	28 e2       	ldi	r18, 0x28	; 40
    33e2:	88 e1       	ldi	r24, 0x18	; 24
    33e4:	90 e0       	ldi	r25, 0x00	; 0
    33e6:	0f b6       	in	r0, 0x3f	; 63
    33e8:	f8 94       	cli
    33ea:	a8 95       	wdr
    33ec:	80 93 60 00 	sts	0x0060, r24
    33f0:	0f be       	out	0x3f, r0	; 63
    33f2:	20 93 60 00 	sts	0x0060, r18
		wdt_reset();
    33f6:	a8 95       	wdr
	#endif
	
	wdt_reset();
    33f8:	a8 95       	wdr

FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);   

int main(void){      
	mywdt_init();
	mywdt_sleep(100);
    33fa:	84 e6       	ldi	r24, 0x64	; 100
    33fc:	90 e0       	ldi	r25, 0x00	; 0
    33fe:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <mywdt_sleep>
	CLEARBIT(DDRC, 6); //Alarm indgang
	CLEARBIT(PORTC, 7); //Lav
	SETBIT(DDRC, 7); //Alarm udgang
#endif

		usart_init(9600);
    3402:	60 e8       	ldi	r22, 0x80	; 128
    3404:	75 e2       	ldi	r23, 0x25	; 37
    3406:	80 e0       	ldi	r24, 0x00	; 0
    3408:	90 e0       	ldi	r25, 0x00	; 0
    340a:	0e 94 23 1e 	call	0x3c46	; 0x3c46 <usart_init>
		stdout = &uart_str;
    340e:	85 e0       	ldi	r24, 0x05	; 5
    3410:	91 e0       	ldi	r25, 0x01	; 1
    3412:	90 93 f0 22 	sts	0x22F0, r25
    3416:	80 93 ef 22 	sts	0x22EF, r24
		stderr = &uart_str;
    341a:	90 93 f2 22 	sts	0x22F2, r25
    341e:	80 93 f1 22 	sts	0x22F1, r24
		stdin  = &uart_str;
    3422:	90 93 ee 22 	sts	0x22EE, r25
    3426:	80 93 ed 22 	sts	0x22ED, r24
#if SBNG_TARGET == 50
		printf_P(PSTR("tolog.dk - Firmware %u.%u booting\r\n"),SBNG_VERSION_MAJOR,SBNG_VERSION_MINOR);
#else
		printf_P(PSTR("Stokerbot S3 - Firmware %u.%u booting\r\n"),SBNG_VERSION_MAJOR,SBNG_VERSION_MINOR);
    342a:	1f 92       	push	r1
    342c:	8d e0       	ldi	r24, 0x0D	; 13
    342e:	8f 93       	push	r24
    3430:	1f 92       	push	r1
    3432:	82 e0       	ldi	r24, 0x02	; 2
    3434:	8f 93       	push	r24
    3436:	8b e3       	ldi	r24, 0x3B	; 59
    3438:	92 e0       	ldi	r25, 0x02	; 2
    343a:	9f 93       	push	r25
    343c:	8f 93       	push	r24
    343e:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
#endif

 		mywdt_sleep(2500);
    3442:	84 ec       	ldi	r24, 0xC4	; 196
    3444:	99 e0       	ldi	r25, 0x09	; 9
    3446:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <mywdt_sleep>

		spilcd_init();
    344a:	0e 94 4d 37 	call	0x6e9a	; 0x6e9a <spilcd_init>
		LCDclr();
    344e:	0e 94 44 37 	call	0x6e88	; 0x6e88 <LCDclr>
		mywdt_sleep(100);
    3452:	84 e6       	ldi	r24, 0x64	; 100
    3454:	90 e0       	ldi	r25, 0x00	; 0
    3456:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <mywdt_sleep>

		hasLcd = eepromReadByte(50);
    345a:	82 e3       	ldi	r24, 0x32	; 50
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3462:	80 93 85 05 	sts	0x0585, r24
		if (hasLcd > 0 && hasLcd != 255)
    3466:	81 50       	subi	r24, 0x01	; 1
    3468:	0f 90       	pop	r0
    346a:	0f 90       	pop	r0
    346c:	0f 90       	pop	r0
    346e:	0f 90       	pop	r0
    3470:	0f 90       	pop	r0
    3472:	0f 90       	pop	r0
    3474:	8e 3f       	cpi	r24, 0xFE	; 254
    3476:	58 f4       	brcc	.+22     	; 0x348e <main+0xd4>
		{
			LCDclr();
    3478:	0e 94 44 37 	call	0x6e88	; 0x6e88 <LCDclr>
			LCDsetCursor(0, 0);
    347c:	60 e0       	ldi	r22, 0x00	; 0
    347e:	80 e0       	ldi	r24, 0x00	; 0
    3480:	0e 94 8d 37 	call	0x6f1a	; 0x6f1a <LCDsetCursor>
			#if SBNG_TARGET == 50
				LCDwrite(" tolog.dk v2.11 ", 0);
			#else
				LCDwrite(" Stokerbot S3S v2.11 ", 0);
    3484:	60 e0       	ldi	r22, 0x00	; 0
    3486:	89 e5       	ldi	r24, 0x59	; 89
    3488:	91 e0       	ldi	r25, 0x01	; 1
    348a:	0e 94 aa 37 	call	0x6f54	; 0x6f54 <LCDwrite>
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    348e:	a8 95       	wdr
				LCDwrite(" Stokerbot S3S v2.11 ", 0);
			#endif
		}

		mywdt_reset();
		mywdt_sleep(2500);
    3490:	84 ec       	ldi	r24, 0xC4	; 196
    3492:	99 e0       	ldi	r25, 0x09	; 9
    3494:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <mywdt_sleep>

 		sensorScan = (uint8_t*)&tempbuf;
    3498:	8a e0       	ldi	r24, 0x0A	; 10
    349a:	99 e0       	ldi	r25, 0x09	; 9
    349c:	90 93 09 09 	sts	0x0909, r25
    34a0:	80 93 08 09 	sts	0x0908, r24

		#if SBNG_TARGET == 50
			printf_P(PSTR("tolog.dk - Firmware %u.%u ready\r\n"),SBNG_VERSION_MAJOR,SBNG_VERSION_MINOR);
		#else
			printf_P(PSTR("Stokerbot S3 - Firmware %u.%u ready\r\n"),SBNG_VERSION_MAJOR,SBNG_VERSION_MINOR);
    34a4:	1f 92       	push	r1
    34a6:	8d e0       	ldi	r24, 0x0D	; 13
    34a8:	8f 93       	push	r24
    34aa:	1f 92       	push	r1
    34ac:	82 e0       	ldi	r24, 0x02	; 2
    34ae:	8f 93       	push	r24
    34b0:	85 e1       	ldi	r24, 0x15	; 21
    34b2:	92 e0       	ldi	r25, 0x02	; 2
    34b4:	9f 93       	push	r25
    34b6:	8f 93       	push	r24
    34b8:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
		#endif

	if (eepromReadByte(0) == 255 || eepromReadByte(11) == 255)
    34bc:	80 e0       	ldi	r24, 0x00	; 0
    34be:	90 e0       	ldi	r25, 0x00	; 0
    34c0:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    34c4:	0f 90       	pop	r0
    34c6:	0f 90       	pop	r0
    34c8:	0f 90       	pop	r0
    34ca:	0f 90       	pop	r0
    34cc:	0f 90       	pop	r0
    34ce:	0f 90       	pop	r0
    34d0:	8f 3f       	cpi	r24, 0xFF	; 255
    34d2:	09 f0       	breq	.+2      	; 0x34d6 <main+0x11c>
    34d4:	a8 c0       	rjmp	.+336    	; 0x3626 <main+0x26c>
	{
		printf_P(PSTR("Setting default values\r\n"));
    34d6:	8c ef       	ldi	r24, 0xFC	; 252
    34d8:	91 e0       	ldi	r25, 0x01	; 1
    34da:	9f 93       	push	r25
    34dc:	8f 93       	push	r24
    34de:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
		//Set defaults
		eepromWriteByte(0, 0); //init
    34e2:	60 e0       	ldi	r22, 0x00	; 0
    34e4:	80 e0       	ldi	r24, 0x00	; 0
    34e6:	90 e0       	ldi	r25, 0x00	; 0
    34e8:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>

		myip[0] = 192;
    34ec:	30 ec       	ldi	r19, 0xC0	; 192
    34ee:	30 93 1f 01 	sts	0x011F, r19
		myip[1] = 168;
    34f2:	28 ea       	ldi	r18, 0xA8	; 168
    34f4:	20 93 20 01 	sts	0x0120, r18
		myip[2] = 1;
    34f8:	81 e0       	ldi	r24, 0x01	; 1
    34fa:	80 93 21 01 	sts	0x0121, r24
		myip[3] = 47;
    34fe:	9f e2       	ldi	r25, 0x2F	; 47
    3500:	90 93 22 01 	sts	0x0122, r25

		netmask[0] = 255;
    3504:	9f ef       	ldi	r25, 0xFF	; 255
    3506:	90 93 17 01 	sts	0x0117, r25
		netmask[1] = 255;
    350a:	90 93 18 01 	sts	0x0118, r25
		netmask[2] = 255;
    350e:	90 93 19 01 	sts	0x0119, r25
		netmask[3] = 0;
    3512:	10 92 1a 01 	sts	0x011A, r1

		gwip[0] = 192;
    3516:	30 93 23 01 	sts	0x0123, r19
		gwip[1] = 168;
    351a:	20 93 24 01 	sts	0x0124, r18
		gwip[2] = 1;
    351e:	80 93 25 01 	sts	0x0125, r24
		gwip[3] = 1;
    3522:	80 93 26 01 	sts	0x0126, r24

		dnsip[0] = 8;
    3526:	88 e0       	ldi	r24, 0x08	; 8
    3528:	80 93 13 01 	sts	0x0113, r24
		dnsip[1] = 8;
    352c:	80 93 14 01 	sts	0x0114, r24
		dnsip[2] = 8;
    3530:	80 93 15 01 	sts	0x0115, r24
		dnsip[3] = 8;
    3534:	80 93 16 01 	sts	0x0116, r24

		eepromWriteByte(29, 80);  //web port
    3538:	60 e5       	ldi	r22, 0x50	; 80
    353a:	8d e1       	ldi	r24, 0x1D	; 29
    353c:	90 e0       	ldi	r25, 0x00	; 0
    353e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(10, 0);  //dhcp off
    3542:	60 e0       	ldi	r22, 0x00	; 0
    3544:	8a e0       	ldi	r24, 0x0A	; 10
    3546:	90 e0       	ldi	r25, 0x00	; 0
    3548:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(50, 0);  //no LCD
    354c:	60 e0       	ldi	r22, 0x00	; 0
    354e:	82 e3       	ldi	r24, 0x32	; 50
    3550:	90 e0       	ldi	r25, 0x00	; 0
    3552:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>

		save_ip_addresses();
    3556:	0e 94 93 17 	call	0x2f26	; 0x2f26 <save_ip_addresses>

		eepromWriteStr(200, "SBNG", 4);  //default password
    355a:	44 e0       	ldi	r20, 0x04	; 4
    355c:	6f e6       	ldi	r22, 0x6F	; 111
    355e:	71 e0       	ldi	r23, 0x01	; 1
    3560:	88 ec       	ldi	r24, 0xC8	; 200
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	0e 94 5f 21 	call	0x42be	; 0x42be <eepromSaveStr>
		eepromWriteByte(204, '\0');
    3568:	60 e0       	ldi	r22, 0x00	; 0
    356a:	8c ec       	ldi	r24, 0xCC	; 204
    356c:	90 e0       	ldi	r25, 0x00	; 0
    356e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(205, '\0');
    3572:	60 e0       	ldi	r22, 0x00	; 0
    3574:	8d ec       	ldi	r24, 0xCD	; 205
    3576:	90 e0       	ldi	r25, 0x00	; 0
    3578:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(206, '\0');
    357c:	60 e0       	ldi	r22, 0x00	; 0
    357e:	8e ec       	ldi	r24, 0xCE	; 206
    3580:	90 e0       	ldi	r25, 0x00	; 0
    3582:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(207, '\0');
    3586:	60 e0       	ldi	r22, 0x00	; 0
    3588:	8f ec       	ldi	r24, 0xCF	; 207
    358a:	90 e0       	ldi	r25, 0x00	; 0
    358c:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(208, '\0');
    3590:	60 e0       	ldi	r22, 0x00	; 0
    3592:	80 ed       	ldi	r24, 0xD0	; 208
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(209, '\0');
    359a:	60 e0       	ldi	r22, 0x00	; 0
    359c:	81 ed       	ldi	r24, 0xD1	; 209
    359e:	90 e0       	ldi	r25, 0x00	; 0
    35a0:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>

		eepromWriteByte(100, 1); //Analog port 0 = ADC
    35a4:	61 e0       	ldi	r22, 0x01	; 1
    35a6:	84 e6       	ldi	r24, 0x64	; 100
    35a8:	90 e0       	ldi	r25, 0x00	; 0
    35aa:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(101, 1); //Analog port 1 = ADC
    35ae:	61 e0       	ldi	r22, 0x01	; 1
    35b0:	85 e6       	ldi	r24, 0x65	; 101
    35b2:	90 e0       	ldi	r25, 0x00	; 0
    35b4:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(102, 1); //Analog port 2 = ADC
    35b8:	61 e0       	ldi	r22, 0x01	; 1
    35ba:	86 e6       	ldi	r24, 0x66	; 102
    35bc:	90 e0       	ldi	r25, 0x00	; 0
    35be:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(103, 1); //Analog port 3 = ADC
    35c2:	61 e0       	ldi	r22, 0x01	; 1
    35c4:	87 e6       	ldi	r24, 0x67	; 103
    35c6:	90 e0       	ldi	r25, 0x00	; 0
    35c8:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(104, 1); //Analog port 4 = ADC
    35cc:	61 e0       	ldi	r22, 0x01	; 1
    35ce:	88 e6       	ldi	r24, 0x68	; 104
    35d0:	90 e0       	ldi	r25, 0x00	; 0
    35d2:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(105, 1); //Analog port 5 = ADC
    35d6:	61 e0       	ldi	r22, 0x01	; 1
    35d8:	89 e6       	ldi	r24, 0x69	; 105
    35da:	90 e0       	ldi	r25, 0x00	; 0
    35dc:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(106, 1); //Analog port 6 = ADC
    35e0:	61 e0       	ldi	r22, 0x01	; 1
    35e2:	8a e6       	ldi	r24, 0x6A	; 106
    35e4:	90 e0       	ldi	r25, 0x00	; 0
    35e6:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(107, 1); //Analog port 7 = ADC
    35ea:	61 e0       	ldi	r22, 0x01	; 1
    35ec:	8b e6       	ldi	r24, 0x6B	; 107
    35ee:	90 e0       	ldi	r25, 0x00	; 0
    35f0:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>

		eepromWriteByte(110, 0); //Digital port 0 = OUT
    35f4:	60 e0       	ldi	r22, 0x00	; 0
    35f6:	8e e6       	ldi	r24, 0x6E	; 110
    35f8:	90 e0       	ldi	r25, 0x00	; 0
    35fa:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(111, 0); //Digital port 1 = OUT
    35fe:	60 e0       	ldi	r22, 0x00	; 0
    3600:	8f e6       	ldi	r24, 0x6F	; 111
    3602:	90 e0       	ldi	r25, 0x00	; 0
    3604:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(112, 0); //Digital port 2 = OUT
    3608:	60 e0       	ldi	r22, 0x00	; 0
    360a:	80 e7       	ldi	r24, 0x70	; 112
    360c:	90 e0       	ldi	r25, 0x00	; 0
    360e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		eepromWriteByte(113, 0); //Digital port 3 = OUT	
    3612:	60 e0       	ldi	r22, 0x00	; 0
    3614:	81 e7       	ldi	r24, 0x71	; 113
    3616:	90 e0       	ldi	r25, 0x00	; 0
    3618:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
    361c:	0f 90       	pop	r0
    361e:	0f 90       	pop	r0
    3620:	00 e9       	ldi	r16, 0x90	; 144
    3622:	11 e0       	ldi	r17, 0x01	; 1
    3624:	08 c0       	rjmp	.+16     	; 0x3636 <main+0x27c>
			printf_P(PSTR("tolog.dk - Firmware %u.%u ready\r\n"),SBNG_VERSION_MAJOR,SBNG_VERSION_MINOR);
		#else
			printf_P(PSTR("Stokerbot S3 - Firmware %u.%u ready\r\n"),SBNG_VERSION_MAJOR,SBNG_VERSION_MINOR);
		#endif

	if (eepromReadByte(0) == 255 || eepromReadByte(11) == 255)
    3626:	8b e0       	ldi	r24, 0x0B	; 11
    3628:	90 e0       	ldi	r25, 0x00	; 0
    362a:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    362e:	8f 3f       	cpi	r24, 0xFF	; 255
    3630:	09 f0       	breq	.+2      	; 0x3634 <main+0x27a>
    3632:	57 c0       	rjmp	.+174    	; 0x36e2 <main+0x328>
    3634:	50 cf       	rjmp	.-352    	; 0x34d6 <main+0x11c>

		for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
		{
			uint16_t pos = 400 + ((alarm-1)*15); //400 415 430 445

			eepromWriteByte(pos+0, 0); //enabled
    3636:	60 e0       	ldi	r22, 0x00	; 0
    3638:	c8 01       	movw	r24, r16
    363a:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+1, 0); //sensorid
    363e:	60 e0       	ldi	r22, 0x00	; 0
    3640:	c8 01       	movw	r24, r16
    3642:	01 96       	adiw	r24, 0x01	; 1
    3644:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+2, 0); //sensorid
    3648:	60 e0       	ldi	r22, 0x00	; 0
    364a:	c8 01       	movw	r24, r16
    364c:	02 96       	adiw	r24, 0x02	; 2
    364e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+3, 0); //sensorid
    3652:	60 e0       	ldi	r22, 0x00	; 0
    3654:	c8 01       	movw	r24, r16
    3656:	03 96       	adiw	r24, 0x03	; 3
    3658:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+4, 0); //sensorid
    365c:	60 e0       	ldi	r22, 0x00	; 0
    365e:	c8 01       	movw	r24, r16
    3660:	04 96       	adiw	r24, 0x04	; 4
    3662:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+5, 0); //sensorid
    3666:	60 e0       	ldi	r22, 0x00	; 0
    3668:	c8 01       	movw	r24, r16
    366a:	05 96       	adiw	r24, 0x05	; 5
    366c:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+6, 0); //sensorid
    3670:	60 e0       	ldi	r22, 0x00	; 0
    3672:	c8 01       	movw	r24, r16
    3674:	06 96       	adiw	r24, 0x06	; 6
    3676:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+7, 0); //sensorid
    367a:	60 e0       	ldi	r22, 0x00	; 0
    367c:	c8 01       	movw	r24, r16
    367e:	07 96       	adiw	r24, 0x07	; 7
    3680:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+8, 0); //sensorid
    3684:	60 e0       	ldi	r22, 0x00	; 0
    3686:	c8 01       	movw	r24, r16
    3688:	08 96       	adiw	r24, 0x08	; 8
    368a:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+9, '<'); //type
    368e:	6c e3       	ldi	r22, 0x3C	; 60
    3690:	c8 01       	movw	r24, r16
    3692:	09 96       	adiw	r24, 0x09	; 9
    3694:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+10, 0); //value
    3698:	60 e0       	ldi	r22, 0x00	; 0
    369a:	c8 01       	movw	r24, r16
    369c:	0a 96       	adiw	r24, 0x0a	; 10
    369e:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+11, 0); //target
    36a2:	60 e0       	ldi	r22, 0x00	; 0
    36a4:	c8 01       	movw	r24, r16
    36a6:	0b 96       	adiw	r24, 0x0b	; 11
    36a8:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+12, 0); //state
    36ac:	60 e0       	ldi	r22, 0x00	; 0
    36ae:	c8 01       	movw	r24, r16
    36b0:	0c 96       	adiw	r24, 0x0c	; 12
    36b2:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+13, 0); //reverse
    36b6:	60 e0       	ldi	r22, 0x00	; 0
    36b8:	c8 01       	movw	r24, r16
    36ba:	0d 96       	adiw	r24, 0x0d	; 13
    36bc:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
			eepromWriteByte(pos+14, 0); //not-used
    36c0:	60 e0       	ldi	r22, 0x00	; 0
    36c2:	c8 01       	movw	r24, r16
    36c4:	0e 96       	adiw	r24, 0x0e	; 14
    36c6:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
    36ca:	01 5f       	subi	r16, 0xF1	; 241
    36cc:	1f 4f       	sbci	r17, 0xFF	; 255
		eepromWriteByte(110, 0); //Digital port 0 = OUT
		eepromWriteByte(111, 0); //Digital port 1 = OUT
		eepromWriteByte(112, 0); //Digital port 2 = OUT
		eepromWriteByte(113, 0); //Digital port 3 = OUT	

		for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
    36ce:	0c 3c       	cpi	r16, 0xCC	; 204
    36d0:	21 e0       	ldi	r18, 0x01	; 1
    36d2:	12 07       	cpc	r17, r18
    36d4:	09 f0       	breq	.+2      	; 0x36d8 <main+0x31e>
    36d6:	af cf       	rjmp	.-162    	; 0x3636 <main+0x27c>
			eepromWriteByte(pos+12, 0); //state
			eepromWriteByte(pos+13, 0); //reverse
			eepromWriteByte(pos+14, 0); //not-used
		}
    	
		eepromWriteByte(1, EEPROM_VERSION);
    36d8:	62 e0       	ldi	r22, 0x02	; 2
    36da:	81 e0       	ldi	r24, 0x01	; 1
    36dc:	90 e0       	ldi	r25, 0x00	; 0
    36de:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
	}

	if (dnsip[0] == 255)
    36e2:	80 91 13 01 	lds	r24, 0x0113
    36e6:	8f 3f       	cpi	r24, 0xFF	; 255
    36e8:	59 f4       	brne	.+22     	; 0x3700 <main+0x346>
	{
		dnsip[0] = 8;
    36ea:	88 e0       	ldi	r24, 0x08	; 8
    36ec:	80 93 13 01 	sts	0x0113, r24
		dnsip[1] = 8;
    36f0:	80 93 14 01 	sts	0x0114, r24
		dnsip[2] = 8;
    36f4:	80 93 15 01 	sts	0x0115, r24
		dnsip[3] = 8;
    36f8:	80 93 16 01 	sts	0x0116, r24
		save_ip_addresses();
    36fc:	0e 94 93 17 	call	0x2f26	; 0x2f26 <save_ip_addresses>
	}


		read_ip_addresses();
    3700:	0e 94 32 17 	call	0x2e64	; 0x2e64 <read_ip_addresses>


		OW_selectPort(1);
    3704:	81 e0       	ldi	r24, 0x01	; 1
    3706:	0e 94 0f 22 	call	0x441e	; 0x441e <OW_selectPort>
        int nSensors = search_sensors(MAXSENSORS);  //Finder alle sensore (op til max)
    370a:	8c e3       	ldi	r24, 0x3C	; 60
    370c:	90 e0       	ldi	r25, 0x00	; 0
    370e:	0e 94 f3 22 	call	0x45e6	; 0x45e6 <search_sensors>
    3712:	a8 2e       	mov	r10, r24
    3714:	b1 2c       	mov	r11, r1
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    3716:	a8 95       	wdr

		OW_selectPort(1);
        int nSensors = search_sensors(MAXSENSORS);  //Finder alle sensore (op til max)
		mywdt_reset();

		for ( int i=0; i<nSensors; i++ ) {
    3718:	e1 2c       	mov	r14, r1
    371a:	f1 2c       	mov	r15, r1
    371c:	00 e0       	ldi	r16, 0x00	; 0
    371e:	10 e0       	ldi	r17, 0x00	; 0
				for (uint8_t o=0; o<OW_ROMCODE_SIZE; o++)
				{
					systemID[o] = sensorScan[i*OW_ROMCODE_SIZE+o];
				}

				printf_P(PSTR("Found system id %02X%02X%02X%02X%02X%02X%02X%02X\r\n"),
    3720:	49 ec       	ldi	r20, 0xC9	; 201
    3722:	c4 2e       	mov	r12, r20
    3724:	41 e0       	ldi	r20, 0x01	; 1
    3726:	d4 2e       	mov	r13, r20

		OW_selectPort(1);
        int nSensors = search_sensors(MAXSENSORS);  //Finder alle sensore (op til max)
		mywdt_reset();

		for ( int i=0; i<nSensors; i++ ) {
    3728:	0a 15       	cp	r16, r10
    372a:	1b 05       	cpc	r17, r11
    372c:	0c f0       	brlt	.+2      	; 0x3730 <main+0x376>
    372e:	40 c0       	rjmp	.+128    	; 0x37b0 <main+0x3f6>
			if (sensorScan[i*OW_ROMCODE_SIZE+0] == 0x01)
    3730:	e0 91 08 09 	lds	r30, 0x0908
    3734:	f0 91 09 09 	lds	r31, 0x0909
    3738:	ee 0d       	add	r30, r14
    373a:	ff 1d       	adc	r31, r15
    373c:	80 81       	ld	r24, Z
    373e:	81 30       	cpi	r24, 0x01	; 1
    3740:	89 f5       	brne	.+98     	; 0x37a4 <main+0x3ea>
    3742:	a3 ed       	ldi	r26, 0xD3	; 211
    3744:	b9 e1       	ldi	r27, 0x19	; 25
			{
				for (uint8_t o=0; o<OW_ROMCODE_SIZE; o++)
				{
					systemID[o] = sensorScan[i*OW_ROMCODE_SIZE+o];
    3746:	81 91       	ld	r24, Z+
    3748:	8d 93       	st	X+, r24
		mywdt_reset();

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+0] == 0x01)
			{
				for (uint8_t o=0; o<OW_ROMCODE_SIZE; o++)
    374a:	49 e1       	ldi	r20, 0x19	; 25
    374c:	ab 3d       	cpi	r26, 0xDB	; 219
    374e:	b4 07       	cpc	r27, r20
    3750:	d1 f7       	brne	.-12     	; 0x3746 <main+0x38c>
				{
					systemID[o] = sensorScan[i*OW_ROMCODE_SIZE+o];
				}

				printf_P(PSTR("Found system id %02X%02X%02X%02X%02X%02X%02X%02X\r\n"),
    3752:	80 91 da 19 	lds	r24, 0x19DA
    3756:	1f 92       	push	r1
    3758:	8f 93       	push	r24
    375a:	80 91 d9 19 	lds	r24, 0x19D9
    375e:	1f 92       	push	r1
    3760:	8f 93       	push	r24
    3762:	80 91 d8 19 	lds	r24, 0x19D8
    3766:	1f 92       	push	r1
    3768:	8f 93       	push	r24
    376a:	80 91 d7 19 	lds	r24, 0x19D7
    376e:	1f 92       	push	r1
    3770:	8f 93       	push	r24
    3772:	80 91 d6 19 	lds	r24, 0x19D6
    3776:	1f 92       	push	r1
    3778:	8f 93       	push	r24
    377a:	80 91 d5 19 	lds	r24, 0x19D5
    377e:	1f 92       	push	r1
    3780:	8f 93       	push	r24
    3782:	80 91 d4 19 	lds	r24, 0x19D4
    3786:	1f 92       	push	r1
    3788:	8f 93       	push	r24
    378a:	80 91 d3 19 	lds	r24, 0x19D3
    378e:	1f 92       	push	r1
    3790:	8f 93       	push	r24
    3792:	df 92       	push	r13
    3794:	cf 92       	push	r12
    3796:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
    379a:	0f b6       	in	r0, 0x3f	; 63
    379c:	f8 94       	cli
    379e:	de bf       	out	0x3e, r29	; 62
    37a0:	0f be       	out	0x3f, r0	; 63
    37a2:	cd bf       	out	0x3d, r28	; 61

		OW_selectPort(1);
        int nSensors = search_sensors(MAXSENSORS);  //Finder alle sensore (op til max)
		mywdt_reset();

		for ( int i=0; i<nSensors; i++ ) {
    37a4:	0f 5f       	subi	r16, 0xFF	; 255
    37a6:	1f 4f       	sbci	r17, 0xFF	; 255
    37a8:	98 e0       	ldi	r25, 0x08	; 8
    37aa:	e9 0e       	add	r14, r25
    37ac:	f1 1c       	adc	r15, r1
    37ae:	bc cf       	rjmp	.-136    	; 0x3728 <main+0x36e>
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    37b0:	a8 95       	wdr
			}
		}
		mywdt_reset();
	

	if (systemID[0] == 0)
    37b2:	80 91 d3 19 	lds	r24, 0x19D3
    37b6:	81 11       	cpse	r24, r1
    37b8:	20 c0       	rjmp	.+64     	; 0x37fa <main+0x440>
	{
		printf_P(PSTR("No system id found, add a DS2401 or use old software ***"));
    37ba:	80 e9       	ldi	r24, 0x90	; 144
    37bc:	91 e0       	ldi	r25, 0x01	; 1
    37be:	9f 93       	push	r25
    37c0:	8f 93       	push	r24
    37c2:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>

				systemID[0] = 21;
    37c6:	85 e1       	ldi	r24, 0x15	; 21
    37c8:	80 93 d3 19 	sts	0x19D3, r24
				systemID[1] = 22;
    37cc:	86 e1       	ldi	r24, 0x16	; 22
    37ce:	80 93 d4 19 	sts	0x19D4, r24
				systemID[2] = 23;
    37d2:	87 e1       	ldi	r24, 0x17	; 23
    37d4:	80 93 d5 19 	sts	0x19D5, r24
				systemID[3] = 24;
    37d8:	88 e1       	ldi	r24, 0x18	; 24
    37da:	80 93 d6 19 	sts	0x19D6, r24
				systemID[4] = 25;
    37de:	89 e1       	ldi	r24, 0x19	; 25
    37e0:	80 93 d7 19 	sts	0x19D7, r24
				systemID[5] = 26;
    37e4:	8a e1       	ldi	r24, 0x1A	; 26
    37e6:	80 93 d8 19 	sts	0x19D8, r24
				systemID[6] = 27;
    37ea:	8b e1       	ldi	r24, 0x1B	; 27
    37ec:	80 93 d9 19 	sts	0x19D9, r24
				systemID[7] = 28;
    37f0:	8c e1       	ldi	r24, 0x1C	; 28
    37f2:	80 93 da 19 	sts	0x19DA, r24
    37f6:	0f 90       	pop	r0
    37f8:	0f 90       	pop	r0
    37fa:	e4 ed       	ldi	r30, 0xD4	; 212
    37fc:	f9 e1       	ldi	r31, 0x19	; 25
    37fe:	a8 e2       	ldi	r26, 0x28	; 40
    3800:	b1 e0       	ldi	r27, 0x01	; 1
	}

	for (uint8_t o=1; o<=5; o++)
	{
		mymac[o] = systemID[o];
    3802:	81 91       	ld	r24, Z+
    3804:	8d 93       	st	X+, r24
				systemID[5] = 26;
				systemID[6] = 27;
				systemID[7] = 28;
	}

	for (uint8_t o=1; o<=5; o++)
    3806:	29 e1       	ldi	r18, 0x19	; 25
    3808:	e9 3d       	cpi	r30, 0xD9	; 217
    380a:	f2 07       	cpc	r31, r18
    380c:	d1 f7       	brne	.-12     	; 0x3802 <main+0x448>
	{
		mymac[o] = systemID[o];
	}

	if (hasLcd > 0 && hasLcd != 255)
    380e:	80 91 85 05 	lds	r24, 0x0585
    3812:	81 50       	subi	r24, 0x01	; 1
    3814:	8e 3f       	cpi	r24, 0xFE	; 254
    3816:	08 f0       	brcs	.+2      	; 0x381a <main+0x460>
    3818:	58 c0       	rjmp	.+176    	; 0x38ca <main+0x510>
	{
		LCDsetCursor(1, 0);
    381a:	60 e0       	ldi	r22, 0x00	; 0
    381c:	81 e0       	ldi	r24, 0x01	; 1
    381e:	0e 94 8d 37 	call	0x6f1a	; 0x6f1a <LCDsetCursor>
		char str[25];
		sprintf(str, "ID: %02X%02X%02X%02X%02X%02X%02X%02X",
    3822:	80 91 da 19 	lds	r24, 0x19DA
    3826:	1f 92       	push	r1
    3828:	8f 93       	push	r24
    382a:	80 91 d9 19 	lds	r24, 0x19D9
    382e:	1f 92       	push	r1
    3830:	8f 93       	push	r24
    3832:	80 91 d8 19 	lds	r24, 0x19D8
    3836:	1f 92       	push	r1
    3838:	8f 93       	push	r24
    383a:	80 91 d7 19 	lds	r24, 0x19D7
    383e:	1f 92       	push	r1
    3840:	8f 93       	push	r24
    3842:	80 91 d6 19 	lds	r24, 0x19D6
    3846:	1f 92       	push	r1
    3848:	8f 93       	push	r24
    384a:	80 91 d5 19 	lds	r24, 0x19D5
    384e:	1f 92       	push	r1
    3850:	8f 93       	push	r24
    3852:	80 91 d4 19 	lds	r24, 0x19D4
    3856:	1f 92       	push	r1
    3858:	8f 93       	push	r24
    385a:	80 91 d3 19 	lds	r24, 0x19D3
    385e:	1f 92       	push	r1
    3860:	8f 93       	push	r24
    3862:	84 e7       	ldi	r24, 0x74	; 116
    3864:	91 e0       	ldi	r25, 0x01	; 1
    3866:	9f 93       	push	r25
    3868:	8f 93       	push	r24
    386a:	8e 01       	movw	r16, r28
    386c:	0f 5f       	subi	r16, 0xFF	; 255
    386e:	1f 4f       	sbci	r17, 0xFF	; 255
    3870:	1f 93       	push	r17
    3872:	0f 93       	push	r16
    3874:	0e 94 ec 3e 	call	0x7dd8	; 0x7dd8 <sprintf>
				systemID[4],
				systemID[5],
				systemID[6],
				systemID[7]);

		LCDwrite(str, 0);
    3878:	60 e0       	ldi	r22, 0x00	; 0
    387a:	c8 01       	movw	r24, r16
    387c:	0e 94 aa 37 	call	0x6f54	; 0x6f54 <LCDwrite>

		LCDsetCursor(2, 0);
    3880:	60 e0       	ldi	r22, 0x00	; 0
    3882:	82 e0       	ldi	r24, 0x02	; 2
    3884:	0e 94 8d 37 	call	0x6f1a	; 0x6f1a <LCDsetCursor>
		sprintf(str, "IP: %u.%u.%u.%u", myip[0],myip[1],myip[2],myip[3]);
    3888:	80 91 22 01 	lds	r24, 0x0122
    388c:	1f 92       	push	r1
    388e:	8f 93       	push	r24
    3890:	80 91 21 01 	lds	r24, 0x0121
    3894:	1f 92       	push	r1
    3896:	8f 93       	push	r24
    3898:	80 91 20 01 	lds	r24, 0x0120
    389c:	1f 92       	push	r1
    389e:	8f 93       	push	r24
    38a0:	80 91 1f 01 	lds	r24, 0x011F
    38a4:	1f 92       	push	r1
    38a6:	8f 93       	push	r24
    38a8:	89 e9       	ldi	r24, 0x99	; 153
    38aa:	91 e0       	ldi	r25, 0x01	; 1
    38ac:	9f 93       	push	r25
    38ae:	8f 93       	push	r24
    38b0:	1f 93       	push	r17
    38b2:	0f 93       	push	r16
    38b4:	0e 94 ec 3e 	call	0x7dd8	; 0x7dd8 <sprintf>
		LCDwrite(str, 0);
    38b8:	0f b6       	in	r0, 0x3f	; 63
    38ba:	f8 94       	cli
    38bc:	de bf       	out	0x3e, r29	; 62
    38be:	0f be       	out	0x3f, r0	; 63
    38c0:	cd bf       	out	0x3d, r28	; 61
    38c2:	60 e0       	ldi	r22, 0x00	; 0
    38c4:	c8 01       	movw	r24, r16
    38c6:	0e 94 aa 37 	call	0x6f54	; 0x6f54 <LCDwrite>
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    38ca:	a8 95       	wdr
    38cc:	a8 95       	wdr
		_delay_ms(250);
*/

		mywdt_reset();

        enc28j60Init(mymac);
    38ce:	87 e2       	ldi	r24, 0x27	; 39
    38d0:	91 e0       	ldi	r25, 0x01	; 1
    38d2:	0e 94 a0 0d 	call	0x1b40	; 0x1b40 <enc28j60Init>
        enc28j60clkout(0);
    38d6:	80 e0       	ldi	r24, 0x00	; 0
    38d8:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <enc28j60clkout>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    38dc:	80 e0       	ldi	r24, 0x00	; 0
    38de:	8a 95       	dec	r24
    38e0:	f1 f7       	brne	.-4      	; 0x38de <main+0x524>
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    38e2:	a8 95       	wdr
        enc28j60clkout(0);
        _delay_loop_1(0); // 60us

		mywdt_reset();

        initTimer();
    38e4:	0e 94 7b 24 	call	0x48f6	; 0x48f6 <initTimer>
	  	ADC_Init();
    38e8:	0e 94 82 23 	call	0x4704	; 0x4704 <ADC_Init>
		twiInit(10); //200ms timeout
    38ec:	8a e0       	ldi	r24, 0x0A	; 10
    38ee:	0e 94 70 23 	call	0x46e0	; 0x46e0 <twiInit>
		loadSimpleSensorData();
    38f2:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <loadSimpleSensorData>
    38f6:	e4 eb       	ldi	r30, 0xB4	; 180
    38f8:	f5 e0       	ldi	r31, 0x05	; 5
    38fa:	82 e0       	ldi	r24, 0x02	; 2
    38fc:	90 e0       	ldi	r25, 0x00	; 0
			{
				//output
				SETBIT(DDRC, (i-6));
			} else {
				//input
				CLEARBIT(DDRC, (i-6));
    38fe:	21 e0       	ldi	r18, 0x01	; 1
    3900:	30 e0       	ldi	r19, 0x00	; 0
		loadSimpleSensorData();

		//Set digital pins based on selections...
		for (uint8_t i=8; i<=11; i++)
		{
			if (simpleSensorTypes[i] == 0)
    3902:	41 91       	ld	r20, Z+
			{
				//output
				SETBIT(DDRC, (i-6));
    3904:	67 b1       	in	r22, 0x07	; 7
		loadSimpleSensorData();

		//Set digital pins based on selections...
		for (uint8_t i=8; i<=11; i++)
		{
			if (simpleSensorTypes[i] == 0)
    3906:	41 11       	cpse	r20, r1
    3908:	09 c0       	rjmp	.+18     	; 0x391c <main+0x562>
			{
				//output
				SETBIT(DDRC, (i-6));
    390a:	a9 01       	movw	r20, r18
    390c:	08 2e       	mov	r0, r24
    390e:	01 c0       	rjmp	.+2      	; 0x3912 <main+0x558>
    3910:	44 0f       	add	r20, r20
    3912:	0a 94       	dec	r0
    3914:	ea f7       	brpl	.-6      	; 0x3910 <main+0x556>
    3916:	64 2b       	or	r22, r20
    3918:	67 b9       	out	0x07, r22	; 7
    391a:	09 c0       	rjmp	.+18     	; 0x392e <main+0x574>
			} else {
				//input
				CLEARBIT(DDRC, (i-6));
    391c:	a9 01       	movw	r20, r18
    391e:	08 2e       	mov	r0, r24
    3920:	01 c0       	rjmp	.+2      	; 0x3924 <main+0x56a>
    3922:	44 0f       	add	r20, r20
    3924:	0a 94       	dec	r0
    3926:	ea f7       	brpl	.-6      	; 0x3922 <main+0x568>
    3928:	40 95       	com	r20
    392a:	46 23       	and	r20, r22
    392c:	47 b9       	out	0x07, r20	; 7
    392e:	01 96       	adiw	r24, 0x01	; 1
	  	ADC_Init();
		twiInit(10); //200ms timeout
		loadSimpleSensorData();

		//Set digital pins based on selections...
		for (uint8_t i=8; i<=11; i++)
    3930:	86 30       	cpi	r24, 0x06	; 6
    3932:	91 05       	cpc	r25, r1
    3934:	31 f7       	brne	.-52     	; 0x3902 <main+0x548>
				//input
				CLEARBIT(DDRC, (i-6));
			}
		}

       sei();
    3936:	78 94       	sei
        /* Magjack leds configuration, see enc28j60 datasheet, page 11 */
        // LEDB=yellow LEDA=green
        //
        // 0x476 is PHLCON LEDA=links status, LEDB=receive/transmit
        // enc28j60PhyWrite(PHLCON,0b0000 0100 0111 01 10);
        enc28j60PhyWrite(PHLCON,0x476);
    3938:	66 e7       	ldi	r22, 0x76	; 118
    393a:	74 e0       	ldi	r23, 0x04	; 4
    393c:	84 e1       	ldi	r24, 0x14	; 20
    393e:	0e 94 77 0d 	call	0x1aee	; 0x1aee <enc28j60PhyWrite>
       
        //init the web server ethernet/ip layer:
        init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    3942:	40 e5       	ldi	r20, 0x50	; 80
    3944:	50 e0       	ldi	r21, 0x00	; 0
    3946:	6f e1       	ldi	r22, 0x1F	; 31
    3948:	71 e0       	ldi	r23, 0x01	; 1
    394a:	87 e2       	ldi	r24, 0x27	; 39
    394c:	91 e0       	ldi	r25, 0x01	; 1
    394e:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <init_ip_arp_udp_tcp>
        // init the web client:
        client_set_gwip(gwip);  // e.g internal IP of dsl router
    3952:	83 e2       	ldi	r24, 0x23	; 35
    3954:	91 e0       	ldi	r25, 0x01	; 1
    3956:	0e 94 b5 14 	call	0x296a	; 0x296a <client_set_gwip>
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    395a:	a8 95       	wdr
        //init the web server ethernet/ip layer:
        init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
        // init the web client:
        client_set_gwip(gwip);  // e.g internal IP of dsl router
		mywdt_reset();
		printf("ENC version %u\r\n",enc28j60getrev());
    395c:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <enc28j60getrev>
    3960:	1f 92       	push	r1
    3962:	8f 93       	push	r24
    3964:	89 ea       	ldi	r24, 0xA9	; 169
    3966:	91 e0       	ldi	r25, 0x01	; 1
    3968:	9f 93       	push	r25
    396a:	8f 93       	push	r24
    396c:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    3970:	a8 95       	wdr
        // init the web client:
        client_set_gwip(gwip);  // e.g internal IP of dsl router
		mywdt_reset();
		printf("ENC version %u\r\n",enc28j60getrev());
		mywdt_reset();
		initTimedEvents();
    3972:	0e 94 f2 26 	call	0x4de4	; 0x4de4 <initTimedEvents>

		mywdt_sleep(500);
    3976:	84 ef       	ldi	r24, 0xF4	; 244
    3978:	91 e0       	ldi	r25, 0x01	; 1
    397a:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <mywdt_sleep>
    397e:	0f 90       	pop	r0
    3980:	0f 90       	pop	r0
    3982:	0f 90       	pop	r0
    3984:	0f 90       	pop	r0
			simpleSensorValues[i] = readOversampledAdc(i);
		}

		if (simpleSensorTypes[i] == TYPE_DIGIN)  //DIGITAL
		{
			if (GETBIT(PINA, i) > 0)
    3986:	cc 24       	eor	r12, r12
    3988:	c3 94       	inc	r12
    398a:	d1 2c       	mov	r13, r1
			}

			if (tickDiffS(timer_sendOWSensors) >= 30 && start_web_client==0)
			{
				timer_sendOWSensors = tickS;
				start_web_client = 1;
    398c:	99 24       	eor	r9, r9
    398e:	93 94       	inc	r9
static void mywdt_reset()
{
	#if SBNG_TARGET == 50
		FLIPBIT(PORTB, 2);
	#endif
	wdt_reset();
    3990:	a8 95       	wdr
			}
*/
			mywdt_reset();
			
			//Hvert 5. sekund opdatere vi simple sensors, de sendes hvert 45. sekund nr web_client er fri
			if (tickDiffS(timerSimple) >= 2)
    3992:	80 91 90 05 	lds	r24, 0x0590
    3996:	90 91 91 05 	lds	r25, 0x0591
    399a:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    399e:	02 97       	sbiw	r24, 0x02	; 2
    39a0:	a0 f4       	brcc	.+40     	; 0x39ca <main+0x610>
			{
				timerSimple = tickS;
				updateSimpleSensors();
			}

			if (tickDiffS(timerRemoteIO) >= 1)
    39a2:	80 91 86 05 	lds	r24, 0x0586
    39a6:	90 91 87 05 	lds	r25, 0x0587
    39aa:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    39ae:	89 2b       	or	r24, r25
    39b0:	09 f4       	brne	.+2      	; 0x39b4 <main+0x5fa>
    39b2:	80 c0       	rjmp	.+256    	; 0x3ab4 <main+0x6fa>
				#if SBNG_TARGET == 50
					if (alarmTimeout > 0)
						alarmTimeout--;
				#endif

				timerRemoteIO = tickS;
    39b4:	80 91 2d 01 	lds	r24, 0x012D
    39b8:	90 91 2e 01 	lds	r25, 0x012E
    39bc:	90 93 87 05 	sts	0x0587, r25
    39c0:	80 93 86 05 	sts	0x0586, r24
				checkTimedEvents();
    39c4:	0e 94 ff 26 	call	0x4dfe	; 0x4dfe <checkTimedEvents>
    39c8:	75 c0       	rjmp	.+234    	; 0x3ab4 <main+0x6fa>
			mywdt_reset();
			
			//Hvert 5. sekund opdatere vi simple sensors, de sendes hvert 45. sekund nr web_client er fri
			if (tickDiffS(timerSimple) >= 2)
			{
				timerSimple = tickS;
    39ca:	80 91 2d 01 	lds	r24, 0x012D
    39ce:	90 91 2e 01 	lds	r25, 0x012E
    39d2:	90 93 91 05 	sts	0x0591, r25
    39d6:	80 93 90 05 	sts	0x0590, r24
    39da:	9c ea       	ldi	r25, 0xAC	; 172
    39dc:	a9 2e       	mov	r10, r25
    39de:	95 e0       	ldi	r25, 0x05	; 5
    39e0:	b9 2e       	mov	r11, r25
    39e2:	2a e0       	ldi	r18, 0x0A	; 10
    39e4:	e2 2e       	mov	r14, r18
    39e6:	29 e1       	ldi	r18, 0x19	; 25
    39e8:	f2 2e       	mov	r15, r18
    39ea:	00 e0       	ldi	r16, 0x00	; 0
    39ec:	10 e0       	ldi	r17, 0x00	; 0
	//Send ADC+digital pins
	//ADC pins
	for (uint8_t i=0; i<=7; i++)
	{
		uint8_t eepos = 100 + i;
		simpleSensorTypes[i] = eepromReadByte(eepos);
    39ee:	80 2e       	mov	r8, r16
    39f0:	c8 01       	movw	r24, r16
    39f2:	8c 59       	subi	r24, 0x9C	; 156
    39f4:	9f 4f       	sbci	r25, 0xFF	; 255
    39f6:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    39fa:	35 01       	movw	r6, r10
    39fc:	f5 01       	movw	r30, r10
    39fe:	80 83       	st	Z, r24

		if (simpleSensorTypes[i] == TYPE_ADC)  //ADC
    3a00:	81 30       	cpi	r24, 0x01	; 1
    3a02:	31 f4       	brne	.+12     	; 0x3a10 <main+0x656>
		{
			simpleSensorValues[i] = readOversampledAdc(i);
    3a04:	80 2f       	mov	r24, r16
    3a06:	0e 94 9d 23 	call	0x473a	; 0x473a <readOversampledAdc>
    3a0a:	f7 01       	movw	r30, r14
    3a0c:	91 83       	std	Z+1, r25	; 0x01
    3a0e:	80 83       	st	Z, r24
    3a10:	ff ef       	ldi	r31, 0xFF	; 255
    3a12:	af 1a       	sub	r10, r31
    3a14:	bf 0a       	sbc	r11, r31
		}

		if (simpleSensorTypes[i] == TYPE_DIGIN)  //DIGITAL
    3a16:	f3 01       	movw	r30, r6
    3a18:	80 81       	ld	r24, Z
    3a1a:	82 30       	cpi	r24, 0x02	; 2
    3a1c:	91 f4       	brne	.+36     	; 0x3a42 <main+0x688>
		{
			if (GETBIT(PINA, i) > 0)
    3a1e:	20 b1       	in	r18, 0x00	; 0
    3a20:	c6 01       	movw	r24, r12
    3a22:	02 c0       	rjmp	.+4      	; 0x3a28 <main+0x66e>
    3a24:	88 0f       	add	r24, r24
    3a26:	99 1f       	adc	r25, r25
    3a28:	8a 94       	dec	r8
    3a2a:	e2 f7       	brpl	.-8      	; 0x3a24 <main+0x66a>
    3a2c:	30 e0       	ldi	r19, 0x00	; 0
    3a2e:	82 23       	and	r24, r18
    3a30:	93 23       	and	r25, r19
				simpleSensorValues[i] = 1;
    3a32:	f7 01       	movw	r30, r14
			simpleSensorValues[i] = readOversampledAdc(i);
		}

		if (simpleSensorTypes[i] == TYPE_DIGIN)  //DIGITAL
		{
			if (GETBIT(PINA, i) > 0)
    3a34:	89 2b       	or	r24, r25
    3a36:	19 f0       	breq	.+6      	; 0x3a3e <main+0x684>
				simpleSensorValues[i] = 1;
    3a38:	d1 82       	std	Z+1, r13	; 0x01
    3a3a:	c0 82       	st	Z, r12
    3a3c:	02 c0       	rjmp	.+4      	; 0x3a42 <main+0x688>
			else
				simpleSensorValues[i] = 0;
    3a3e:	11 82       	std	Z+1, r1	; 0x01
    3a40:	10 82       	st	Z, r1
    3a42:	0f 5f       	subi	r16, 0xFF	; 255
    3a44:	1f 4f       	sbci	r17, 0xFF	; 255
    3a46:	f2 e0       	ldi	r31, 0x02	; 2
    3a48:	ef 0e       	add	r14, r31
    3a4a:	f1 1c       	adc	r15, r1

static void updateSimpleSensors(void)
{
	//Send ADC+digital pins
	//ADC pins
	for (uint8_t i=0; i<=7; i++)
    3a4c:	08 30       	cpi	r16, 0x08	; 8
    3a4e:	11 05       	cpc	r17, r1
    3a50:	71 f6       	brne	.-100    	; 0x39ee <main+0x634>
    3a52:	0a e1       	ldi	r16, 0x1A	; 26
    3a54:	e0 2e       	mov	r14, r16
    3a56:	09 e1       	ldi	r16, 0x19	; 25
    3a58:	f0 2e       	mov	r15, r16
    3a5a:	84 eb       	ldi	r24, 0xB4	; 180
    3a5c:	a8 2e       	mov	r10, r24
    3a5e:	85 e0       	ldi	r24, 0x05	; 5
    3a60:	b8 2e       	mov	r11, r24
    3a62:	0e e6       	ldi	r16, 0x6E	; 110
    3a64:	10 e0       	ldi	r17, 0x00	; 0

	//Digital pins
	for (uint8_t i=0; i<=3; i++)
	{
		uint8_t eepos = 110 + i;
		simpleSensorTypes[i+8] = eepromReadByte(eepos);
    3a66:	c8 01       	movw	r24, r16
    3a68:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3a6c:	f5 01       	movw	r30, r10
    3a6e:	81 93       	st	Z+, r24
    3a70:	5f 01       	movw	r10, r30

		if (simpleSensorTypes[i+8] == TYPE_DIGIN || simpleSensorTypes[i+8] == TYPE_DIGOUT)  //DIGITAL
    3a72:	8d 7f       	andi	r24, 0xFD	; 253
    3a74:	b1 f4       	brne	.+44     	; 0x3aa2 <main+0x6e8>
		{
		  	//Digital pins is C2-5
			if (GETBIT(PINC, (i+2)) > 0)
    3a76:	26 b1       	in	r18, 0x06	; 6
    3a78:	c8 01       	movw	r24, r16
    3a7a:	8c 56       	subi	r24, 0x6C	; 108
    3a7c:	91 09       	sbc	r25, r1
    3a7e:	a6 01       	movw	r20, r12
    3a80:	02 c0       	rjmp	.+4      	; 0x3a86 <main+0x6cc>
    3a82:	44 0f       	add	r20, r20
    3a84:	55 1f       	adc	r21, r21
    3a86:	8a 95       	dec	r24
    3a88:	e2 f7       	brpl	.-8      	; 0x3a82 <main+0x6c8>
    3a8a:	ca 01       	movw	r24, r20
    3a8c:	30 e0       	ldi	r19, 0x00	; 0
    3a8e:	82 23       	and	r24, r18
    3a90:	93 23       	and	r25, r19
				simpleSensorValues[i+8] = 1;
    3a92:	f7 01       	movw	r30, r14
		simpleSensorTypes[i+8] = eepromReadByte(eepos);

		if (simpleSensorTypes[i+8] == TYPE_DIGIN || simpleSensorTypes[i+8] == TYPE_DIGOUT)  //DIGITAL
		{
		  	//Digital pins is C2-5
			if (GETBIT(PINC, (i+2)) > 0)
    3a94:	89 2b       	or	r24, r25
    3a96:	19 f0       	breq	.+6      	; 0x3a9e <main+0x6e4>
				simpleSensorValues[i+8] = 1;
    3a98:	d1 82       	std	Z+1, r13	; 0x01
    3a9a:	c0 82       	st	Z, r12
    3a9c:	02 c0       	rjmp	.+4      	; 0x3aa2 <main+0x6e8>
			else
				simpleSensorValues[i+8] = 0;
    3a9e:	11 82       	std	Z+1, r1	; 0x01
    3aa0:	10 82       	st	Z, r1
    3aa2:	0f 5f       	subi	r16, 0xFF	; 255
    3aa4:	1f 4f       	sbci	r17, 0xFF	; 255
    3aa6:	f2 e0       	ldi	r31, 0x02	; 2
    3aa8:	ef 0e       	add	r14, r31
    3aaa:	f1 1c       	adc	r15, r1
				simpleSensorValues[i] = 0;
		}
	}

	//Digital pins
	for (uint8_t i=0; i<=3; i++)
    3aac:	02 37       	cpi	r16, 0x72	; 114
    3aae:	11 05       	cpc	r17, r1
    3ab0:	d1 f6       	brne	.-76     	; 0x3a66 <main+0x6ac>
    3ab2:	77 cf       	rjmp	.-274    	; 0x39a2 <main+0x5e8>

				timerRemoteIO = tickS;
				checkTimedEvents();
			}
	
			if (tickDiffS(timerOW) >= 2)
    3ab4:	80 91 92 05 	lds	r24, 0x0592
    3ab8:	90 91 93 05 	lds	r25, 0x0593
    3abc:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    3ac0:	02 97       	sbiw	r24, 0x02	; 2
    3ac2:	50 f0       	brcs	.+20     	; 0x3ad8 <main+0x71e>
			{
 				timerOW = tickS;
    3ac4:	80 91 2d 01 	lds	r24, 0x012D
    3ac8:	90 91 2e 01 	lds	r25, 0x012E
    3acc:	90 93 93 05 	sts	0x0593, r25
    3ad0:	80 93 92 05 	sts	0x0592, r24
				updateOWSensors();
    3ad4:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <updateOWSensors>
			}

			if (tickDiffS(timer_sendOWSensors) >= 30 && start_web_client==0)
    3ad8:	80 91 8a 05 	lds	r24, 0x058A
    3adc:	90 91 8b 05 	lds	r25, 0x058B
    3ae0:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    3ae4:	4e 97       	sbiw	r24, 0x1e	; 30
    3ae6:	a0 f0       	brcs	.+40     	; 0x3b10 <main+0x756>
    3ae8:	80 91 a2 05 	lds	r24, 0x05A2
    3aec:	81 11       	cpse	r24, r1
    3aee:	10 c0       	rjmp	.+32     	; 0x3b10 <main+0x756>
			{
				timer_sendOWSensors = tickS;
    3af0:	80 91 2d 01 	lds	r24, 0x012D
    3af4:	90 91 2e 01 	lds	r25, 0x012E
    3af8:	90 93 8b 05 	sts	0x058B, r25
    3afc:	80 93 8a 05 	sts	0x058A, r24
				start_web_client = 1;
    3b00:	90 92 a2 05 	sts	0x05A2, r9
				hasLcd = eepromReadByte(50);
    3b04:	82 e3       	ldi	r24, 0x32	; 50
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    3b0c:	80 93 85 05 	sts	0x0585, r24
			}

			if (tickDiffS(timer_lcd) >= 1)
    3b10:	80 91 8e 05 	lds	r24, 0x058E
    3b14:	90 91 8f 05 	lds	r25, 0x058F
    3b18:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    3b1c:	89 2b       	or	r24, r25
    3b1e:	79 f0       	breq	.+30     	; 0x3b3e <main+0x784>
			{
				timer_lcd = tickS;
    3b20:	80 91 2d 01 	lds	r24, 0x012D
    3b24:	90 91 2e 01 	lds	r25, 0x012E
    3b28:	90 93 8f 05 	sts	0x058F, r25
    3b2c:	80 93 8e 05 	sts	0x058E, r24
				if (hasLcd > 0 && hasLcd != 255)
    3b30:	80 91 85 05 	lds	r24, 0x0585
    3b34:	81 50       	subi	r24, 0x01	; 1
    3b36:	8e 3f       	cpi	r24, 0xFE	; 254
    3b38:	10 f4       	brcc	.+4      	; 0x3b3e <main+0x784>
					lcd_update();
    3b3a:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <lcd_update>
			}

			if (tickDiffS(timer_eeprom) >= 1800) //every 30min saves changes to eeprom from counters
    3b3e:	80 91 8c 05 	lds	r24, 0x058C
    3b42:	90 91 8d 05 	lds	r25, 0x058D
    3b46:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    3b4a:	88 30       	cpi	r24, 0x08	; 8
    3b4c:	97 40       	sbci	r25, 0x07	; 7
    3b4e:	a8 f4       	brcc	.+42     	; 0x3b7a <main+0x7c0>
			{
				timer_eeprom = tickS;
				timedSaveEeprom();
			}

			if (tickDiffS(timer_ioalarm) >= 5)
    3b50:	80 91 88 05 	lds	r24, 0x0588
    3b54:	90 91 89 05 	lds	r25, 0x0589
    3b58:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    3b5c:	05 97       	sbiw	r24, 0x05	; 5
    3b5e:	70 f1       	brcs	.+92     	; 0x3bbc <main+0x802>
			{
				timer_ioalarm = tickS;
    3b60:	80 91 2d 01 	lds	r24, 0x012D
    3b64:	90 91 2e 01 	lds	r25, 0x012E
    3b68:	90 93 89 05 	sts	0x0589, r25
    3b6c:	80 93 88 05 	sts	0x0588, r24
				timedAlarmCheck();
    3b70:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <timedAlarmCheck>
				getDHTData();
    3b74:	0e 94 77 18 	call	0x30ee	; 0x30ee <getDHTData>
    3b78:	21 c0       	rjmp	.+66     	; 0x3bbc <main+0x802>
					lcd_update();
			}

			if (tickDiffS(timer_eeprom) >= 1800) //every 30min saves changes to eeprom from counters
			{
				timer_eeprom = tickS;
    3b7a:	80 91 2d 01 	lds	r24, 0x012D
    3b7e:	90 91 2e 01 	lds	r25, 0x012E
    3b82:	90 93 8d 05 	sts	0x058D, r25
    3b86:	80 93 8c 05 	sts	0x058C, r24
    3b8a:	1c ea       	ldi	r17, 0xAC	; 172
    3b8c:	e1 2e       	mov	r14, r17
    3b8e:	15 e0       	ldi	r17, 0x05	; 5
    3b90:	f1 2e       	mov	r15, r17
    3b92:	0e e6       	ldi	r16, 0x6E	; 110
    3b94:	10 e0       	ldi	r17, 0x00	; 0
//Called every 30minutes and only saved if theres any changes (100000 / 30minutes worst case = 5years)
static void timedSaveEeprom(void)
{
	for (uint8_t i=0; i<8; i++)
	{
		if (simpleSensorTypes[i] == 3) //counter
    3b96:	f7 01       	movw	r30, r14
    3b98:	81 91       	ld	r24, Z+
    3b9a:	7f 01       	movw	r14, r30
    3b9c:	83 30       	cpi	r24, 0x03	; 3
    3b9e:	41 f4       	brne	.+16     	; 0x3bb0 <main+0x7f6>
    3ba0:	f8 01       	movw	r30, r16
    3ba2:	e4 56       	subi	r30, 0x64	; 100
    3ba4:	f7 4e       	sbci	r31, 0xE7	; 231
		{
			uint8_t pos = 110 + (i*2);
			//save tjekker selv om det er ndvendigt
			eepromSaveWord(pos, simpleSensorValues[i]);
    3ba6:	60 81       	ld	r22, Z
    3ba8:	71 81       	ldd	r23, Z+1	; 0x01
    3baa:	c8 01       	movw	r24, r16
    3bac:	0e 94 38 21 	call	0x4270	; 0x4270 <eepromSaveWord>
    3bb0:	0e 5f       	subi	r16, 0xFE	; 254
    3bb2:	1f 4f       	sbci	r17, 0xFF	; 255
}

//Called every 30minutes and only saved if theres any changes (100000 / 30minutes worst case = 5years)
static void timedSaveEeprom(void)
{
	for (uint8_t i=0; i<8; i++)
    3bb4:	0e 37       	cpi	r16, 0x7E	; 126
    3bb6:	11 05       	cpc	r17, r1
    3bb8:	71 f7       	brne	.-36     	; 0x3b96 <main+0x7dc>
    3bba:	ca cf       	rjmp	.-108    	; 0x3b50 <main+0x796>
				timer_ioalarm = tickS;
				timedAlarmCheck();
				getDHTData();
			}

			handle_net();
    3bbc:	0e 94 d1 32 	call	0x65a2	; 0x65a2 <handle_net>
        }
    3bc0:	e7 ce       	rjmp	.-562    	; 0x3990 <main+0x5d6>

00003bc2 <updateCounters>:
	}
}

//Called every 20ms
void updateCounters(void)
{
    3bc2:	ef 92       	push	r14
    3bc4:	ff 92       	push	r15
    3bc6:	1f 93       	push	r17
    3bc8:	cf 93       	push	r28
    3bca:	df 93       	push	r29
    3bcc:	cc ea       	ldi	r28, 0xAC	; 172
    3bce:	d5 e0       	ldi	r29, 0x05	; 5
    3bd0:	e4 ea       	ldi	r30, 0xA4	; 164
    3bd2:	f8 e0       	ldi	r31, 0x08	; 8
    3bd4:	aa e0       	ldi	r26, 0x0A	; 10
    3bd6:	b9 e1       	ldi	r27, 0x19	; 25
    3bd8:	80 e0       	ldi	r24, 0x00	; 0
    3bda:	90 e0       	ldi	r25, 0x00	; 0
				//and debounce is not set
				if (simpleSensorDebounce[i] == 0)
				{
					//Update counter
					simpleSensorValues[i]++;
					simpleSensorDebounce[i] = 1;
    3bdc:	11 e0       	ldi	r17, 0x01	; 1
	for (uint8_t i=0; i<12; i++)
	{
		if (simpleSensorTypes[i] == 3)
		{
			//Check if pin is high
			if ( (i >= 8 && GETBIT(PINC,(i-6))>0) || (i < 8 && GETBIT(PINA,i)>0))
    3bde:	41 e0       	ldi	r20, 0x01	; 1
    3be0:	50 e0       	ldi	r21, 0x00	; 0
			CLEARBIT(PORTC, 7);
	#endif

	for (uint8_t i=0; i<12; i++)
	{
		if (simpleSensorTypes[i] == 3)
    3be2:	28 2f       	mov	r18, r24
    3be4:	39 91       	ld	r19, Y+
    3be6:	33 30       	cpi	r19, 0x03	; 3
    3be8:	11 f5       	brne	.+68     	; 0x3c2e <updateCounters+0x6c>
		{
			//Check if pin is high
			if ( (i >= 8 && GETBIT(PINC,(i-6))>0) || (i < 8 && GETBIT(PINA,i)>0))
    3bea:	88 30       	cpi	r24, 0x08	; 8
    3bec:	28 f0       	brcs	.+10     	; 0x3bf8 <updateCounters+0x36>
    3bee:	66 b1       	in	r22, 0x06	; 6
    3bf0:	9c 01       	movw	r18, r24
    3bf2:	26 50       	subi	r18, 0x06	; 6
    3bf4:	31 09       	sbc	r19, r1
    3bf6:	01 c0       	rjmp	.+2      	; 0x3bfa <updateCounters+0x38>
    3bf8:	60 b1       	in	r22, 0x00	; 0
    3bfa:	7a 01       	movw	r14, r20
    3bfc:	02 c0       	rjmp	.+4      	; 0x3c02 <updateCounters+0x40>
    3bfe:	ee 0c       	add	r14, r14
    3c00:	ff 1c       	adc	r15, r15
    3c02:	2a 95       	dec	r18
    3c04:	e2 f7       	brpl	.-8      	; 0x3bfe <updateCounters+0x3c>
    3c06:	97 01       	movw	r18, r14
    3c08:	70 e0       	ldi	r23, 0x00	; 0
    3c0a:	26 23       	and	r18, r22
    3c0c:	37 23       	and	r19, r23
    3c0e:	23 2b       	or	r18, r19
    3c10:	69 f0       	breq	.+26     	; 0x3c2c <updateCounters+0x6a>
			{
				//and debounce is not set
				if (simpleSensorDebounce[i] == 0)
    3c12:	20 81       	ld	r18, Z
    3c14:	21 11       	cpse	r18, r1
    3c16:	0b c0       	rjmp	.+22     	; 0x3c2e <updateCounters+0x6c>
				{
					//Update counter
					simpleSensorValues[i]++;
    3c18:	2d 91       	ld	r18, X+
    3c1a:	3c 91       	ld	r19, X
    3c1c:	11 97       	sbiw	r26, 0x01	; 1
    3c1e:	2f 5f       	subi	r18, 0xFF	; 255
    3c20:	3f 4f       	sbci	r19, 0xFF	; 255
    3c22:	11 96       	adiw	r26, 0x01	; 1
    3c24:	3c 93       	st	X, r19
    3c26:	2e 93       	st	-X, r18
					simpleSensorDebounce[i] = 1;
    3c28:	10 83       	st	Z, r17
    3c2a:	01 c0       	rjmp	.+2      	; 0x3c2e <updateCounters+0x6c>
//					printf("Counter for %u incremented to %u\r\n",i,simpleSensorValues[i]);
				}
			} else {
				simpleSensorDebounce[i] = 0;
    3c2c:	10 82       	st	Z, r1
    3c2e:	01 96       	adiw	r24, 0x01	; 1
    3c30:	31 96       	adiw	r30, 0x01	; 1
    3c32:	12 96       	adiw	r26, 0x02	; 2
			SETBIT(PORTC, 7);
		else
			CLEARBIT(PORTC, 7);
	#endif

	for (uint8_t i=0; i<12; i++)
    3c34:	8c 30       	cpi	r24, 0x0C	; 12
    3c36:	91 05       	cpc	r25, r1
    3c38:	a1 f6       	brne	.-88     	; 0x3be2 <updateCounters+0x20>
			} else {
				simpleSensorDebounce[i] = 0;
			}
		}
	}
}
    3c3a:	df 91       	pop	r29
    3c3c:	cf 91       	pop	r28
    3c3e:	1f 91       	pop	r17
    3c40:	ff 90       	pop	r15
    3c42:	ef 90       	pop	r14
    3c44:	08 95       	ret

00003c46 <usart_init>:
#include <avr/io.h>

//----------------------------------------------------------------------------
//Init serielle Schnittstelle
void usart_init(unsigned long baudrate) 
{ 
    3c46:	9b 01       	movw	r18, r22
    3c48:	ac 01       	movw	r20, r24
	//Serielle Schnittstelle 1
  	//Enable TXEN im Register UCR TX-Data Enable
	UCSR0B =(1 << TXEN0);
    3c4a:	88 e0       	ldi	r24, 0x08	; 8
    3c4c:	80 93 c1 00 	sts	0x00C1, r24
	// 1 = Parity Mode Enabled, Even Parity
	// 2 = Parity Mode Enabled, Odd Parity
	//UCSRC = 0x06 + ((parity+1)<<4);
	//UCSRC |= (1<<USBS);
	//Teiler wird gesetzt 
	UBRR0=(F_CPU / (baudrate * 16L) - 1);
    3c50:	84 e0       	ldi	r24, 0x04	; 4
    3c52:	22 0f       	add	r18, r18
    3c54:	33 1f       	adc	r19, r19
    3c56:	44 1f       	adc	r20, r20
    3c58:	55 1f       	adc	r21, r21
    3c5a:	8a 95       	dec	r24
    3c5c:	d1 f7       	brne	.-12     	; 0x3c52 <usart_init+0xc>
    3c5e:	60 e0       	ldi	r22, 0x00	; 0
    3c60:	72 e1       	ldi	r23, 0x12	; 18
    3c62:	8a e7       	ldi	r24, 0x7A	; 122
    3c64:	90 e0       	ldi	r25, 0x00	; 0
    3c66:	0e 94 8c 3b 	call	0x7718	; 0x7718 <__udivmodsi4>
    3c6a:	21 50       	subi	r18, 0x01	; 1
    3c6c:	31 09       	sbc	r19, r1
    3c6e:	30 93 c5 00 	sts	0x00C5, r19
    3c72:	20 93 c4 00 	sts	0x00C4, r18
    3c76:	08 95       	ret

00003c78 <uart_putchar>:
}

int uart_putchar(char c, FILE *stream)
{
    while(!(UCSR0A & (1<<UDRE0)));
    3c78:	90 91 c0 00 	lds	r25, 0x00C0
    3c7c:	95 ff       	sbrs	r25, 5
    3c7e:	fc cf       	rjmp	.-8      	; 0x3c78 <uart_putchar>
    UDR0 = c;
    3c80:	80 93 c6 00 	sts	0x00C6, r24
	return 0;
}
    3c84:	80 e0       	ldi	r24, 0x00	; 0
    3c86:	90 e0       	ldi	r25, 0x00	; 0
    3c88:	08 95       	ret

00003c8a <crc8>:

#define CRC8INIT	0x00
#define CRC8POLY	0x18              //0X18 = X^8+X^5+X^4+X^0

uint8_t	crc8 ( uint8_t *data_in, uint16_t number_of_bytes_to_read )
{
    3c8a:	fc 01       	movw	r30, r24
    3c8c:	68 0f       	add	r22, r24
    3c8e:	79 1f       	adc	r23, r25
	uint16_t loop_count;
	uint8_t  bit_counter;
	uint8_t  data;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;
    3c90:	80 e0       	ldi	r24, 0x00	; 0
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ data) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
    3c92:	48 e1       	ldi	r20, 0x18	; 24
	uint8_t  data;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_to_read; loop_count++)
    3c94:	e6 17       	cp	r30, r22
    3c96:	f7 07       	cpc	r31, r23
    3c98:	81 f0       	breq	.+32     	; 0x3cba <crc8+0x30>
	{
		data = data_in[loop_count];
    3c9a:	21 91       	ld	r18, Z+
    3c9c:	98 e0       	ldi	r25, 0x08	; 8
		
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ data) & 0x01;
    3c9e:	32 2f       	mov	r19, r18
    3ca0:	38 27       	eor	r19, r24
	
			if ( feedback_bit == 0x01 ) {
    3ca2:	53 2f       	mov	r21, r19
    3ca4:	51 70       	andi	r21, 0x01	; 1
    3ca6:	30 fd       	sbrc	r19, 0
				crc = crc ^ CRC8POLY;
    3ca8:	84 27       	eor	r24, r20
			}
			crc = (crc >> 1) & 0x7F;
    3caa:	86 95       	lsr	r24
			if ( feedback_bit == 0x01 ) {
    3cac:	51 30       	cpi	r21, 0x01	; 1
    3cae:	09 f4       	brne	.+2      	; 0x3cb2 <crc8+0x28>
				crc = crc | 0x80;
    3cb0:	80 68       	ori	r24, 0x80	; 128
			}
		
			data = data >> 1;
    3cb2:	26 95       	lsr	r18
    3cb4:	91 50       	subi	r25, 0x01	; 1
			bit_counter--;
		
		} while (bit_counter > 0);
    3cb6:	99 f7       	brne	.-26     	; 0x3c9e <crc8+0x14>
    3cb8:	ed cf       	rjmp	.-38     	; 0x3c94 <crc8+0xa>
	}
	
	return crc;
}
    3cba:	08 95       	ret

00003cbc <findSensor>:
		}
	}


int16_t findSensor(uint8_t family, uint8_t id1, uint8_t id2, uint8_t id3, uint8_t id4, uint8_t id5, uint8_t id6, uint8_t crc)
{
    3cbc:	af 92       	push	r10
    3cbe:	cf 92       	push	r12
    3cc0:	ef 92       	push	r14
    3cc2:	0f 93       	push	r16
    3cc4:	cf 93       	push	r28
    3cc6:	df 93       	push	r29
    3cc8:	e7 e1       	ldi	r30, 0x17	; 23
    3cca:	f6 e0       	ldi	r31, 0x06	; 6
	uint16_t pos = 0;
    3ccc:	a0 e0       	ldi	r26, 0x00	; 0
    3cce:	b0 e0       	ldi	r27, 0x00	; 0
    3cd0:	ef 01       	movw	r28, r30
    3cd2:	27 97       	sbiw	r28, 0x07	; 7
	
	while (pos < MAXSENSORS)
	{
		if (
    3cd4:	98 81       	ld	r25, Y
    3cd6:	98 13       	cpse	r25, r24
    3cd8:	1d c0       	rjmp	.+58     	; 0x3d14 <findSensor+0x58>
    3cda:	21 96       	adiw	r28, 0x01	; 1
		sensorValues[(pos*SENSORSIZE)+FAMILY] == family
		&&
    3cdc:	98 81       	ld	r25, Y
    3cde:	96 13       	cpse	r25, r22
    3ce0:	19 c0       	rjmp	.+50     	; 0x3d14 <findSensor+0x58>
    3ce2:	21 96       	adiw	r28, 0x01	; 1
		sensorValues[(pos*SENSORSIZE)+ID1] == id1
		&&
    3ce4:	98 81       	ld	r25, Y
    3ce6:	94 13       	cpse	r25, r20
    3ce8:	15 c0       	rjmp	.+42     	; 0x3d14 <findSensor+0x58>
    3cea:	21 96       	adiw	r28, 0x01	; 1
		sensorValues[(pos*SENSORSIZE)+ID2] == id2
		&&
    3cec:	98 81       	ld	r25, Y
    3cee:	92 13       	cpse	r25, r18
    3cf0:	11 c0       	rjmp	.+34     	; 0x3d14 <findSensor+0x58>
    3cf2:	21 96       	adiw	r28, 0x01	; 1
		sensorValues[(pos*SENSORSIZE)+ID3] == id3
		&&
    3cf4:	98 81       	ld	r25, Y
    3cf6:	90 13       	cpse	r25, r16
    3cf8:	0d c0       	rjmp	.+26     	; 0x3d14 <findSensor+0x58>
    3cfa:	21 96       	adiw	r28, 0x01	; 1
		sensorValues[(pos*SENSORSIZE)+ID4] == id4
		&&
    3cfc:	98 81       	ld	r25, Y
    3cfe:	9e 11       	cpse	r25, r14
    3d00:	09 c0       	rjmp	.+18     	; 0x3d14 <findSensor+0x58>
    3d02:	21 96       	adiw	r28, 0x01	; 1
		sensorValues[(pos*SENSORSIZE)+ID5] == id5
		&&
    3d04:	98 81       	ld	r25, Y
    3d06:	9c 11       	cpse	r25, r12
    3d08:	05 c0       	rjmp	.+10     	; 0x3d14 <findSensor+0x58>
		sensorValues[(pos*SENSORSIZE)+ID6] == id6
		&&
    3d0a:	90 81       	ld	r25, Z
    3d0c:	9a 11       	cpse	r25, r10
    3d0e:	02 c0       	rjmp	.+4      	; 0x3d14 <findSensor+0x58>
		sensorValues[(pos*SENSORSIZE)+CRC] == crc
		)
		{	
			return pos;
    3d10:	cd 01       	movw	r24, r26
    3d12:	21 c0       	rjmp	.+66     	; 0x3d56 <findSensor+0x9a>
		}
		pos++;
    3d14:	11 96       	adiw	r26, 0x01	; 1
    3d16:	3b 96       	adiw	r30, 0x0b	; 11

int16_t findSensor(uint8_t family, uint8_t id1, uint8_t id2, uint8_t id3, uint8_t id4, uint8_t id5, uint8_t id6, uint8_t crc)
{
	uint16_t pos = 0;
	
	while (pos < MAXSENSORS)
    3d18:	ac 33       	cpi	r26, 0x3C	; 60
    3d1a:	b1 05       	cpc	r27, r1
    3d1c:	c9 f6       	brne	.-78     	; 0x3cd0 <findSensor+0x14>
		}
		pos++;
	}

	//If too many sensors found, we delete the oldest - may no longer exist
	if (nextSensorPos > MAXSENSORS)
    3d1e:	90 91 94 05 	lds	r25, 0x0594
    3d22:	9d 33       	cpi	r25, 0x3D	; 61
    3d24:	10 f0       	brcs	.+4      	; 0x3d2a <findSensor+0x6e>
	{
		nextSensorPos = 0;
    3d26:	10 92 94 05 	sts	0x0594, r1
	}

	//not found, create new
	sensorValues[(nextSensorPos*SENSORSIZE)+FAMILY]  = family;
    3d2a:	90 91 94 05 	lds	r25, 0x0594
    3d2e:	3b e0       	ldi	r19, 0x0B	; 11
    3d30:	93 9f       	mul	r25, r19
    3d32:	f0 01       	movw	r30, r0
    3d34:	11 24       	eor	r1, r1
    3d36:	e0 5f       	subi	r30, 0xF0	; 240
    3d38:	f9 4f       	sbci	r31, 0xF9	; 249
    3d3a:	80 83       	st	Z, r24
	sensorValues[(nextSensorPos*SENSORSIZE)+ID1]     = id1;
    3d3c:	61 83       	std	Z+1, r22	; 0x01
	sensorValues[(nextSensorPos*SENSORSIZE)+ID2]     = id2;
    3d3e:	42 83       	std	Z+2, r20	; 0x02
	sensorValues[(nextSensorPos*SENSORSIZE)+ID3]     = id3;
    3d40:	23 83       	std	Z+3, r18	; 0x03
	sensorValues[(nextSensorPos*SENSORSIZE)+ID4]     = id4;
    3d42:	04 83       	std	Z+4, r16	; 0x04
	sensorValues[(nextSensorPos*SENSORSIZE)+ID5]     = id5;
    3d44:	e5 82       	std	Z+5, r14	; 0x05
	sensorValues[(nextSensorPos*SENSORSIZE)+ID6]     = id6;
    3d46:	c6 82       	std	Z+6, r12	; 0x06
	sensorValues[(nextSensorPos*SENSORSIZE)+CRC]     = crc;
    3d48:	a7 82       	std	Z+7, r10	; 0x07
	nextSensorPos++;
    3d4a:	81 e0       	ldi	r24, 0x01	; 1
    3d4c:	89 0f       	add	r24, r25
    3d4e:	80 93 94 05 	sts	0x0594, r24
	return (nextSensorPos-1);
    3d52:	90 e0       	ldi	r25, 0x00	; 0
    3d54:	01 97       	sbiw	r24, 0x01	; 1
}
    3d56:	df 91       	pop	r29
    3d58:	cf 91       	pop	r28
    3d5a:	0f 91       	pop	r16
    3d5c:	ef 90       	pop	r14
    3d5e:	cf 90       	pop	r12
    3d60:	af 90       	pop	r10
    3d62:	08 95       	ret

00003d64 <DS18X20_meas_to_cel>:
   always returns  DS18X20_OK
   TODO invalid-values detection (but should be covered by CRC)
*/
uint8_t DS18X20_meas_to_cel( uint8_t fc, uint8_t *sp, 
	uint8_t* subzero, uint8_t* cel, uint8_t* cel_frac_bits, uint16_t *maalt)
{
    3d64:	ef 92       	push	r14
    3d66:	ff 92       	push	r15
    3d68:	0f 93       	push	r16
    3d6a:	1f 93       	push	r17
    3d6c:	cf 93       	push	r28
    3d6e:	df 93       	push	r29
    3d70:	db 01       	movw	r26, r22
	uint16_t meas;
	uint8_t  i;
	
	meas = sp[0];  // LSB
    3d72:	ec 91       	ld	r30, X
	meas |= ((uint16_t)sp[1])<<8; // MSB
    3d74:	11 96       	adiw	r26, 0x01	; 1
    3d76:	9c 91       	ld	r25, X
    3d78:	11 97       	sbiw	r26, 0x01	; 1
    3d7a:	f0 e0       	ldi	r31, 0x00	; 0
    3d7c:	f9 2b       	or	r31, r25
	//meas = 0xff5e; meas = 0xfe6f;
	
	//  only work on 12bit-base
	if( fc == DS18S20_ID ) { // 9 -> 12 bit if 18S20
    3d7e:	80 31       	cpi	r24, 0x10	; 16
    3d80:	81 f4       	brne	.+32     	; 0x3da2 <DS18X20_meas_to_cel+0x3e>
		/* Extended measurements for DS18S20 contributed by Carsten Foss */
		meas &= (uint16_t) 0xfffe;	// Discard LSB , needed for later extended precicion calc
    3d82:	bf 01       	movw	r22, r30
    3d84:	6e 7f       	andi	r22, 0xFE	; 254
		meas <<= 3;					// Convert to 12-bit , now degrees are in 1/16 degrees units
    3d86:	e3 e0       	ldi	r30, 0x03	; 3
    3d88:	66 0f       	add	r22, r22
    3d8a:	77 1f       	adc	r23, r23
    3d8c:	ea 95       	dec	r30
    3d8e:	e1 f7       	brne	.-8      	; 0x3d88 <DS18X20_meas_to_cel+0x24>
		meas += (16 - sp[6]) - 4;	// Add the compensation , and remember to subtract 0.25 degree (4/16)
    3d90:	16 96       	adiw	r26, 0x06	; 6
    3d92:	9c 91       	ld	r25, X
    3d94:	16 97       	sbiw	r26, 0x06	; 6
    3d96:	ec e0       	ldi	r30, 0x0C	; 12
    3d98:	f0 e0       	ldi	r31, 0x00	; 0
    3d9a:	e9 1b       	sub	r30, r25
    3d9c:	f1 09       	sbc	r31, r1
    3d9e:	e6 0f       	add	r30, r22
    3da0:	f7 1f       	adc	r31, r23
	}
	
	// check for negative 
	if ( meas & 0x8000 )  {
    3da2:	f7 ff       	sbrs	r31, 7
    3da4:	07 c0       	rjmp	.+14     	; 0x3db4 <DS18X20_meas_to_cel+0x50>
		*subzero=1;      // mark negative
    3da6:	91 e0       	ldi	r25, 0x01	; 1
    3da8:	ea 01       	movw	r28, r20
    3daa:	98 83       	st	Y, r25
		meas ^= 0xffff;  // convert to positive => (twos complement)++
		meas++;
    3dac:	f1 95       	neg	r31
    3dae:	e1 95       	neg	r30
    3db0:	f1 09       	sbc	r31, r1
    3db2:	02 c0       	rjmp	.+4      	; 0x3db8 <DS18X20_meas_to_cel+0x54>
	}
	else *subzero=0;
    3db4:	ea 01       	movw	r28, r20
    3db6:	18 82       	st	Y, r1
	
	// clear undefined bits for B != 12bit
	if ( fc == DS18B20_ID ) { // check resolution 18B20
    3db8:	88 32       	cpi	r24, 0x28	; 40
    3dba:	79 f4       	brne	.+30     	; 0x3dda <DS18X20_meas_to_cel+0x76>
		i = sp[DS18B20_CONF_REG];
    3dbc:	14 96       	adiw	r26, 0x04	; 4
    3dbe:	8c 91       	ld	r24, X
		if ( (i & DS18B20_12_BIT) == DS18B20_12_BIT ) ;
    3dc0:	98 2f       	mov	r25, r24
    3dc2:	90 76       	andi	r25, 0x60	; 96
    3dc4:	90 36       	cpi	r25, 0x60	; 96
    3dc6:	49 f0       	breq	.+18     	; 0x3dda <DS18X20_meas_to_cel+0x76>
		else if ( (i & DS18B20_11_BIT) == DS18B20_11_BIT ) 
    3dc8:	86 ff       	sbrs	r24, 6
    3dca:	02 c0       	rjmp	.+4      	; 0x3dd0 <DS18X20_meas_to_cel+0x6c>
			meas &= ~(DS18B20_11_BIT_UNDF);
    3dcc:	ee 7f       	andi	r30, 0xFE	; 254
    3dce:	05 c0       	rjmp	.+10     	; 0x3dda <DS18X20_meas_to_cel+0x76>
		else if ( (i & DS18B20_10_BIT) == DS18B20_10_BIT ) 
    3dd0:	85 ff       	sbrs	r24, 5
    3dd2:	02 c0       	rjmp	.+4      	; 0x3dd8 <DS18X20_meas_to_cel+0x74>
			meas &= ~(DS18B20_10_BIT_UNDF);
    3dd4:	ec 7f       	andi	r30, 0xFC	; 252
    3dd6:	01 c0       	rjmp	.+2      	; 0x3dda <DS18X20_meas_to_cel+0x76>
		else { // if ( (i & DS18B20_9_BIT) == DS18B20_9_BIT ) { 
			meas &= ~(DS18B20_9_BIT_UNDF);
    3dd8:	e8 7f       	andi	r30, 0xF8	; 248
		}
	}			
	
	*cel  = (uint8_t)(meas >> 4); 
    3dda:	cf 01       	movw	r24, r30
    3ddc:	44 e0       	ldi	r20, 0x04	; 4
    3dde:	96 95       	lsr	r25
    3de0:	87 95       	ror	r24
    3de2:	4a 95       	dec	r20
    3de4:	e1 f7       	brne	.-8      	; 0x3dde <DS18X20_meas_to_cel+0x7a>
    3de6:	d9 01       	movw	r26, r18
    3de8:	8c 93       	st	X, r24
	*cel_frac_bits = (uint8_t)(meas & 0x000F);
    3dea:	8e 2f       	mov	r24, r30
    3dec:	8f 70       	andi	r24, 0x0F	; 15
    3dee:	e8 01       	movw	r28, r16
    3df0:	88 83       	st	Y, r24

	*maalt = meas;
    3df2:	d7 01       	movw	r26, r14
    3df4:	ed 93       	st	X+, r30
    3df6:	fc 93       	st	X, r31
	
	return DS18X20_OK;
}
    3df8:	80 e0       	ldi	r24, 0x00	; 0
    3dfa:	df 91       	pop	r29
    3dfc:	cf 91       	pop	r28
    3dfe:	1f 91       	pop	r17
    3e00:	0f 91       	pop	r16
    3e02:	ff 90       	pop	r15
    3e04:	ef 90       	pop	r14
    3e06:	08 95       	ret

00003e08 <DS18X20_start_meas>:
}

/* start measurement (CONVERT_T) for all sensors if input id==NULL 
   or for single sensor. then id is the rom-code */
uint8_t DS18X20_start_meas( uint8_t with_power_extern, uint8_t id[])
{
    3e08:	1f 93       	push	r17
    3e0a:	cf 93       	push	r28
    3e0c:	df 93       	push	r29
    3e0e:	00 d0       	rcall	.+0      	; 0x3e10 <DS18X20_start_meas+0x8>
    3e10:	cd b7       	in	r28, 0x3d	; 61
    3e12:	de b7       	in	r29, 0x3e	; 62
    3e14:	18 2f       	mov	r17, r24
	ow_reset(); //**
    3e16:	69 83       	std	Y+1, r22	; 0x01
    3e18:	7a 83       	std	Y+2, r23	; 0x02
    3e1a:	0e 94 cc 21 	call	0x4398	; 0x4398 <ow_reset>
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
    3e1e:	0e 94 b0 21 	call	0x4360	; 0x4360 <ow_input_pin_state>
    3e22:	69 81       	ldd	r22, Y+1	; 0x01
    3e24:	7a 81       	ldd	r23, Y+2	; 0x02
    3e26:	88 23       	and	r24, r24
    3e28:	41 f0       	breq	.+16     	; 0x3e3a <DS18X20_start_meas+0x32>
		ow_command( DS18X20_CONVERT_T, id );
    3e2a:	84 e4       	ldi	r24, 0x44	; 68
    3e2c:	0e 94 4d 23 	call	0x469a	; 0x469a <ow_command>
		if (with_power_extern != DS18X20_POWER_EXTERN)
    3e30:	11 30       	cpi	r17, 0x01	; 1
    3e32:	29 f0       	breq	.+10     	; 0x3e3e <DS18X20_start_meas+0x36>
			ow_parasite_enable();
    3e34:	0e 94 b9 21 	call	0x4372	; 0x4372 <ow_parasite_enable>
    3e38:	02 c0       	rjmp	.+4      	; 0x3e3e <DS18X20_start_meas+0x36>
	} 
	else { 
		#ifdef DS18X20_VERBOSE
		  printf_P(PSTR( "DS18X20_start_meas: Short Circuit !\r" ));
		#endif
		return DS18X20_START_FAIL;
    3e3a:	82 e0       	ldi	r24, 0x02	; 2
    3e3c:	01 c0       	rjmp	.+2      	; 0x3e40 <DS18X20_start_meas+0x38>
	ow_reset(); //**
	if( ow_input_pin_state() ) { // only send if bus is "idle" = high
		ow_command( DS18X20_CONVERT_T, id );
		if (with_power_extern != DS18X20_POWER_EXTERN)
			ow_parasite_enable();
		return DS18X20_OK;
    3e3e:	80 e0       	ldi	r24, 0x00	; 0
		#ifdef DS18X20_VERBOSE
		  printf_P(PSTR( "DS18X20_start_meas: Short Circuit !\r" ));
		#endif
		return DS18X20_START_FAIL;
	}
}
    3e40:	0f 90       	pop	r0
    3e42:	0f 90       	pop	r0
    3e44:	df 91       	pop	r29
    3e46:	cf 91       	pop	r28
    3e48:	1f 91       	pop	r17
    3e4a:	08 95       	ret

00003e4c <DS18X20_read_meas>:
   output: subzero==1 if temp.<0, cel: full celsius, mcel: frac 
   in millicelsius*0.1
   i.e.: subzero=1, cel=18, millicel=5000 = -18,5000C */
uint8_t DS18X20_read_meas(uint8_t id[], uint8_t *subzero, 
	uint8_t *cel, uint8_t *cel_frac_bits , uint16_t *maalt)
{
    3e4c:	2f 92       	push	r2
    3e4e:	3f 92       	push	r3
    3e50:	4f 92       	push	r4
    3e52:	5f 92       	push	r5
    3e54:	6f 92       	push	r6
    3e56:	7f 92       	push	r7
    3e58:	8f 92       	push	r8
    3e5a:	9f 92       	push	r9
    3e5c:	af 92       	push	r10
    3e5e:	bf 92       	push	r11
    3e60:	cf 92       	push	r12
    3e62:	df 92       	push	r13
    3e64:	ef 92       	push	r14
    3e66:	ff 92       	push	r15
    3e68:	0f 93       	push	r16
    3e6a:	1f 93       	push	r17
    3e6c:	cf 93       	push	r28
    3e6e:	df 93       	push	r29
    3e70:	cd b7       	in	r28, 0x3d	; 61
    3e72:	de b7       	in	r29, 0x3e	; 62
    3e74:	29 97       	sbiw	r28, 0x09	; 9
    3e76:	0f b6       	in	r0, 0x3f	; 63
    3e78:	f8 94       	cli
    3e7a:	de bf       	out	0x3e, r29	; 62
    3e7c:	0f be       	out	0x3f, r0	; 63
    3e7e:	cd bf       	out	0x3d, r28	; 61
    3e80:	6c 01       	movw	r12, r24
    3e82:	5b 01       	movw	r10, r22
    3e84:	4a 01       	movw	r8, r20
    3e86:	39 01       	movw	r6, r18
	uint8_t i;
	uint8_t sp[DS18X20_SP_SIZE];
	
	ow_reset(); //**
    3e88:	0e 94 cc 21 	call	0x4398	; 0x4398 <ow_reset>
	ow_command(DS18X20_READ, id);
    3e8c:	b6 01       	movw	r22, r12
    3e8e:	8e eb       	ldi	r24, 0xBE	; 190
    3e90:	0e 94 4d 23 	call	0x469a	; 0x469a <ow_command>
    3e94:	ce 01       	movw	r24, r28
    3e96:	01 96       	adiw	r24, 0x01	; 1
    3e98:	1c 01       	movw	r2, r24
    3e9a:	7e 01       	movw	r14, r28
    3e9c:	9a e0       	ldi	r25, 0x0A	; 10
    3e9e:	e9 0e       	add	r14, r25
    3ea0:	f1 1c       	adc	r15, r1
    3ea2:	21 01       	movw	r4, r2
	for ( i=0 ; i< DS18X20_SP_SIZE; i++ ) sp[i]=ow_byte_rd();
    3ea4:	0e 94 9f 22 	call	0x453e	; 0x453e <ow_byte_rd>
    3ea8:	f1 01       	movw	r30, r2
    3eaa:	81 93       	st	Z+, r24
    3eac:	1f 01       	movw	r2, r30
    3eae:	ee 15       	cp	r30, r14
    3eb0:	ff 05       	cpc	r31, r15
    3eb2:	c1 f7       	brne	.-16     	; 0x3ea4 <DS18X20_read_meas+0x58>
	if ( crc8( &sp[0], DS18X20_SP_SIZE ) ) 
    3eb4:	69 e0       	ldi	r22, 0x09	; 9
    3eb6:	70 e0       	ldi	r23, 0x00	; 0
    3eb8:	c2 01       	movw	r24, r4
    3eba:	0e 94 45 1e 	call	0x3c8a	; 0x3c8a <crc8>
    3ebe:	81 11       	cpse	r24, r1
    3ec0:	0b c0       	rjmp	.+22     	; 0x3ed8 <DS18X20_read_meas+0x8c>
		return DS18X20_ERROR_CRC;
	DS18X20_meas_to_cel(id[0], sp, subzero, cel, cel_frac_bits, maalt);
    3ec2:	78 01       	movw	r14, r16
    3ec4:	83 01       	movw	r16, r6
    3ec6:	94 01       	movw	r18, r8
    3ec8:	a5 01       	movw	r20, r10
    3eca:	b2 01       	movw	r22, r4
    3ecc:	f6 01       	movw	r30, r12
    3ece:	80 81       	ld	r24, Z
    3ed0:	0e 94 b2 1e 	call	0x3d64	; 0x3d64 <DS18X20_meas_to_cel>
	return DS18X20_OK;
    3ed4:	80 e0       	ldi	r24, 0x00	; 0
    3ed6:	01 c0       	rjmp	.+2      	; 0x3eda <DS18X20_read_meas+0x8e>
	
	ow_reset(); //**
	ow_command(DS18X20_READ, id);
	for ( i=0 ; i< DS18X20_SP_SIZE; i++ ) sp[i]=ow_byte_rd();
	if ( crc8( &sp[0], DS18X20_SP_SIZE ) ) 
		return DS18X20_ERROR_CRC;
    3ed8:	83 e0       	ldi	r24, 0x03	; 3
	DS18X20_meas_to_cel(id[0], sp, subzero, cel, cel_frac_bits, maalt);
	return DS18X20_OK;
}
    3eda:	29 96       	adiw	r28, 0x09	; 9
    3edc:	0f b6       	in	r0, 0x3f	; 63
    3ede:	f8 94       	cli
    3ee0:	de bf       	out	0x3e, r29	; 62
    3ee2:	0f be       	out	0x3f, r0	; 63
    3ee4:	cd bf       	out	0x3d, r28	; 61
    3ee6:	df 91       	pop	r29
    3ee8:	cf 91       	pop	r28
    3eea:	1f 91       	pop	r17
    3eec:	0f 91       	pop	r16
    3eee:	ff 90       	pop	r15
    3ef0:	ef 90       	pop	r14
    3ef2:	df 90       	pop	r13
    3ef4:	cf 90       	pop	r12
    3ef6:	bf 90       	pop	r11
    3ef8:	af 90       	pop	r10
    3efa:	9f 90       	pop	r9
    3efc:	8f 90       	pop	r8
    3efe:	7f 90       	pop	r7
    3f00:	6f 90       	pop	r6
    3f02:	5f 90       	pop	r5
    3f04:	4f 90       	pop	r4
    3f06:	3f 90       	pop	r3
    3f08:	2f 90       	pop	r2
    3f0a:	08 95       	ret

00003f0c <updateOWSensors>:
extern uint8_t start_web_client;
static uint8_t nextSensorPos = 0;


void updateOWSensors()
{
    3f0c:	2f 92       	push	r2
    3f0e:	3f 92       	push	r3
    3f10:	4f 92       	push	r4
    3f12:	5f 92       	push	r5
    3f14:	6f 92       	push	r6
    3f16:	7f 92       	push	r7
    3f18:	8f 92       	push	r8
    3f1a:	9f 92       	push	r9
    3f1c:	af 92       	push	r10
    3f1e:	cf 92       	push	r12
    3f20:	ef 92       	push	r14
    3f22:	ff 92       	push	r15
    3f24:	0f 93       	push	r16
    3f26:	1f 93       	push	r17
    3f28:	cf 93       	push	r28
    3f2a:	df 93       	push	r29
    3f2c:	cd b7       	in	r28, 0x3d	; 61
    3f2e:	de b7       	in	r29, 0x3e	; 62
    3f30:	e1 97       	sbiw	r28, 0x31	; 49
    3f32:	0f b6       	in	r0, 0x3f	; 63
    3f34:	f8 94       	cli
    3f36:	de bf       	out	0x3e, r29	; 62
    3f38:	0f be       	out	0x3f, r0	; 63
    3f3a:	cd bf       	out	0x3d, r28	; 61
	#endif

	uint8_t subzero, cel, cel_frac_bits;
	uint16_t maalt;

	if (!DS18B20Conv)
    3f3c:	80 91 84 05 	lds	r24, 0x0584
    3f40:	81 11       	cpse	r24, r1
    3f42:	10 c0       	rjmp	.+32     	; 0x3f64 <updateOWSensors+0x58>
	{
		DS18B20Conv = true;
    3f44:	81 e0       	ldi	r24, 0x01	; 1
    3f46:	80 93 84 05 	sts	0x0584, r24
		
		for (uint8_t active_OW_channel=1; active_OW_channel<=3; active_OW_channel++)
    3f4a:	11 e0       	ldi	r17, 0x01	; 1
		{
			OW_selectPort(active_OW_channel);
    3f4c:	81 2f       	mov	r24, r17
    3f4e:	0e 94 0f 22 	call	0x441e	; 0x441e <OW_selectPort>
			DS18X20_start_meas( DS18X20_POWER_PARASITE, NULL );
    3f52:	60 e0       	ldi	r22, 0x00	; 0
    3f54:	70 e0       	ldi	r23, 0x00	; 0
    3f56:	80 e0       	ldi	r24, 0x00	; 0
    3f58:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <DS18X20_start_meas>

	if (!DS18B20Conv)
	{
		DS18B20Conv = true;
		
		for (uint8_t active_OW_channel=1; active_OW_channel<=3; active_OW_channel++)
    3f5c:	1f 5f       	subi	r17, 0xFF	; 255
    3f5e:	14 30       	cpi	r17, 0x04	; 4
    3f60:	a9 f7       	brne	.-22     	; 0x3f4c <updateOWSensors+0x40>
    3f62:	53 c1       	rjmp	.+678    	; 0x420a <__stack+0x10b>
			OW_selectPort(active_OW_channel);
			DS18X20_start_meas( DS18X20_POWER_PARASITE, NULL );
		}
		
	} else {
		DS18B20Conv = false;
    3f64:	10 92 84 05 	sts	0x0584, r1

		for (uint8_t active_OW_channel=1; active_OW_channel<=3; active_OW_channel++)
    3f68:	ff 24       	eor	r15, r15
    3f6a:	f3 94       	inc	r15
    3f6c:	9e 01       	movw	r18, r28
    3f6e:	29 5d       	subi	r18, 0xD9	; 217
    3f70:	3f 4f       	sbci	r19, 0xFF	; 255
    3f72:	3f a7       	std	Y+47, r19	; 0x2f
    3f74:	2e a7       	std	Y+46, r18	; 0x2e


			int frac = cel_frac_bits*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger

			unsigned char sensorexport[30];
      		sprintf_P((char*)sensorexport, PSTR("%02X%02X%02X%02X%02X%02X%02X%02X %c%d.%04d"),
    3f76:	ce 01       	movw	r24, r28
    3f78:	01 96       	adiw	r24, 0x01	; 1
    3f7a:	3c 01       	movw	r6, r24
	} else {
		DS18B20Conv = false;

		for (uint8_t active_OW_channel=1; active_OW_channel<=3; active_OW_channel++)
		{
			OW_selectPort(active_OW_channel);
    3f7c:	8f 2d       	mov	r24, r15
    3f7e:	0e 94 0f 22 	call	0x441e	; 0x441e <OW_selectPort>

		#ifdef OW_DEBUG
			printf_P(PSTR("Scanner for onewire sensore paa %d\r\n"),active_OW_channel);
		#endif
      	
	      int nSensors = search_sensors(MAXSENSORS);  //Finder alle sensore (op til max)
    3f82:	8c e3       	ldi	r24, 0x3C	; 60
    3f84:	90 e0       	ldi	r25, 0x00	; 0
    3f86:	0e 94 f3 22 	call	0x45e6	; 0x45e6 <search_sensors>
    3f8a:	a8 2f       	mov	r26, r24
    3f8c:	b0 e0       	ldi	r27, 0x00	; 0
    3f8e:	b9 ab       	std	Y+49, r27	; 0x31
    3f90:	a8 ab       	std	Y+48, r26	; 0x30

		#ifdef OW_DEBUG
			printf("Found %d sensors \r\n", nSensors);
		#endif

		for ( int i=0; i<nSensors; i++ ) {
    3f92:	f7 e0       	ldi	r31, 0x07	; 7
    3f94:	2f 2e       	mov	r2, r31
    3f96:	31 2c       	mov	r3, r1
    3f98:	81 2c       	mov	r8, r1
    3f9a:	91 2c       	mov	r9, r1
    3f9c:	41 2c       	mov	r4, r1
    3f9e:	51 2c       	mov	r5, r1
    3fa0:	9e 01       	movw	r18, r28
    3fa2:	26 5e       	subi	r18, 0xE6	; 230
    3fa4:	3f 4f       	sbci	r19, 0xFF	; 255
    3fa6:	3d a7       	std	Y+45, r19	; 0x2d
    3fa8:	2c a7       	std	Y+44, r18	; 0x2c
    3faa:	a8 a9       	ldd	r26, Y+48	; 0x30
    3fac:	b9 a9       	ldd	r27, Y+49	; 0x31
    3fae:	4a 16       	cp	r4, r26
    3fb0:	5b 06       	cpc	r5, r27
    3fb2:	0c f0       	brlt	.+2      	; 0x3fb6 <updateOWSensors+0xaa>
    3fb4:	26 c1       	rjmp	.+588    	; 0x4202 <__stack+0x103>
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
    3fb6:	e0 91 08 09 	lds	r30, 0x0908
    3fba:	f0 91 09 09 	lds	r31, 0x0909
    3fbe:	df 01       	movw	r26, r30
    3fc0:	a8 0d       	add	r26, r8
    3fc2:	b9 1d       	adc	r27, r9
    3fc4:	8c 91       	ld	r24, X
    3fc6:	8d 31       	cpi	r24, 0x1D	; 29
    3fc8:	09 f0       	breq	.+2      	; 0x3fcc <updateOWSensors+0xc0>
    3fca:	6f c0       	rjmp	.+222    	; 0x40aa <updateOWSensors+0x19e>
                sensorScan[(i*SENSORSIZE)+ID2],
                sensorScan[(i*SENSORSIZE)+ID3],
                sensorScan[(i*SENSORSIZE)+ID4],
                sensorScan[(i*SENSORSIZE)+ID5],
                sensorScan[(i*SENSORSIZE)+ID6],
                sensorScan[(i*SENSORSIZE)+CRC]
    3fcc:	e2 0d       	add	r30, r2
    3fce:	f3 1d       	adc	r31, r3
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    3fd0:	80 81       	ld	r24, Z
    3fd2:	1f 92       	push	r1
    3fd4:	8f 93       	push	r24
                sensorScan[(i*SENSORSIZE)+ID1],
                sensorScan[(i*SENSORSIZE)+ID2],
                sensorScan[(i*SENSORSIZE)+ID3],
                sensorScan[(i*SENSORSIZE)+ID4],
                sensorScan[(i*SENSORSIZE)+ID5],
                sensorScan[(i*SENSORSIZE)+ID6],
    3fd6:	df 01       	movw	r26, r30
    3fd8:	11 97       	sbiw	r26, 0x01	; 1
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    3fda:	8c 91       	ld	r24, X
    3fdc:	1f 92       	push	r1
    3fde:	8f 93       	push	r24
                sensorScan[(i*SENSORSIZE)+FAMILY],
                sensorScan[(i*SENSORSIZE)+ID1],
                sensorScan[(i*SENSORSIZE)+ID2],
                sensorScan[(i*SENSORSIZE)+ID3],
                sensorScan[(i*SENSORSIZE)+ID4],
                sensorScan[(i*SENSORSIZE)+ID5],
    3fe0:	11 97       	sbiw	r26, 0x01	; 1
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    3fe2:	8c 91       	ld	r24, X
    3fe4:	1f 92       	push	r1
    3fe6:	8f 93       	push	r24
                sensorScan[(i*SENSORSIZE)+FAMILY],
                sensorScan[(i*SENSORSIZE)+ID1],
                sensorScan[(i*SENSORSIZE)+ID2],
                sensorScan[(i*SENSORSIZE)+ID3],
                sensorScan[(i*SENSORSIZE)+ID4],
    3fe8:	11 97       	sbiw	r26, 0x01	; 1
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    3fea:	8c 91       	ld	r24, X
    3fec:	1f 92       	push	r1
    3fee:	8f 93       	push	r24
                sensorScan[(i*SENSORSIZE)+FAMILY],
                sensorScan[(i*SENSORSIZE)+ID1],
                sensorScan[(i*SENSORSIZE)+ID2],
                sensorScan[(i*SENSORSIZE)+ID3],
    3ff0:	11 97       	sbiw	r26, 0x01	; 1
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    3ff2:	8c 91       	ld	r24, X
    3ff4:	1f 92       	push	r1
    3ff6:	8f 93       	push	r24
                sensorScan[(i*SENSORSIZE)+FAMILY],
                sensorScan[(i*SENSORSIZE)+ID1],
                sensorScan[(i*SENSORSIZE)+ID2],
    3ff8:	11 97       	sbiw	r26, 0x01	; 1
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    3ffa:	8c 91       	ld	r24, X
    3ffc:	1f 92       	push	r1
    3ffe:	8f 93       	push	r24
                sensorScan[(i*SENSORSIZE)+FAMILY],
                sensorScan[(i*SENSORSIZE)+ID1],
    4000:	11 97       	sbiw	r26, 0x01	; 1
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    4002:	8c 91       	ld	r24, X
    4004:	1f 92       	push	r1
    4006:	8f 93       	push	r24
                sensorScan[(i*SENSORSIZE)+FAMILY],
    4008:	37 97       	sbiw	r30, 0x07	; 7
		#endif

		for ( int i=0; i<nSensors; i++ ) {
			if (sensorScan[i*OW_ROMCODE_SIZE+FAMILY] == 0x1D)
			{
				printf("Found counter (%02X%02X%02X%02X%02X%02X%02X%02X)\r\n",
    400a:	80 81       	ld	r24, Z
    400c:	1f 92       	push	r1
    400e:	8f 93       	push	r24
    4010:	8a eb       	ldi	r24, 0xBA	; 186
    4012:	91 e0       	ldi	r25, 0x01	; 1
    4014:	9f 93       	push	r25
    4016:	8f 93       	push	r24
    4018:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    401c:	3f ef       	ldi	r19, 0xFF	; 255
    401e:	89 e6       	ldi	r24, 0x69	; 105
    4020:	98 e1       	ldi	r25, 0x18	; 24
    4022:	31 50       	subi	r19, 0x01	; 1
    4024:	80 40       	sbci	r24, 0x00	; 0
    4026:	90 40       	sbci	r25, 0x00	; 0
    4028:	e1 f7       	brne	.-8      	; 0x4022 <updateOWSensors+0x116>
    402a:	00 c0       	rjmp	.+0      	; 0x402c <updateOWSensors+0x120>
    402c:	00 00       	nop
                sensorScan[(i*SENSORSIZE)+CRC]
                );
				_delay_ms(1000);
				//Read A+B counters

				ow_reset();
    402e:	0e 94 cc 21 	call	0x4398	; 0x4398 <ow_reset>
				ow_byte_wr( OW_MATCH_ROM );
    4032:	85 e5       	ldi	r24, 0x55	; 85
    4034:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
    4038:	0f b6       	in	r0, 0x3f	; 63
    403a:	f8 94       	cli
    403c:	de bf       	out	0x3e, r29	; 62
    403e:	0f be       	out	0x3f, r0	; 63
    4040:	cd bf       	out	0x3d, r28	; 61
    4042:	00 e0       	ldi	r16, 0x00	; 0
    4044:	10 e0       	ldi	r17, 0x00	; 0

				for (uint8_t o=0; o<OW_ROMCODE_SIZE; o++)
				{
					ow_byte_wr( sensorScan[i*OW_ROMCODE_SIZE+o] );
    4046:	e0 91 08 09 	lds	r30, 0x0908
    404a:	f0 91 09 09 	lds	r31, 0x0909
    404e:	e0 0f       	add	r30, r16
    4050:	f1 1f       	adc	r31, r17
    4052:	e8 0d       	add	r30, r8
    4054:	f9 1d       	adc	r31, r9
    4056:	80 81       	ld	r24, Z
    4058:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
    405c:	0f 5f       	subi	r16, 0xFF	; 255
    405e:	1f 4f       	sbci	r17, 0xFF	; 255
				//Read A+B counters

				ow_reset();
				ow_byte_wr( OW_MATCH_ROM );

				for (uint8_t o=0; o<OW_ROMCODE_SIZE; o++)
    4060:	08 30       	cpi	r16, 0x08	; 8
    4062:	11 05       	cpc	r17, r1
    4064:	81 f7       	brne	.-32     	; 0x4046 <updateOWSensors+0x13a>
				{
					ow_byte_wr( sensorScan[i*OW_ROMCODE_SIZE+o] );
				}
	
				ow_byte_wr( 0x5A );
    4066:	8a e5       	ldi	r24, 0x5A	; 90
    4068:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
				ow_byte_wr( 0xC0 );
    406c:	80 ec       	ldi	r24, 0xC0	; 192
    406e:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
				ow_byte_wr( 0x01 );
    4072:	81 e0       	ldi	r24, 0x01	; 1
    4074:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
    4078:	10 e2       	ldi	r17, 0x20	; 32

				uint8_t data[32];
				for (uint8_t x=0; x<32; x++)
				{
					data[i]=ow_byte_rd();
    407a:	0e 94 9f 22 	call	0x453e	; 0x453e <ow_byte_rd>
					printf("%u : %02X \r\n", i,data[i]);
    407e:	1f 92       	push	r1
    4080:	8f 93       	push	r24
    4082:	5f 92       	push	r5
    4084:	4f 92       	push	r4
    4086:	ad ee       	ldi	r26, 0xED	; 237
    4088:	b1 e0       	ldi	r27, 0x01	; 1
    408a:	bf 93       	push	r27
    408c:	af 93       	push	r26
    408e:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    4092:	11 50       	subi	r17, 0x01	; 1
				ow_byte_wr( 0x5A );
				ow_byte_wr( 0xC0 );
				ow_byte_wr( 0x01 );

				uint8_t data[32];
				for (uint8_t x=0; x<32; x++)
    4094:	0f 90       	pop	r0
    4096:	0f 90       	pop	r0
    4098:	0f 90       	pop	r0
    409a:	0f 90       	pop	r0
    409c:	0f 90       	pop	r0
    409e:	0f 90       	pop	r0
    40a0:	61 f7       	brne	.-40     	; 0x407a <updateOWSensors+0x16e>
				{
					data[i]=ow_byte_rd();
					printf("%u : %02X \r\n", i,data[i]);
				}				

				printf("DONE\r\n");
    40a2:	8a ef       	ldi	r24, 0xFA	; 250
    40a4:	91 e0       	ldi	r25, 0x01	; 1
    40a6:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
			}
			



			if (sensorScan[i*OW_ROMCODE_SIZE+0] == 0x10 || sensorScan[i*OW_ROMCODE_SIZE+0] == 0x28)
    40aa:	e0 91 08 09 	lds	r30, 0x0908
    40ae:	f0 91 09 09 	lds	r31, 0x0909
    40b2:	e8 0d       	add	r30, r8
    40b4:	f9 1d       	adc	r31, r9
    40b6:	80 81       	ld	r24, Z
    40b8:	80 31       	cpi	r24, 0x10	; 16
    40ba:	19 f0       	breq	.+6      	; 0x40c2 <updateOWSensors+0x1b6>
    40bc:	88 32       	cpi	r24, 0x28	; 40
    40be:	09 f0       	breq	.+2      	; 0x40c2 <updateOWSensors+0x1b6>
    40c0:	96 c0       	rjmp	.+300    	; 0x41ee <__stack+0xef>
    40c2:	de 01       	movw	r26, r28
    40c4:	5f 96       	adiw	r26, 0x1f	; 31
			{
				uint8_t sensorID[OW_ROMCODE_SIZE];
				for (uint8_t o=0; o<OW_ROMCODE_SIZE; o++)
				{
					sensorID[o] = sensorScan[i*OW_ROMCODE_SIZE+o];
    40c6:	81 91       	ld	r24, Z+
    40c8:	8d 93       	st	X+, r24


			if (sensorScan[i*OW_ROMCODE_SIZE+0] == 0x10 || sensorScan[i*OW_ROMCODE_SIZE+0] == 0x28)
			{
				uint8_t sensorID[OW_ROMCODE_SIZE];
				for (uint8_t o=0; o<OW_ROMCODE_SIZE; o++)
    40ca:	8e a5       	ldd	r24, Y+46	; 0x2e
    40cc:	9f a5       	ldd	r25, Y+47	; 0x2f
    40ce:	a8 17       	cp	r26, r24
    40d0:	b9 07       	cpc	r27, r25
    40d2:	c9 f7       	brne	.-14     	; 0x40c6 <updateOWSensors+0x1ba>
				{
					sensorID[o] = sensorScan[i*OW_ROMCODE_SIZE+o];
				}

				if ( DS18X20_read_meas( sensorID, &subzero, &cel, &cel_frac_bits, &maalt) == DS18X20_OK ) {			
    40d4:	8e 01       	movw	r16, r28
    40d6:	09 5d       	subi	r16, 0xD9	; 217
    40d8:	1f 4f       	sbci	r17, 0xFF	; 255
    40da:	9e 01       	movw	r18, r28
    40dc:	27 5d       	subi	r18, 0xD7	; 215
    40de:	3f 4f       	sbci	r19, 0xFF	; 255
    40e0:	ae 01       	movw	r20, r28
    40e2:	46 5d       	subi	r20, 0xD6	; 214
    40e4:	5f 4f       	sbci	r21, 0xFF	; 255
    40e6:	be 01       	movw	r22, r28
    40e8:	65 5d       	subi	r22, 0xD5	; 213
    40ea:	7f 4f       	sbci	r23, 0xFF	; 255
    40ec:	ce 01       	movw	r24, r28
    40ee:	4f 96       	adiw	r24, 0x1f	; 31
    40f0:	0e 94 26 1f 	call	0x3e4c	; 0x3e4c <DS18X20_read_meas>
    40f4:	81 11       	cpse	r24, r1
    40f6:	73 c0       	rjmp	.+230    	; 0x41de <__stack+0xdf>
		  #ifdef OW_DEBUG							
			int frac = cel_frac_bits*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
		  #endif
						char sign = (subzero) ? '-' : '+';
    40f8:	8b a5       	ldd	r24, Y+43	; 0x2b
    40fa:	88 23       	and	r24, r24
    40fc:	11 f0       	breq	.+4      	; 0x4102 <__stack+0x3>
    40fe:	1d e2       	ldi	r17, 0x2D	; 45
    4100:	01 c0       	rjmp	.+2      	; 0x4104 <__stack+0x5>
    4102:	1b e2       	ldi	r17, 0x2B	; 43
          sensorScan[i*OW_ROMCODE_SIZE+ID2],
          sensorScan[i*OW_ROMCODE_SIZE+ID3],
          sensorScan[i*OW_ROMCODE_SIZE+ID4],
          sensorScan[i*OW_ROMCODE_SIZE+ID5],
          sensorScan[i*OW_ROMCODE_SIZE+ID6],
          sensorScan[i*OW_ROMCODE_SIZE+CRC]
    4104:	e0 91 08 09 	lds	r30, 0x0908
    4108:	f0 91 09 09 	lds	r31, 0x0909
		  #ifdef OW_DEBUG							
			int frac = cel_frac_bits*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
		  #endif
						char sign = (subzero) ? '-' : '+';

          uint16_t pos = findSensor(
    410c:	e8 0d       	add	r30, r8
    410e:	f9 1d       	adc	r31, r9
    4110:	a7 80       	ldd	r10, Z+7	; 0x07
    4112:	c6 80       	ldd	r12, Z+6	; 0x06
    4114:	e5 80       	ldd	r14, Z+5	; 0x05
    4116:	04 81       	ldd	r16, Z+4	; 0x04
    4118:	23 81       	ldd	r18, Z+3	; 0x03
    411a:	42 81       	ldd	r20, Z+2	; 0x02
    411c:	61 81       	ldd	r22, Z+1	; 0x01
    411e:	80 81       	ld	r24, Z
    4120:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <findSensor>
          sensorScan[i*OW_ROMCODE_SIZE+ID5],
          sensorScan[i*OW_ROMCODE_SIZE+ID6],
          sensorScan[i*OW_ROMCODE_SIZE+CRC]
          );
      	
          sensorValues[(pos*SENSORSIZE)+VALUE1]     = cel;
    4124:	2b e0       	ldi	r18, 0x0B	; 11
    4126:	28 9f       	mul	r18, r24
    4128:	f0 01       	movw	r30, r0
    412a:	29 9f       	mul	r18, r25
    412c:	f0 0d       	add	r31, r0
    412e:	11 24       	eor	r1, r1
    4130:	df 01       	movw	r26, r30
    4132:	a8 5e       	subi	r26, 0xE8	; 232
    4134:	b9 4f       	sbci	r27, 0xF9	; 249
    4136:	8a a5       	ldd	r24, Y+42	; 0x2a
    4138:	8c 93       	st	X, r24
          sensorValues[(pos*SENSORSIZE)+VALUE2]     = cel_frac_bits;
    413a:	49 a5       	ldd	r20, Y+41	; 0x29
    413c:	e0 5f       	subi	r30, 0xF0	; 240
    413e:	f9 4f       	sbci	r31, 0xF9	; 249
    4140:	41 87       	std	Z+9, r20	; 0x09
          sensorValues[(pos*SENSORSIZE)+SIGN]       = sign;
    4142:	12 87       	std	Z+10, r17	; 0x0a


			int frac = cel_frac_bits*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    4144:	21 e7       	ldi	r18, 0x71	; 113
    4146:	32 e0       	ldi	r19, 0x02	; 2
    4148:	42 9f       	mul	r20, r18
    414a:	c0 01       	movw	r24, r0
    414c:	43 9f       	mul	r20, r19
    414e:	90 0d       	add	r25, r0
    4150:	11 24       	eor	r1, r1

			unsigned char sensorexport[30];
      		sprintf_P((char*)sensorexport, PSTR("%02X%02X%02X%02X%02X%02X%02X%02X %c%d.%04d"),
    4152:	9f 93       	push	r25
    4154:	8f 93       	push	r24
    4156:	8c 91       	ld	r24, X
    4158:	1f 92       	push	r1
    415a:	8f 93       	push	r24
    415c:	1f 92       	push	r1
    415e:	1f 93       	push	r17
    4160:	87 81       	ldd	r24, Z+7	; 0x07
    4162:	1f 92       	push	r1
    4164:	8f 93       	push	r24
    4166:	86 81       	ldd	r24, Z+6	; 0x06
    4168:	1f 92       	push	r1
    416a:	8f 93       	push	r24
    416c:	85 81       	ldd	r24, Z+5	; 0x05
    416e:	1f 92       	push	r1
    4170:	8f 93       	push	r24
    4172:	84 81       	ldd	r24, Z+4	; 0x04
    4174:	1f 92       	push	r1
    4176:	8f 93       	push	r24
    4178:	83 81       	ldd	r24, Z+3	; 0x03
    417a:	1f 92       	push	r1
    417c:	8f 93       	push	r24
    417e:	82 81       	ldd	r24, Z+2	; 0x02
    4180:	1f 92       	push	r1
    4182:	8f 93       	push	r24
    4184:	81 81       	ldd	r24, Z+1	; 0x01
    4186:	1f 92       	push	r1
    4188:	8f 93       	push	r24
    418a:	80 81       	ld	r24, Z
    418c:	1f 92       	push	r1
    418e:	8f 93       	push	r24
    4190:	80 e8       	ldi	r24, 0x80	; 128
    4192:	92 e0       	ldi	r25, 0x02	; 2
    4194:	9f 93       	push	r25
    4196:	8f 93       	push	r24
    4198:	7f 92       	push	r7
    419a:	6f 92       	push	r6
    419c:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
    41a0:	f3 01       	movw	r30, r6
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	de bf       	out	0x3e, r29	; 62
    41a8:	0f be       	out	0x3f, r0	; 63
    41aa:	cd bf       	out	0x3d, r28	; 61
                sensorValues[(pos*SENSORSIZE)+VALUE1],
                frac
                );

		  
		  uint8_t sercrc = 0;
    41ac:	80 e0       	ldi	r24, 0x00	; 0
		  for (uint8_t u=0; u<25; u++)
		  {
			sercrc = sercrc + sensorexport[u];
    41ae:	91 91       	ld	r25, Z+
    41b0:	89 0f       	add	r24, r25
                frac
                );

		  
		  uint8_t sercrc = 0;
		  for (uint8_t u=0; u<25; u++)
    41b2:	2c a5       	ldd	r18, Y+44	; 0x2c
    41b4:	3d a5       	ldd	r19, Y+45	; 0x2d
    41b6:	e2 17       	cp	r30, r18
    41b8:	f3 07       	cpc	r31, r19
    41ba:	c9 f7       	brne	.-14     	; 0x41ae <__stack+0xaf>
		  {
			sercrc = sercrc + sensorexport[u];
		  }
		  
		  printf("%s %d\r\n", sensorexport, sercrc);
    41bc:	1f 92       	push	r1
    41be:	8f 93       	push	r24
    41c0:	7f 92       	push	r7
    41c2:	6f 92       	push	r6
    41c4:	80 e0       	ldi	r24, 0x00	; 0
    41c6:	92 e0       	ldi	r25, 0x02	; 2
    41c8:	9f 93       	push	r25
    41ca:	8f 93       	push	r24
    41cc:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    41d0:	0f 90       	pop	r0
    41d2:	0f 90       	pop	r0
    41d4:	0f 90       	pop	r0
    41d6:	0f 90       	pop	r0
    41d8:	0f 90       	pop	r0
    41da:	0f 90       	pop	r0
    41dc:	08 c0       	rjmp	.+16     	; 0x41ee <__stack+0xef>
                frac
                );
        	#endif
				}
				else 
					printf_P(PSTR("CRC Error (lost connection?)"));
    41de:	83 e6       	ldi	r24, 0x63	; 99
    41e0:	92 e0       	ldi	r25, 0x02	; 2
    41e2:	9f 93       	push	r25
    41e4:	8f 93       	push	r24
    41e6:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
    41ea:	0f 90       	pop	r0
    41ec:	0f 90       	pop	r0

		#ifdef OW_DEBUG
			printf("Found %d sensors \r\n", nSensors);
		#endif

		for ( int i=0; i<nSensors; i++ ) {
    41ee:	3f ef       	ldi	r19, 0xFF	; 255
    41f0:	43 1a       	sub	r4, r19
    41f2:	53 0a       	sbc	r5, r19
    41f4:	88 e0       	ldi	r24, 0x08	; 8
    41f6:	88 0e       	add	r8, r24
    41f8:	91 1c       	adc	r9, r1
    41fa:	9b e0       	ldi	r25, 0x0B	; 11
    41fc:	29 0e       	add	r2, r25
    41fe:	31 1c       	adc	r3, r1
    4200:	d4 ce       	rjmp	.-600    	; 0x3faa <updateOWSensors+0x9e>
		}
		
	} else {
		DS18B20Conv = false;

		for (uint8_t active_OW_channel=1; active_OW_channel<=3; active_OW_channel++)
    4202:	f3 94       	inc	r15
    4204:	b4 e0       	ldi	r27, 0x04	; 4
    4206:	fb 12       	cpse	r15, r27
    4208:	b9 ce       	rjmp	.-654    	; 0x3f7c <updateOWSensors+0x70>
					printf_P(PSTR("CRC Error (lost connection?)"));
			  }
			}
			}
		}
	}
    420a:	e1 96       	adiw	r28, 0x31	; 49
    420c:	0f b6       	in	r0, 0x3f	; 63
    420e:	f8 94       	cli
    4210:	de bf       	out	0x3e, r29	; 62
    4212:	0f be       	out	0x3f, r0	; 63
    4214:	cd bf       	out	0x3d, r28	; 61
    4216:	df 91       	pop	r29
    4218:	cf 91       	pop	r28
    421a:	1f 91       	pop	r17
    421c:	0f 91       	pop	r16
    421e:	ff 90       	pop	r15
    4220:	ef 90       	pop	r14
    4222:	cf 90       	pop	r12
    4224:	af 90       	pop	r10
    4226:	9f 90       	pop	r9
    4228:	8f 90       	pop	r8
    422a:	7f 90       	pop	r7
    422c:	6f 90       	pop	r6
    422e:	5f 90       	pop	r5
    4230:	4f 90       	pop	r4
    4232:	3f 90       	pop	r3
    4234:	2f 90       	pop	r2
    4236:	08 95       	ret

00004238 <eepromSaveByte>:
//	eepromSaveByte(10, 127);
//	uint8_t res = eepromReadByte(10);
// Se eeprom.h for hvilke pos der er til hvad

void eepromSaveByte(uint16_t pos, uint8_t value)
{
    4238:	0f 93       	push	r16
    423a:	1f 93       	push	r17
    423c:	cf 93       	push	r28
    423e:	df 93       	push	r29
    4240:	1f 92       	push	r1
    4242:	cd b7       	in	r28, 0x3d	; 61
    4244:	de b7       	in	r29, 0x3e	; 62
    4246:	8c 01       	movw	r16, r24
	return eeprom_read_byte((uint8_t*)pos);
}

uint8_t eepromReadByte(uint16_t pos)
{
	return eeprom_read_byte((uint8_t*)pos);
    4248:	69 83       	std	Y+1, r22	; 0x01
    424a:	0e 94 9e 42 	call	0x853c	; 0x853c <__eerd_byte_m1284p>
//	uint8_t res = eepromReadByte(10);
// Se eeprom.h for hvilke pos der er til hvad

void eepromSaveByte(uint16_t pos, uint8_t value)
{
	if (eepromReadByte(pos) != value)
    424e:	69 81       	ldd	r22, Y+1	; 0x01
    4250:	86 17       	cp	r24, r22
    4252:	41 f0       	breq	.+16     	; 0x4264 <eepromSaveByte+0x2c>
	{
		eeprom_write_byte((uint8_t*)pos, value);
    4254:	c8 01       	movw	r24, r16
	}
}
    4256:	0f 90       	pop	r0
    4258:	df 91       	pop	r29
    425a:	cf 91       	pop	r28
    425c:	1f 91       	pop	r17
    425e:	0f 91       	pop	r16

void eepromSaveByte(uint16_t pos, uint8_t value)
{
	if (eepromReadByte(pos) != value)
	{
		eeprom_write_byte((uint8_t*)pos, value);
    4260:	0c 94 ac 42 	jmp	0x8558	; 0x8558 <__eewr_byte_m1284p>
	}
}
    4264:	0f 90       	pop	r0
    4266:	df 91       	pop	r29
    4268:	cf 91       	pop	r28
    426a:	1f 91       	pop	r17
    426c:	0f 91       	pop	r16
    426e:	08 95       	ret

00004270 <eepromSaveWord>:

void eepromSaveWord(uint16_t pos, uint16_t value)
{
    4270:	0f 93       	push	r16
    4272:	1f 93       	push	r17
    4274:	cf 93       	push	r28
    4276:	df 93       	push	r29
    4278:	00 d0       	rcall	.+0      	; 0x427a <eepromSaveWord+0xa>
    427a:	cd b7       	in	r28, 0x3d	; 61
    427c:	de b7       	in	r29, 0x3e	; 62
    427e:	8c 01       	movw	r16, r24
	return eeprom_read_byte((uint8_t*)pos);
}

uint16_t eepromReadWord(uint16_t pos)
{
	return eeprom_read_word((uint16_t*)pos);
    4280:	69 83       	std	Y+1, r22	; 0x01
    4282:	7a 83       	std	Y+2, r23	; 0x02
    4284:	0e 94 a6 42 	call	0x854c	; 0x854c <__eerd_word_m1284p>
	}
}

void eepromSaveWord(uint16_t pos, uint16_t value)
{
	if (eepromReadWord(pos) != value)
    4288:	69 81       	ldd	r22, Y+1	; 0x01
    428a:	7a 81       	ldd	r23, Y+2	; 0x02
    428c:	86 17       	cp	r24, r22
    428e:	97 07       	cpc	r25, r23
    4290:	49 f0       	breq	.+18     	; 0x42a4 <eepromSaveWord+0x34>
	{
		eeprom_write_word((uint16_t*)pos, value);
    4292:	c8 01       	movw	r24, r16
	}
}
    4294:	0f 90       	pop	r0
    4296:	0f 90       	pop	r0
    4298:	df 91       	pop	r29
    429a:	cf 91       	pop	r28
    429c:	1f 91       	pop	r17
    429e:	0f 91       	pop	r16

void eepromSaveWord(uint16_t pos, uint16_t value)
{
	if (eepromReadWord(pos) != value)
	{
		eeprom_write_word((uint16_t*)pos, value);
    42a0:	0c 94 ba 42 	jmp	0x8574	; 0x8574 <__eewr_word_m1284p>
	}
}
    42a4:	0f 90       	pop	r0
    42a6:	0f 90       	pop	r0
    42a8:	df 91       	pop	r29
    42aa:	cf 91       	pop	r28
    42ac:	1f 91       	pop	r17
    42ae:	0f 91       	pop	r16
    42b0:	08 95       	ret

000042b2 <eepromReadByteSigned>:

int8_t eepromReadByteSigned(uint16_t pos)
{
	return eeprom_read_byte((uint8_t*)pos);
    42b2:	0c 94 9e 42 	jmp	0x853c	; 0x853c <__eerd_byte_m1284p>

000042b6 <eepromReadByte>:
}

uint8_t eepromReadByte(uint16_t pos)
{
	return eeprom_read_byte((uint8_t*)pos);
    42b6:	0c 94 9e 42 	jmp	0x853c	; 0x853c <__eerd_byte_m1284p>

000042ba <eepromReadWord>:
}

uint16_t eepromReadWord(uint16_t pos)
{
	return eeprom_read_word((uint16_t*)pos);
    42ba:	0c 94 a6 42 	jmp	0x854c	; 0x854c <__eerd_word_m1284p>

000042be <eepromSaveStr>:
}

void eepromSaveStr(uint16_t pos, char* target, uint8_t limit)
{
    42be:	cf 92       	push	r12
    42c0:	df 92       	push	r13
    42c2:	ef 92       	push	r14
    42c4:	ff 92       	push	r15
    42c6:	0f 93       	push	r16
    42c8:	1f 93       	push	r17
    42ca:	cf 93       	push	r28
    42cc:	df 93       	push	r29
    42ce:	1f 92       	push	r1
    42d0:	cd b7       	in	r28, 0x3d	; 61
    42d2:	de b7       	in	r29, 0x3e	; 62
    42d4:	8b 01       	movw	r16, r22
	for (uint8_t i=0; i<limit; i++)
    42d6:	6b 01       	movw	r12, r22
    42d8:	7c 01       	movw	r14, r24
    42da:	e6 1a       	sub	r14, r22
    42dc:	f7 0a       	sbc	r15, r23
    42de:	8c 2d       	mov	r24, r12
    42e0:	80 1b       	sub	r24, r16
    42e2:	84 17       	cp	r24, r20
    42e4:	58 f4       	brcc	.+22     	; 0x42fc <eepromSaveStr+0x3e>
    42e6:	c7 01       	movw	r24, r14
    42e8:	8c 0d       	add	r24, r12
    42ea:	9d 1d       	adc	r25, r13
	{
		eepromWriteByte(pos+i, target[i]);
    42ec:	f6 01       	movw	r30, r12
    42ee:	61 91       	ld	r22, Z+
    42f0:	6f 01       	movw	r12, r30
    42f2:	49 83       	std	Y+1, r20	; 0x01
    42f4:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
    42f8:	49 81       	ldd	r20, Y+1	; 0x01
    42fa:	f1 cf       	rjmp	.-30     	; 0x42de <eepromSaveStr+0x20>
	}	
}
    42fc:	0f 90       	pop	r0
    42fe:	df 91       	pop	r29
    4300:	cf 91       	pop	r28
    4302:	1f 91       	pop	r17
    4304:	0f 91       	pop	r16
    4306:	ff 90       	pop	r15
    4308:	ef 90       	pop	r14
    430a:	df 90       	pop	r13
    430c:	cf 90       	pop	r12
    430e:	08 95       	ret

00004310 <eepromReadStr>:

void eepromReadStr(uint16_t pos, char* target, uint8_t limit)
{
    4310:	df 92       	push	r13
    4312:	ef 92       	push	r14
    4314:	ff 92       	push	r15
    4316:	0f 93       	push	r16
    4318:	1f 93       	push	r17
    431a:	cf 93       	push	r28
    431c:	df 93       	push	r29
    431e:	7c 01       	movw	r14, r24
    4320:	eb 01       	movw	r28, r22
    4322:	d4 2e       	mov	r13, r20
	memset(target, '\0', limit);
    4324:	50 e0       	ldi	r21, 0x00	; 0
    4326:	60 e0       	ldi	r22, 0x00	; 0
    4328:	70 e0       	ldi	r23, 0x00	; 0
    432a:	ce 01       	movw	r24, r28
    432c:	0e 94 cd 3d 	call	0x7b9a	; 0x7b9a <memset>
	for (uint8_t i=0; i<limit; i++)
    4330:	8e 01       	movw	r16, r28
    4332:	ec 1a       	sub	r14, r28
    4334:	fd 0a       	sbc	r15, r29
    4336:	80 2f       	mov	r24, r16
    4338:	8c 1b       	sub	r24, r28
    433a:	8d 15       	cp	r24, r13
    433c:	48 f4       	brcc	.+18     	; 0x4350 <eepromReadStr+0x40>
	return eeprom_read_byte((uint8_t*)pos);
}

uint8_t eepromReadByte(uint16_t pos)
{
	return eeprom_read_byte((uint8_t*)pos);
    433e:	c7 01       	movw	r24, r14
    4340:	80 0f       	add	r24, r16
    4342:	91 1f       	adc	r25, r17
    4344:	0e 94 9e 42 	call	0x853c	; 0x853c <__eerd_byte_m1284p>
void eepromReadStr(uint16_t pos, char* target, uint8_t limit)
{
	memset(target, '\0', limit);
	for (uint8_t i=0; i<limit; i++)
	{
		target[i] = eepromReadByte(pos+i);
    4348:	f8 01       	movw	r30, r16
    434a:	81 93       	st	Z+, r24
    434c:	8f 01       	movw	r16, r30
    434e:	f3 cf       	rjmp	.-26     	; 0x4336 <eepromReadStr+0x26>
	}
}
    4350:	df 91       	pop	r29
    4352:	cf 91       	pop	r28
    4354:	1f 91       	pop	r17
    4356:	0f 91       	pop	r16
    4358:	ff 90       	pop	r15
    435a:	ef 90       	pop	r14
    435c:	df 90       	pop	r13
    435e:	08 95       	ret

00004360 <ow_input_pin_state>:

#endif

uint8_t ow_input_pin_state()
{
	return OW_GET_IN();
    4360:	e0 91 83 20 	lds	r30, 0x2083
    4364:	f0 91 84 20 	lds	r31, 0x2084
    4368:	90 81       	ld	r25, Z
    436a:	80 91 82 20 	lds	r24, 0x2082
}
    436e:	89 23       	and	r24, r25
    4370:	08 95       	ret

00004372 <ow_parasite_enable>:

void ow_parasite_enable(void)
{
    OW_OUT_HIGH();
    4372:	e0 91 80 20 	lds	r30, 0x2080
    4376:	f0 91 81 20 	lds	r31, 0x2081
    437a:	80 81       	ld	r24, Z
    437c:	90 91 82 20 	lds	r25, 0x2082
    4380:	89 2b       	or	r24, r25
    4382:	80 83       	st	Z, r24
	OW_DIR_OUT();
    4384:	e0 91 85 20 	lds	r30, 0x2085
    4388:	f0 91 86 20 	lds	r31, 0x2086
    438c:	80 81       	ld	r24, Z
    438e:	90 91 82 20 	lds	r25, 0x2082
    4392:	89 2b       	or	r24, r25
    4394:	80 83       	st	Z, r24
    4396:	08 95       	ret

00004398 <ow_reset>:
uint8_t ow_reset(void)
{
	uint8_t err;
	uint8_t sreg;
	
	OW_OUT_LOW(); // disable internal pull-up (maybe on from parasite)
    4398:	e0 91 80 20 	lds	r30, 0x2080
    439c:	f0 91 81 20 	lds	r31, 0x2081
    43a0:	90 81       	ld	r25, Z
    43a2:	80 91 82 20 	lds	r24, 0x2082
    43a6:	80 95       	com	r24
    43a8:	89 23       	and	r24, r25
    43aa:	80 83       	st	Z, r24
	OW_DIR_OUT(); // pull OW-Pin low for 480us
    43ac:	e0 91 85 20 	lds	r30, 0x2085
    43b0:	f0 91 86 20 	lds	r31, 0x2086
    43b4:	80 81       	ld	r24, Z
    43b6:	90 91 82 20 	lds	r25, 0x2082
    43ba:	89 2b       	or	r24, r25
    43bc:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    43be:	8f eb       	ldi	r24, 0xBF	; 191
    43c0:	93 e0       	ldi	r25, 0x03	; 3
    43c2:	01 97       	sbiw	r24, 0x01	; 1
    43c4:	f1 f7       	brne	.-4      	; 0x43c2 <ow_reset+0x2a>
    43c6:	00 c0       	rjmp	.+0      	; 0x43c8 <ow_reset+0x30>
    43c8:	00 00       	nop
	
	_delay_us(480);
	
	sreg=SREG;
    43ca:	9f b7       	in	r25, 0x3f	; 63
	cli();
    43cc:	f8 94       	cli
	
	// set Pin as input - wait for clients to pull low
	OW_DIR_IN(); // input
    43ce:	e0 91 85 20 	lds	r30, 0x2085
    43d2:	f0 91 86 20 	lds	r31, 0x2086
    43d6:	20 81       	ld	r18, Z
    43d8:	80 91 82 20 	lds	r24, 0x2082
    43dc:	80 95       	com	r24
    43de:	82 23       	and	r24, r18
    43e0:	80 83       	st	Z, r24
    43e2:	e0 eb       	ldi	r30, 0xB0	; 176
    43e4:	ea 95       	dec	r30
    43e6:	f1 f7       	brne	.-4      	; 0x43e4 <ow_reset+0x4c>
	
	_delay_us(66);
	err = OW_GET_IN();		// no presence detect
    43e8:	e0 91 83 20 	lds	r30, 0x2083
    43ec:	f0 91 84 20 	lds	r31, 0x2084
    43f0:	20 81       	ld	r18, Z
    43f2:	80 91 82 20 	lds	r24, 0x2082
	// nobody pulled to low, still high
	
	SREG=sreg; // sei()
    43f6:	9f bf       	out	0x3f, r25	; 63
    43f8:	eb e3       	ldi	r30, 0x3B	; 59
    43fa:	f3 e0       	ldi	r31, 0x03	; 3
    43fc:	31 97       	sbiw	r30, 0x01	; 1
    43fe:	f1 f7       	brne	.-4      	; 0x43fc <ow_reset+0x64>
    4400:	00 c0       	rjmp	.+0      	; 0x4402 <ow_reset+0x6a>
    4402:	00 00       	nop
	
	// after a delay the clients should release the line
	// and input-pin gets back to high due to pull-up-resistor
	_delay_us(480-66);
	if( OW_GET_IN() == 0 )		// short circuit
    4404:	e0 91 83 20 	lds	r30, 0x2083
    4408:	f0 91 84 20 	lds	r31, 0x2084
    440c:	90 81       	ld	r25, Z
    440e:	30 91 82 20 	lds	r19, 0x2082
    4412:	93 23       	and	r25, r19
    4414:	11 f0       	breq	.+4      	; 0x441a <ow_reset+0x82>
	
	// set Pin as input - wait for clients to pull low
	OW_DIR_IN(); // input
	
	_delay_us(66);
	err = OW_GET_IN();		// no presence detect
    4416:	82 23       	and	r24, r18
    4418:	08 95       	ret
	
	// after a delay the clients should release the line
	// and input-pin gets back to high due to pull-up-resistor
	_delay_us(480-66);
	if( OW_GET_IN() == 0 )		// short circuit
		err = 1;
    441a:	81 e0       	ldi	r24, 0x01	; 1
	
	return err;
}
    441c:	08 95       	ret

0000441e <OW_selectPort>:
//#define OW_PIN2 PD6
//#define OW_DIR_IN2()   ( *OW_DDR &= ~(1 << OW_PIN2 ) )

void OW_selectPort(unsigned char port) 
{
	switch(port)
    441e:	82 30       	cpi	r24, 0x02	; 2
    4420:	c9 f0       	breq	.+50     	; 0x4454 <OW_selectPort+0x36>
    4422:	83 30       	cpi	r24, 0x03	; 3
    4424:	59 f1       	breq	.+86     	; 0x447c <OW_selectPort+0x5e>
    4426:	81 30       	cpi	r24, 0x01	; 1
    4428:	09 f0       	breq	.+2      	; 0x442c <OW_selectPort+0xe>
    442a:	3f c0       	rjmp	.+126    	; 0x44aa <OW_selectPort+0x8c>
	return nSensors;
}

void ow_set_bus(volatile uint8_t* in, volatile uint8_t* out,volatile uint8_t* ddr,uint8_t pin)
{
	OW_DDR=ddr;
    442c:	8a e2       	ldi	r24, 0x2A	; 42
    442e:	90 e0       	ldi	r25, 0x00	; 0
    4430:	90 93 86 20 	sts	0x2086, r25
    4434:	80 93 85 20 	sts	0x2085, r24
	OW_OUT=out;
    4438:	8b e2       	ldi	r24, 0x2B	; 43
    443a:	90 e0       	ldi	r25, 0x00	; 0
    443c:	90 93 81 20 	sts	0x2081, r25
    4440:	80 93 80 20 	sts	0x2080, r24
	OW_IN=in;
    4444:	89 e2       	ldi	r24, 0x29	; 41
    4446:	90 e0       	ldi	r25, 0x00	; 0
    4448:	90 93 84 20 	sts	0x2084, r25
    444c:	80 93 83 20 	sts	0x2083, r24
	OW_PIN_MASK=(1<<pin);
    4450:	80 e1       	ldi	r24, 0x10	; 16
    4452:	27 c0       	rjmp	.+78     	; 0x44a2 <OW_selectPort+0x84>
	return nSensors;
}

void ow_set_bus(volatile uint8_t* in, volatile uint8_t* out,volatile uint8_t* ddr,uint8_t pin)
{
	OW_DDR=ddr;
    4454:	8a e2       	ldi	r24, 0x2A	; 42
    4456:	90 e0       	ldi	r25, 0x00	; 0
    4458:	90 93 86 20 	sts	0x2086, r25
    445c:	80 93 85 20 	sts	0x2085, r24
	OW_OUT=out;
    4460:	8b e2       	ldi	r24, 0x2B	; 43
    4462:	90 e0       	ldi	r25, 0x00	; 0
    4464:	90 93 81 20 	sts	0x2081, r25
    4468:	80 93 80 20 	sts	0x2080, r24
	OW_IN=in;
    446c:	89 e2       	ldi	r24, 0x29	; 41
    446e:	90 e0       	ldi	r25, 0x00	; 0
    4470:	90 93 84 20 	sts	0x2084, r25
    4474:	80 93 83 20 	sts	0x2083, r24
	OW_PIN_MASK=(1<<pin);
    4478:	80 e2       	ldi	r24, 0x20	; 32
    447a:	13 c0       	rjmp	.+38     	; 0x44a2 <OW_selectPort+0x84>
	return nSensors;
}

void ow_set_bus(volatile uint8_t* in, volatile uint8_t* out,volatile uint8_t* ddr,uint8_t pin)
{
	OW_DDR=ddr;
    447c:	8a e2       	ldi	r24, 0x2A	; 42
    447e:	90 e0       	ldi	r25, 0x00	; 0
    4480:	90 93 86 20 	sts	0x2086, r25
    4484:	80 93 85 20 	sts	0x2085, r24
	OW_OUT=out;
    4488:	8b e2       	ldi	r24, 0x2B	; 43
    448a:	90 e0       	ldi	r25, 0x00	; 0
    448c:	90 93 81 20 	sts	0x2081, r25
    4490:	80 93 80 20 	sts	0x2080, r24
	OW_IN=in;
    4494:	89 e2       	ldi	r24, 0x29	; 41
    4496:	90 e0       	ldi	r25, 0x00	; 0
    4498:	90 93 84 20 	sts	0x2084, r25
    449c:	80 93 83 20 	sts	0x2083, r24
	OW_PIN_MASK=(1<<pin);
    44a0:	80 e4       	ldi	r24, 0x40	; 64
    44a2:	80 93 82 20 	sts	0x2082, r24
	ow_reset();
    44a6:	0c 94 cc 21 	jmp	0x4398	; 0x4398 <ow_reset>
    44aa:	08 95       	ret

000044ac <ow_bit_io>:
   but around 14 cyles in configureable bus (us-Delay is 4 cyles per uS) */
uint8_t ow_bit_io( uint8_t b )
{
	uint8_t sreg;
	
	sreg=SREG;
    44ac:	2f b7       	in	r18, 0x3f	; 63
	cli();
    44ae:	f8 94       	cli
	
	OW_DIR_OUT(); // drive bus low
    44b0:	e0 91 85 20 	lds	r30, 0x2085
    44b4:	f0 91 86 20 	lds	r31, 0x2086
    44b8:	90 81       	ld	r25, Z
    44ba:	30 91 82 20 	lds	r19, 0x2082
    44be:	93 2b       	or	r25, r19
    44c0:	90 83       	st	Z, r25
    44c2:	92 e0       	ldi	r25, 0x02	; 2
    44c4:	9a 95       	dec	r25
    44c6:	f1 f7       	brne	.-4      	; 0x44c4 <ow_bit_io+0x18>
    44c8:	00 c0       	rjmp	.+0      	; 0x44ca <ow_bit_io+0x1e>
	
	_delay_us(1); // Recovery-Time wuffwuff was 1
	if ( b ) OW_DIR_IN(); // if bit is 1 set bus high (by ext. pull-up)
    44ca:	88 23       	and	r24, r24
    44cc:	51 f0       	breq	.+20     	; 0x44e2 <ow_bit_io+0x36>
    44ce:	e0 91 85 20 	lds	r30, 0x2085
    44d2:	f0 91 86 20 	lds	r31, 0x2086
    44d6:	30 81       	ld	r19, Z
    44d8:	90 91 82 20 	lds	r25, 0x2082
    44dc:	90 95       	com	r25
    44de:	93 23       	and	r25, r19
    44e0:	90 83       	st	Z, r25
    44e2:	92 e2       	ldi	r25, 0x22	; 34
    44e4:	9a 95       	dec	r25
    44e6:	f1 f7       	brne	.-4      	; 0x44e4 <ow_bit_io+0x38>
    44e8:	00 c0       	rjmp	.+0      	; 0x44ea <ow_bit_io+0x3e>
		
	// wuffwuff delay was 15uS-1 see comment above
	_delay_us(15-1-OW_CONF_DELAYOFFSET);
		
	if( OW_GET_IN() == 0 ) b = 0;  // sample at end of read-timeslot
    44ea:	e0 91 83 20 	lds	r30, 0x2083
    44ee:	f0 91 84 20 	lds	r31, 0x2084
    44f2:	90 81       	ld	r25, Z
    44f4:	30 91 82 20 	lds	r19, 0x2082
    44f8:	93 23       	and	r25, r19
    44fa:	09 f4       	brne	.+2      	; 0x44fe <ow_bit_io+0x52>
    44fc:	80 e0       	ldi	r24, 0x00	; 0
    44fe:	98 e7       	ldi	r25, 0x78	; 120
    4500:	9a 95       	dec	r25
    4502:	f1 f7       	brne	.-4      	; 0x4500 <ow_bit_io+0x54>
	
	_delay_us(60-15);
	OW_DIR_IN();
    4504:	e0 91 85 20 	lds	r30, 0x2085
    4508:	f0 91 86 20 	lds	r31, 0x2086
    450c:	30 81       	ld	r19, Z
    450e:	90 91 82 20 	lds	r25, 0x2082
    4512:	90 95       	com	r25
    4514:	93 23       	and	r25, r19
    4516:	90 83       	st	Z, r25
	
	SREG=sreg; // sei();
    4518:	2f bf       	out	0x3f, r18	; 63
	
	return b;
}
    451a:	08 95       	ret

0000451c <ow_byte_wr>:


uint8_t ow_byte_wr( uint8_t b )
{
    451c:	cf 93       	push	r28
    451e:	df 93       	push	r29
    4520:	c8 2f       	mov	r28, r24
    4522:	d8 e0       	ldi	r29, 0x08	; 8
	uint8_t i = 8, j;
	
	do {
		j = ow_bit_io( b & 1 );
    4524:	8c 2f       	mov	r24, r28
    4526:	81 70       	andi	r24, 0x01	; 1
    4528:	0e 94 56 22 	call	0x44ac	; 0x44ac <ow_bit_io>
		b >>= 1;
    452c:	c6 95       	lsr	r28
		if( j ) b |= 0x80;
    452e:	81 11       	cpse	r24, r1
    4530:	c0 68       	ori	r28, 0x80	; 128
    4532:	d1 50       	subi	r29, 0x01	; 1
	} while( --i );
    4534:	b9 f7       	brne	.-18     	; 0x4524 <ow_byte_wr+0x8>
	
	return b;
}
    4536:	8c 2f       	mov	r24, r28
    4538:	df 91       	pop	r29
    453a:	cf 91       	pop	r28
    453c:	08 95       	ret

0000453e <ow_byte_rd>:


uint8_t ow_byte_rd( void )
{
  // read by sending 0xff (a dontcare?)
  return ow_byte_wr( 0xFF ); 
    453e:	8f ef       	ldi	r24, 0xFF	; 255
    4540:	0c 94 8e 22 	jmp	0x451c	; 0x451c <ow_byte_wr>

00004544 <ow_rom_search>:
}


uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
    4544:	df 92       	push	r13
    4546:	ef 92       	push	r14
    4548:	ff 92       	push	r15
    454a:	0f 93       	push	r16
    454c:	1f 93       	push	r17
    454e:	cf 93       	push	r28
    4550:	df 93       	push	r29
    4552:	e8 2e       	mov	r14, r24
    4554:	eb 01       	movw	r28, r22
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) return OW_PRESENCE_ERR;	// error, no device found
    4556:	0e 94 cc 21 	call	0x4398	; 0x4398 <ow_reset>
    455a:	81 11       	cpse	r24, r1
    455c:	2f c0       	rjmp	.+94     	; 0x45bc <ow_rom_search+0x78>
	
	ow_byte_wr( OW_SEARCH_ROM );			// ROM search command
    455e:	80 ef       	ldi	r24, 0xF0	; 240
    4560:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
	next_diff = OW_LAST_DEVICE;			// unchanged on last device
    4564:	f1 2c       	mov	r15, r1
	
	i = OW_ROMCODE_SIZE * 8;					// 8 bytes
    4566:	10 e4       	ldi	r17, 0x40	; 64
    4568:	88 ef       	ldi	r24, 0xF8	; 248
    456a:	d8 2e       	mov	r13, r24
    456c:	d1 0e       	add	r13, r17
	
	do {
		j = 8;					// 8 bits
		do {
			b = ow_bit_io( 1 );			// read bit
    456e:	81 e0       	ldi	r24, 0x01	; 1
    4570:	0e 94 56 22 	call	0x44ac	; 0x44ac <ow_bit_io>
    4574:	08 2f       	mov	r16, r24
			if( ow_bit_io( 1 ) ) {			// read complement bit
    4576:	81 e0       	ldi	r24, 0x01	; 1
    4578:	0e 94 56 22 	call	0x44ac	; 0x44ac <ow_bit_io>
    457c:	88 23       	and	r24, r24
    457e:	19 f0       	breq	.+6      	; 0x4586 <ow_rom_search+0x42>
				if( b )					// 11
    4580:	00 23       	and	r16, r16
    4582:	61 f0       	breq	.+24     	; 0x459c <ow_rom_search+0x58>
    4584:	1d c0       	rjmp	.+58     	; 0x45c0 <ow_rom_search+0x7c>
				return OW_DATA_ERR;			// data error
			}
			else {
				if( !b ) {				// 00 = 2 devices
    4586:	01 11       	cpse	r16, r1
    4588:	09 c0       	rjmp	.+18     	; 0x459c <ow_rom_search+0x58>
					if( diff > i || ((*id & 1) && diff != i) ) {
    458a:	1e 15       	cp	r17, r14
    458c:	28 f0       	brcs	.+10     	; 0x4598 <ow_rom_search+0x54>
    458e:	88 81       	ld	r24, Y
    4590:	80 ff       	sbrs	r24, 0
    4592:	04 c0       	rjmp	.+8      	; 0x459c <ow_rom_search+0x58>
    4594:	e1 16       	cp	r14, r17
    4596:	11 f0       	breq	.+4      	; 0x459c <ow_rom_search+0x58>
    4598:	f1 2e       	mov	r15, r17
					b = 1;				// now 1
    459a:	01 e0       	ldi	r16, 0x01	; 1
					next_diff = i;			// next pass 0
					}
				}
			}
			ow_bit_io( b );     			// write bit
    459c:	80 2f       	mov	r24, r16
    459e:	0e 94 56 22 	call	0x44ac	; 0x44ac <ow_bit_io>
			*id >>= 1;
    45a2:	98 81       	ld	r25, Y
    45a4:	96 95       	lsr	r25
			if( b ) *id |= 0x80;			// store bit
    45a6:	01 11       	cpse	r16, r1
    45a8:	90 68       	ori	r25, 0x80	; 128
    45aa:	98 83       	st	Y, r25
			
			i--;
    45ac:	11 50       	subi	r17, 0x01	; 1
			
		} while( --j );
    45ae:	1d 11       	cpse	r17, r13
    45b0:	de cf       	rjmp	.-68     	; 0x456e <ow_rom_search+0x2a>
		
		id++;					// next byte
    45b2:	21 96       	adiw	r28, 0x01	; 1
	
	} while( i );
    45b4:	11 11       	cpse	r17, r1
    45b6:	d8 cf       	rjmp	.-80     	; 0x4568 <ow_rom_search+0x24>
    45b8:	8f 2d       	mov	r24, r15
    45ba:	03 c0       	rjmp	.+6      	; 0x45c2 <ow_rom_search+0x7e>
uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) return OW_PRESENCE_ERR;	// error, no device found
    45bc:	8f ef       	ldi	r24, 0xFF	; 255
    45be:	01 c0       	rjmp	.+2      	; 0x45c2 <ow_rom_search+0x7e>
		j = 8;					// 8 bits
		do {
			b = ow_bit_io( 1 );			// read bit
			if( ow_bit_io( 1 ) ) {			// read complement bit
				if( b )					// 11
				return OW_DATA_ERR;			// data error
    45c0:	8e ef       	ldi	r24, 0xFE	; 254
		id++;					// next byte
	
	} while( i );
	
	return next_diff;				// to continue search
}
    45c2:	df 91       	pop	r29
    45c4:	cf 91       	pop	r28
    45c6:	1f 91       	pop	r17
    45c8:	0f 91       	pop	r16
    45ca:	ff 90       	pop	r15
    45cc:	ef 90       	pop	r14
    45ce:	df 90       	pop	r13
    45d0:	08 95       	ret

000045d2 <find_sensor>:
	}
}


void find_sensor(uint8_t *diff, uint8_t id[])
{
    45d2:	cf 93       	push	r28
    45d4:	df 93       	push	r29
    45d6:	ec 01       	movw	r28, r24
	for (;;) {
		*diff = ow_rom_search( *diff, &id[0] );
    45d8:	88 81       	ld	r24, Y
    45da:	0e 94 a2 22 	call	0x4544	; 0x4544 <ow_rom_search>
    45de:	88 83       	st	Y, r24
		if ( *diff==OW_PRESENCE_ERR || *diff==OW_DATA_ERR || *diff == OW_LAST_DEVICE ) return;
		return;
	}
}
    45e0:	df 91       	pop	r29
    45e2:	cf 91       	pop	r28
    45e4:	08 95       	ret

000045e6 <search_sensors>:

uint8_t search_sensors(int maxSensors)
{
    45e6:	9f 92       	push	r9
    45e8:	af 92       	push	r10
    45ea:	bf 92       	push	r11
    45ec:	cf 92       	push	r12
    45ee:	df 92       	push	r13
    45f0:	ef 92       	push	r14
    45f2:	ff 92       	push	r15
    45f4:	0f 93       	push	r16
    45f6:	1f 93       	push	r17
    45f8:	cf 93       	push	r28
    45fa:	df 93       	push	r29
    45fc:	cd b7       	in	r28, 0x3d	; 61
    45fe:	de b7       	in	r29, 0x3e	; 62
    4600:	29 97       	sbiw	r28, 0x09	; 9
    4602:	0f b6       	in	r0, 0x3f	; 63
    4604:	f8 94       	cli
    4606:	de bf       	out	0x3e, r29	; 62
    4608:	0f be       	out	0x3f, r0	; 63
    460a:	cd bf       	out	0x3d, r28	; 61
    460c:	6c 01       	movw	r12, r24
	
	//printf_P(PSTR( "\rScanning Bus for DS18X20\r" ));
	
	nSensors = 0;
	
	for( diff = OW_SEARCH_FIRST; diff != OW_LAST_DEVICE && nSensors < maxSensors ; )
    460e:	8f ef       	ldi	r24, 0xFF	; 255
    4610:	89 87       	std	Y+9, r24	; 0x09
	uint8_t id[OW_ROMCODE_SIZE];
	uint8_t diff, nSensors;
	
	//printf_P(PSTR( "\rScanning Bus for DS18X20\r" ));
	
	nSensors = 0;
    4612:	91 2c       	mov	r9, r1
	
	for( diff = OW_SEARCH_FIRST; diff != OW_LAST_DEVICE && nSensors < maxSensors ; )
	{
		find_sensor( &diff, &id[0] );
    4614:	5e 01       	movw	r10, r28
    4616:	89 e0       	ldi	r24, 0x09	; 9
    4618:	a8 0e       	add	r10, r24
    461a:	b1 1c       	adc	r11, r1
    461c:	8e 01       	movw	r16, r28
    461e:	0f 5f       	subi	r16, 0xFF	; 255
    4620:	1f 4f       	sbci	r17, 0xFF	; 255
	
	//printf_P(PSTR( "\rScanning Bus for DS18X20\r" ));
	
	nSensors = 0;
	
	for( diff = OW_SEARCH_FIRST; diff != OW_LAST_DEVICE && nSensors < maxSensors ; )
    4622:	89 85       	ldd	r24, Y+9	; 0x09
    4624:	88 23       	and	r24, r24
    4626:	31 f1       	breq	.+76     	; 0x4674 <search_sensors+0x8e>
    4628:	e9 2c       	mov	r14, r9
    462a:	f1 2c       	mov	r15, r1
    462c:	ec 14       	cp	r14, r12
    462e:	fd 04       	cpc	r15, r13
    4630:	0c f5       	brge	.+66     	; 0x4674 <search_sensors+0x8e>
	{
		find_sensor( &diff, &id[0] );
    4632:	b8 01       	movw	r22, r16
    4634:	c5 01       	movw	r24, r10
    4636:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <find_sensor>
				printf_P(PSTR( "No Sensor found\r" ));
			#endif
			break;
		}
		
		if( diff == OW_DATA_ERR ) {
    463a:	89 85       	ldd	r24, Y+9	; 0x09
    463c:	8e 5f       	subi	r24, 0xFE	; 254
    463e:	82 30       	cpi	r24, 0x02	; 2
    4640:	c8 f0       	brcs	.+50     	; 0x4674 <search_sensors+0x8e>
			break;
		}
		
		for (i=0;i<OW_ROMCODE_SIZE;i++)
		{
			sensorScan[nSensors*OW_ROMCODE_SIZE+i] = id[i];
    4642:	97 01       	movw	r18, r14
    4644:	93 e0       	ldi	r25, 0x03	; 3
    4646:	22 0f       	add	r18, r18
    4648:	33 1f       	adc	r19, r19
    464a:	9a 95       	dec	r25
    464c:	e1 f7       	brne	.-8      	; 0x4646 <search_sensors+0x60>
    464e:	f8 01       	movw	r30, r16
    4650:	20 1b       	sub	r18, r16
    4652:	31 0b       	sbc	r19, r17
    4654:	a9 01       	movw	r20, r18
    4656:	4e 0f       	add	r20, r30
    4658:	5f 1f       	adc	r21, r31
    465a:	a0 91 08 09 	lds	r26, 0x0908
    465e:	b0 91 09 09 	lds	r27, 0x0909
    4662:	a4 0f       	add	r26, r20
    4664:	b5 1f       	adc	r27, r21
    4666:	81 91       	ld	r24, Z+
    4668:	8c 93       	st	X, r24
				printf_P(PSTR( "Bus Error\r" ));
			#endif
			break;
		}
		
		for (i=0;i<OW_ROMCODE_SIZE;i++)
    466a:	ea 15       	cp	r30, r10
    466c:	fb 05       	cpc	r31, r11
    466e:	91 f7       	brne	.-28     	; 0x4654 <search_sensors+0x6e>
		{
			sensorScan[nSensors*OW_ROMCODE_SIZE+i] = id[i];
		}
		
		nSensors++;
    4670:	93 94       	inc	r9
    4672:	d7 cf       	rjmp	.-82     	; 0x4622 <search_sensors+0x3c>
	}
	
	return nSensors;
}
    4674:	89 2d       	mov	r24, r9
    4676:	29 96       	adiw	r28, 0x09	; 9
    4678:	0f b6       	in	r0, 0x3f	; 63
    467a:	f8 94       	cli
    467c:	de bf       	out	0x3e, r29	; 62
    467e:	0f be       	out	0x3f, r0	; 63
    4680:	cd bf       	out	0x3d, r28	; 61
    4682:	df 91       	pop	r29
    4684:	cf 91       	pop	r28
    4686:	1f 91       	pop	r17
    4688:	0f 91       	pop	r16
    468a:	ff 90       	pop	r15
    468c:	ef 90       	pop	r14
    468e:	df 90       	pop	r13
    4690:	cf 90       	pop	r12
    4692:	bf 90       	pop	r11
    4694:	af 90       	pop	r10
    4696:	9f 90       	pop	r9
    4698:	08 95       	ret

0000469a <ow_command>:
	return next_diff;				// to continue search
}


void ow_command( uint8_t command, uint8_t *id )
{
    469a:	ff 92       	push	r15
    469c:	0f 93       	push	r16
    469e:	1f 93       	push	r17
    46a0:	cf 93       	push	r28
    46a2:	df 93       	push	r29
    46a4:	f8 2e       	mov	r15, r24
    46a6:	eb 01       	movw	r28, r22
	uint8_t i;

	ow_reset();
    46a8:	0e 94 cc 21 	call	0x4398	; 0x4398 <ow_reset>

	if( id ) {
    46ac:	20 97       	sbiw	r28, 0x00	; 0
    46ae:	69 f0       	breq	.+26     	; 0x46ca <ow_command+0x30>
		ow_byte_wr( OW_MATCH_ROM );			// to a single device
    46b0:	85 e5       	ldi	r24, 0x55	; 85
    46b2:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
    46b6:	8e 01       	movw	r16, r28
    46b8:	08 5f       	subi	r16, 0xF8	; 248
    46ba:	1f 4f       	sbci	r17, 0xFF	; 255
		i = OW_ROMCODE_SIZE;
		do {
			ow_byte_wr( *id );
    46bc:	89 91       	ld	r24, Y+
    46be:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
			id++;
		} while( --i );
    46c2:	c0 17       	cp	r28, r16
    46c4:	d1 07       	cpc	r29, r17
    46c6:	d1 f7       	brne	.-12     	; 0x46bc <ow_command+0x22>
    46c8:	03 c0       	rjmp	.+6      	; 0x46d0 <ow_command+0x36>
	} 
	else {
		ow_byte_wr( OW_SKIP_ROM );			// to all devices
    46ca:	8c ec       	ldi	r24, 0xCC	; 204
    46cc:	0e 94 8e 22 	call	0x451c	; 0x451c <ow_byte_wr>
	}
	
	ow_byte_wr( command );
    46d0:	8f 2d       	mov	r24, r15
}
    46d2:	df 91       	pop	r29
    46d4:	cf 91       	pop	r28
    46d6:	1f 91       	pop	r17
    46d8:	0f 91       	pop	r16
    46da:	ff 90       	pop	r15
	} 
	else {
		ow_byte_wr( OW_SKIP_ROM );			// to all devices
	}
	
	ow_byte_wr( command );
    46dc:	0c 94 8e 22 	jmp	0x451c	; 0x451c <ow_byte_wr>

000046e0 <twiInit>:
twiInit(
  uint8_t timeout
)
{
  // save starting time-out counter value
  toValue = timeout;
    46e0:	80 93 95 05 	sts	0x0595, r24

  // initialize TWI Bit Rate Prescaler
  TWSR =
    46e4:	10 92 b9 00 	sts	0x00B9, r1
       ( ( ( TWPS & _BV( 1 ) ) != 0 ) ? _BV( TWPS1 ) : 0 ) |
       ( ( ( TWPS & _BV( 0 ) ) != 0 ) ? _BV( TWPS0 ) : 0 );

  // initialize TWI Bit Rate
  TWBR = TWBR_VALUE;
    46e8:	80 e2       	ldi	r24, 0x20	; 32
    46ea:	80 93 b8 00 	sts	0x00B8, r24
    46ee:	08 95       	ret

000046f0 <twiDecTo>:

********************************************************************************/

void twiDecTo(void)
{
  if ( toCounter != 0 )
    46f0:	80 91 96 05 	lds	r24, 0x0596
    46f4:	88 23       	and	r24, r24
    46f6:	29 f0       	breq	.+10     	; 0x4702 <twiDecTo+0x12>
  {
  	toCounter--;
    46f8:	80 91 96 05 	lds	r24, 0x0596
    46fc:	81 50       	subi	r24, 0x01	; 1
    46fe:	80 93 96 05 	sts	0x0596, r24
    4702:	08 95       	ret

00004704 <ADC_Init>:
#include "analog.h"
#include <avr/io.h>

void ADC_Init(void)
{ 
	ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
    4704:	87 e8       	ldi	r24, 0x87	; 135
    4706:	80 93 7a 00 	sts	0x007A, r24
    470a:	08 95       	ret

0000470c <readAdc>:
	return value / 64;
}

uint16_t readAdc(unsigned char adc_input)
{
    DDRA=0x00;
    470c:	11 b8       	out	0x01, r1	; 1

	ADMUX =(1<<REFS0) + adc_input; //Select port
    470e:	80 5c       	subi	r24, 0xC0	; 192
    4710:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= (1 << ADSC);  // Start A2D Conversions
    4714:	80 91 7a 00 	lds	r24, 0x007A
    4718:	80 64       	ori	r24, 0x40	; 64
    471a:	80 93 7a 00 	sts	0x007A, r24
	while ((ADCSRA & 0x10)==0); // Wait for the AD conversion to complete
    471e:	80 91 7a 00 	lds	r24, 0x007A
    4722:	84 ff       	sbrs	r24, 4
    4724:	fc cf       	rjmp	.-8      	; 0x471e <readAdc+0x12>
	ADCSRA|=0x10;
    4726:	80 91 7a 00 	lds	r24, 0x007A
    472a:	80 61       	ori	r24, 0x10	; 16
    472c:	80 93 7a 00 	sts	0x007A, r24
	return ADCW;
    4730:	80 91 78 00 	lds	r24, 0x0078
    4734:	90 91 79 00 	lds	r25, 0x0079
}
    4738:	08 95       	ret

0000473a <readOversampledAdc>:
{ 
	ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
}

uint16_t readOversampledAdc(unsigned char adc_input)
{
    473a:	0f 93       	push	r16
    473c:	1f 93       	push	r17
    473e:	cf 93       	push	r28
    4740:	df 93       	push	r29
    4742:	08 2f       	mov	r16, r24
    4744:	10 e4       	ldi	r17, 0x40	; 64
	uint16_t value = 0;
    4746:	c0 e0       	ldi	r28, 0x00	; 0
    4748:	d0 e0       	ldi	r29, 0x00	; 0
	for (uint8_t i=0; i<64; i++)
		value += readAdc(adc_input);
    474a:	80 2f       	mov	r24, r16
    474c:	0e 94 86 23 	call	0x470c	; 0x470c <readAdc>
    4750:	c8 0f       	add	r28, r24
    4752:	d9 1f       	adc	r29, r25
    4754:	11 50       	subi	r17, 0x01	; 1
}

uint16_t readOversampledAdc(unsigned char adc_input)
{
	uint16_t value = 0;
	for (uint8_t i=0; i<64; i++)
    4756:	c9 f7       	brne	.-14     	; 0x474a <readOversampledAdc+0x10>
		value += readAdc(adc_input);
	return value / 64;
}
    4758:	ce 01       	movw	r24, r28
    475a:	26 e0       	ldi	r18, 0x06	; 6
    475c:	96 95       	lsr	r25
    475e:	87 95       	ror	r24
    4760:	2a 95       	dec	r18
    4762:	e1 f7       	brne	.-8      	; 0x475c <readOversampledAdc+0x22>
    4764:	df 91       	pop	r29
    4766:	cf 91       	pop	r28
    4768:	1f 91       	pop	r17
    476a:	0f 91       	pop	r16
    476c:	08 95       	ret

0000476e <base64dec>:
  |54321054|32105432|10543210|
  |76543210|76543210|76543210|

*/

int base64dec(void* dest, const char* b64str, uint8_t strict){
    476e:	ef 92       	push	r14
    4770:	ff 92       	push	r15
    4772:	0f 93       	push	r16
    4774:	1f 93       	push	r17
    4776:	cf 93       	push	r28
    4778:	df 93       	push	r29
    477a:	00 d0       	rcall	.+0      	; 0x477c <base64dec+0xe>
    477c:	00 d0       	rcall	.+0      	; 0x477e <base64dec+0x10>
    477e:	cd b7       	in	r28, 0x3d	; 61
    4780:	de b7       	in	r29, 0x3e	; 62
    4782:	fc 01       	movw	r30, r24
    4784:	7b 01       	movw	r14, r22
	uint8_t buffer[4];
	uint8_t idx=0;
	uint8_t term=0;
    4786:	70 e0       	ldi	r23, 0x00	; 0

*/

int base64dec(void* dest, const char* b64str, uint8_t strict){
	uint8_t buffer[4];
	uint8_t idx=0;
    4788:	60 e0       	ldi	r22, 0x00	; 0
	uint8_t term=0;
	for(;;){
		buffer[idx]= ascii2bit6(*b64str);
    478a:	26 2f       	mov	r18, r22
    478c:	30 e0       	ldi	r19, 0x00	; 0
    478e:	d7 01       	movw	r26, r14
    4790:	5d 91       	ld	r21, X+
    4792:	7d 01       	movw	r14, r26
#else

static
uint8_t ascii2bit6(char a){
	int r;
	switch(a>>4){
    4794:	85 2f       	mov	r24, r21
    4796:	82 95       	swap	r24
    4798:	8f 70       	andi	r24, 0x0F	; 15
    479a:	86 30       	cpi	r24, 0x06	; 6
    479c:	28 f4       	brcc	.+10     	; 0x47a8 <base64dec+0x3a>
    479e:	84 30       	cpi	r24, 0x04	; 4
    47a0:	30 f4       	brcc	.+12     	; 0x47ae <base64dec+0x40>
    47a2:	83 30       	cpi	r24, 0x03	; 3
    47a4:	a9 f0       	breq	.+42     	; 0x47d0 <base64dec+0x62>
    47a6:	19 c0       	rjmp	.+50     	; 0x47da <base64dec+0x6c>
    47a8:	88 30       	cpi	r24, 0x08	; 8
    47aa:	48 f0       	brcs	.+18     	; 0x47be <base64dec+0x50>
    47ac:	16 c0       	rjmp	.+44     	; 0x47da <base64dec+0x6c>
		case 0x5:
		case 0x4: 
			r=a-'A';
    47ae:	85 2f       	mov	r24, r21
    47b0:	90 e0       	ldi	r25, 0x00	; 0
    47b2:	81 54       	subi	r24, 0x41	; 65
    47b4:	91 09       	sbc	r25, r1
			if(r<0 || r>25){
    47b6:	8a 31       	cpi	r24, 0x1A	; 26
    47b8:	91 05       	cpc	r25, r1
    47ba:	f0 f4       	brcc	.+60     	; 0x47f8 <base64dec+0x8a>
    47bc:	1e c0       	rjmp	.+60     	; 0x47fa <base64dec+0x8c>
			} else {
				return r;
			}
		case 0x7:
		case 0x6: 
			r=a-'a';
    47be:	85 2f       	mov	r24, r21
    47c0:	90 e0       	ldi	r25, 0x00	; 0
    47c2:	81 56       	subi	r24, 0x61	; 97
    47c4:	91 09       	sbc	r25, r1
			if(r<0 || r>25){
    47c6:	8a 31       	cpi	r24, 0x1A	; 26
    47c8:	91 05       	cpc	r25, r1
    47ca:	b0 f4       	brcc	.+44     	; 0x47f8 <base64dec+0x8a>
				return -1;
			} else {
				return r+26;
    47cc:	86 5e       	subi	r24, 0xE6	; 230
    47ce:	15 c0       	rjmp	.+42     	; 0x47fa <base64dec+0x8c>
			}
			break;
		case 0x3:
			if(a>'9')
    47d0:	5a 33       	cpi	r21, 0x3A	; 58
    47d2:	90 f4       	brcc	.+36     	; 0x47f8 <base64dec+0x8a>
				return -1;
			return a-'0'+52;
    47d4:	84 e0       	ldi	r24, 0x04	; 4
    47d6:	85 0f       	add	r24, r21
    47d8:	10 c0       	rjmp	.+32     	; 0x47fa <base64dec+0x8c>
		default:
			break;	
	}
	switch (a){
    47da:	5d 32       	cpi	r21, 0x2D	; 45
    47dc:	49 f0       	breq	.+18     	; 0x47f0 <base64dec+0x82>
    47de:	18 f4       	brcc	.+6      	; 0x47e6 <base64dec+0x78>
    47e0:	5b 32       	cpi	r21, 0x2B	; 43
    47e2:	31 f0       	breq	.+12     	; 0x47f0 <base64dec+0x82>
    47e4:	09 c0       	rjmp	.+18     	; 0x47f8 <base64dec+0x8a>
    47e6:	5f 32       	cpi	r21, 0x2F	; 47
    47e8:	29 f0       	breq	.+10     	; 0x47f4 <base64dec+0x86>
    47ea:	5f 35       	cpi	r21, 0x5F	; 95
    47ec:	19 f0       	breq	.+6      	; 0x47f4 <base64dec+0x86>
    47ee:	04 c0       	rjmp	.+8      	; 0x47f8 <base64dec+0x8a>
		case '+':
		case '-':
			return 62;
    47f0:	8e e3       	ldi	r24, 0x3E	; 62
    47f2:	03 c0       	rjmp	.+6      	; 0x47fa <base64dec+0x8c>
		case '/':
		case '_':
			return 63;
    47f4:	8f e3       	ldi	r24, 0x3F	; 63
    47f6:	01 c0       	rjmp	.+2      	; 0x47fa <base64dec+0x8c>
	switch(a>>4){
		case 0x5:
		case 0x4: 
			r=a-'A';
			if(r<0 || r>25){
				return -1;
    47f8:	8f ef       	ldi	r24, 0xFF	; 255
int base64dec(void* dest, const char* b64str, uint8_t strict){
	uint8_t buffer[4];
	uint8_t idx=0;
	uint8_t term=0;
	for(;;){
		buffer[idx]= ascii2bit6(*b64str);
    47fa:	01 e0       	ldi	r16, 0x01	; 1
    47fc:	10 e0       	ldi	r17, 0x00	; 0
    47fe:	0c 0f       	add	r16, r28
    4800:	1d 1f       	adc	r17, r29
    4802:	20 0f       	add	r18, r16
    4804:	31 1f       	adc	r19, r17
    4806:	d9 01       	movw	r26, r18
    4808:	8c 93       	st	X, r24
		
		if(buffer[idx]==0xFF){
    480a:	8f 3f       	cpi	r24, 0xFF	; 255
    480c:	79 f4       	brne	.+30     	; 0x482c <base64dec+0xbe>
			if(*b64str=='='){
    480e:	5d 33       	cpi	r21, 0x3D	; 61
    4810:	21 f4       	brne	.+8      	; 0x481a <base64dec+0xac>
				term++;
    4812:	7f 5f       	subi	r23, 0xFF	; 255
				b64str++;
				if(term==2)
    4814:	72 30       	cpi	r23, 0x02	; 2
    4816:	69 f4       	brne	.+26     	; 0x4832 <base64dec+0xc4>
    4818:	56 c0       	rjmp	.+172    	; 0x48c6 <base64dec+0x158>
					goto finalize; /* definitly the end */
			}else{
				if(*b64str == '\0'){
    481a:	55 23       	and	r21, r21
    481c:	59 f1       	breq	.+86     	; 0x4874 <base64dec+0x106>
					goto finalize; /* definitly the end */
				}else{
					if(*b64str == '\r' || *b64str == '\n' || !(strict)){
    481e:	5d 30       	cpi	r21, 0x0D	; 13
    4820:	41 f0       	breq	.+16     	; 0x4832 <base64dec+0xc4>
    4822:	5a 30       	cpi	r21, 0x0A	; 10
    4824:	31 f0       	breq	.+12     	; 0x4832 <base64dec+0xc4>
    4826:	44 23       	and	r20, r20
    4828:	21 f0       	breq	.+8      	; 0x4832 <base64dec+0xc4>
    482a:	4a c0       	rjmp	.+148    	; 0x48c0 <base64dec+0x152>
						return -1;
					}
				}
			}
		}else{
			if(term)
    482c:	71 11       	cpse	r23, r1
    482e:	48 c0       	rjmp	.+144    	; 0x48c0 <base64dec+0x152>
				return -1; /* this happens if we get a '=' in the stream */
			idx++;
    4830:	6f 5f       	subi	r22, 0xFF	; 255
			b64str++;
		}
		if(idx==4){
    4832:	64 30       	cpi	r22, 0x04	; 4
    4834:	09 f0       	breq	.+2      	; 0x4838 <base64dec+0xca>
    4836:	a9 cf       	rjmp	.-174    	; 0x478a <base64dec+0x1c>
			((uint8_t*)dest)[0] = buffer[0]<<2 | buffer[1]>>4;
    4838:	2a 81       	ldd	r18, Y+2	; 0x02
    483a:	89 81       	ldd	r24, Y+1	; 0x01
    483c:	b4 e0       	ldi	r27, 0x04	; 4
    483e:	8b 9f       	mul	r24, r27
    4840:	c0 01       	movw	r24, r0
    4842:	11 24       	eor	r1, r1
    4844:	92 2f       	mov	r25, r18
    4846:	92 95       	swap	r25
    4848:	9f 70       	andi	r25, 0x0F	; 15
    484a:	98 2b       	or	r25, r24
    484c:	90 83       	st	Z, r25
			((uint8_t*)dest)[1] = buffer[1]<<4 | buffer[2]>>2;
    484e:	8b 81       	ldd	r24, Y+3	; 0x03
    4850:	00 e1       	ldi	r16, 0x10	; 16
    4852:	20 9f       	mul	r18, r16
    4854:	90 01       	movw	r18, r0
    4856:	11 24       	eor	r1, r1
    4858:	98 2f       	mov	r25, r24
    485a:	96 95       	lsr	r25
    485c:	96 95       	lsr	r25
    485e:	92 2b       	or	r25, r18
    4860:	91 83       	std	Z+1, r25	; 0x01
			((uint8_t*)dest)[2] = buffer[2]<<6 | buffer[3];
    4862:	10 e4       	ldi	r17, 0x40	; 64
    4864:	81 9f       	mul	r24, r17
    4866:	c0 01       	movw	r24, r0
    4868:	11 24       	eor	r1, r1
    486a:	9c 81       	ldd	r25, Y+4	; 0x04
    486c:	98 2b       	or	r25, r24
    486e:	92 83       	std	Z+2, r25	; 0x02
			dest = (uint8_t*)dest +3;
    4870:	33 96       	adiw	r30, 0x03	; 3
    4872:	8a cf       	rjmp	.-236    	; 0x4788 <base64dec+0x1a>
			idx=0;
		}
	}
  finalize:	
	/* the final touch */
	if(idx==0)
    4874:	66 23       	and	r22, r22
    4876:	49 f1       	breq	.+82     	; 0x48ca <base64dec+0x15c>
		return 0;
	if(term==1){
    4878:	71 30       	cpi	r23, 0x01	; 1
    487a:	a9 f4       	brne	.+42     	; 0x48a6 <base64dec+0x138>
		((uint8_t*)dest)[0] = buffer[0]<<2 | buffer[1]>>4;
    487c:	8a 81       	ldd	r24, Y+2	; 0x02
    487e:	29 81       	ldd	r18, Y+1	; 0x01
    4880:	94 e0       	ldi	r25, 0x04	; 4
    4882:	29 9f       	mul	r18, r25
    4884:	90 01       	movw	r18, r0
    4886:	11 24       	eor	r1, r1
    4888:	98 2f       	mov	r25, r24
    488a:	92 95       	swap	r25
    488c:	9f 70       	andi	r25, 0x0F	; 15
    488e:	92 2b       	or	r25, r18
    4890:	90 83       	st	Z, r25
		((uint8_t*)dest)[1] = buffer[1]<<4 | buffer[2]>>2;			
    4892:	a0 e1       	ldi	r26, 0x10	; 16
    4894:	8a 9f       	mul	r24, r26
    4896:	c0 01       	movw	r24, r0
    4898:	11 24       	eor	r1, r1
    489a:	9b 81       	ldd	r25, Y+3	; 0x03
    489c:	96 95       	lsr	r25
    489e:	96 95       	lsr	r25
    48a0:	98 2b       	or	r25, r24
    48a2:	91 83       	std	Z+1, r25	; 0x01
    48a4:	12 c0       	rjmp	.+36     	; 0x48ca <base64dec+0x15c>
		return 0;
	}
	if(term==2){
    48a6:	72 30       	cpi	r23, 0x02	; 2
    48a8:	59 f4       	brne	.+22     	; 0x48c0 <base64dec+0x152>
		((uint8_t*)dest)[0] = buffer[0]<<2 | buffer[1]>>4;
    48aa:	89 81       	ldd	r24, Y+1	; 0x01
    48ac:	b4 e0       	ldi	r27, 0x04	; 4
    48ae:	8b 9f       	mul	r24, r27
    48b0:	c0 01       	movw	r24, r0
    48b2:	11 24       	eor	r1, r1
    48b4:	9a 81       	ldd	r25, Y+2	; 0x02
    48b6:	92 95       	swap	r25
    48b8:	9f 70       	andi	r25, 0x0F	; 15
    48ba:	98 2b       	or	r25, r24
    48bc:	90 83       	st	Z, r25
    48be:	05 c0       	rjmp	.+10     	; 0x48ca <base64dec+0x15c>
					goto finalize; /* definitly the end */
				}else{
					if(*b64str == '\r' || *b64str == '\n' || !(strict)){
						b64str++; /* charcters that we simply ignore */
					}else{
						return -1;
    48c0:	8f ef       	ldi	r24, 0xFF	; 255
    48c2:	9f ef       	ldi	r25, 0xFF	; 255
    48c4:	04 c0       	rjmp	.+8      	; 0x48ce <base64dec+0x160>
			idx=0;
		}
	}
  finalize:	
	/* the final touch */
	if(idx==0)
    48c6:	61 11       	cpse	r22, r1
    48c8:	f0 cf       	rjmp	.-32     	; 0x48aa <base64dec+0x13c>
		return 0;
    48ca:	80 e0       	ldi	r24, 0x00	; 0
    48cc:	90 e0       	ldi	r25, 0x00	; 0
	if(term==2){
		((uint8_t*)dest)[0] = buffer[0]<<2 | buffer[1]>>4;
		return 0;
	}
	return -1;
}
    48ce:	0f 90       	pop	r0
    48d0:	0f 90       	pop	r0
    48d2:	0f 90       	pop	r0
    48d4:	0f 90       	pop	r0
    48d6:	df 91       	pop	r29
    48d8:	cf 91       	pop	r28
    48da:	1f 91       	pop	r17
    48dc:	0f 91       	pop	r16
    48de:	ff 90       	pop	r15
    48e0:	ef 90       	pop	r14
    48e2:	08 95       	ret

000048e4 <tickDiffS>:
	return tick - oldtick;
}

uint16_t tickDiffS(uint16_t oldtick)
{
	return tickS - oldtick;
    48e4:	20 91 2d 01 	lds	r18, 0x012D
    48e8:	30 91 2e 01 	lds	r19, 0x012E
}
    48ec:	a9 01       	movw	r20, r18
    48ee:	48 1b       	sub	r20, r24
    48f0:	59 0b       	sbc	r21, r25
    48f2:	ca 01       	movw	r24, r20
    48f4:	08 95       	ret

000048f6 <initTimer>:

void initTimer(void)
{
   TCCR1B |= (1 << WGM12) | (1 << CS12); // Configure timer 1 for CTC mode
    48f6:	e1 e8       	ldi	r30, 0x81	; 129
    48f8:	f0 e0       	ldi	r31, 0x00	; 0
    48fa:	80 81       	ld	r24, Z
    48fc:	8c 60       	ori	r24, 0x0C	; 12
    48fe:	80 83       	st	Z, r24
   OCR1A   = 125; // Compare value 125
    4900:	8d e7       	ldi	r24, 0x7D	; 125
    4902:	90 e0       	ldi	r25, 0x00	; 0
    4904:	90 93 89 00 	sts	0x0089, r25
    4908:	80 93 88 00 	sts	0x0088, r24
   TCCR1A |= (1 << CS12); // Start timer at Fcpu/256
    490c:	e0 e8       	ldi	r30, 0x80	; 128
    490e:	f0 e0       	ldi	r31, 0x00	; 0
    4910:	80 81       	ld	r24, Z
    4912:	84 60       	ori	r24, 0x04	; 4
    4914:	80 83       	st	Z, r24
   
   timerCounter = 0;
    4916:	10 92 88 20 	sts	0x2088, r1
    491a:	10 92 87 20 	sts	0x2087, r1
	
   TIMSK1 |= (1 << OCIE1A); // Enable CTC interrupt
    491e:	ef e6       	ldi	r30, 0x6F	; 111
    4920:	f0 e0       	ldi	r31, 0x00	; 0
    4922:	80 81       	ld	r24, Z
    4924:	82 60       	ori	r24, 0x02	; 2
    4926:	80 83       	st	Z, r24
    4928:	08 95       	ret

0000492a <__vector_13>:
}


ISR(TIMER1_COMPA_vect)
{
    492a:	1f 92       	push	r1
    492c:	0f 92       	push	r0
    492e:	0f b6       	in	r0, 0x3f	; 63
    4930:	0f 92       	push	r0
    4932:	11 24       	eor	r1, r1
    4934:	0b b6       	in	r0, 0x3b	; 59
    4936:	0f 92       	push	r0
    4938:	2f 93       	push	r18
    493a:	3f 93       	push	r19
    493c:	4f 93       	push	r20
    493e:	5f 93       	push	r21
    4940:	6f 93       	push	r22
    4942:	7f 93       	push	r23
    4944:	8f 93       	push	r24
    4946:	9f 93       	push	r25
    4948:	af 93       	push	r26
    494a:	bf 93       	push	r27
    494c:	ef 93       	push	r30
    494e:	ff 93       	push	r31
  tick++;
    4950:	80 91 89 20 	lds	r24, 0x2089
    4954:	90 91 8a 20 	lds	r25, 0x208A
    4958:	01 96       	adiw	r24, 0x01	; 1
    495a:	90 93 8a 20 	sts	0x208A, r25
    495e:	80 93 89 20 	sts	0x2089, r24
  timerCounter++;
    4962:	20 91 87 20 	lds	r18, 0x2087
    4966:	30 91 88 20 	lds	r19, 0x2088
    496a:	2f 5f       	subi	r18, 0xFF	; 255
    496c:	3f 4f       	sbci	r19, 0xFF	; 255
    496e:	30 93 88 20 	sts	0x2088, r19
    4972:	20 93 87 20 	sts	0x2087, r18
uint16_t tickS = 1;
uint16_t timerCounter;

uint16_t tickDiff(uint16_t oldtick)
{
	return tick - oldtick;
    4976:	20 91 8b 20 	lds	r18, 0x208B
    497a:	30 91 8c 20 	lds	r19, 0x208C
    497e:	ac 01       	movw	r20, r24
    4980:	42 1b       	sub	r20, r18
    4982:	53 0b       	sbc	r21, r19
    4984:	9a 01       	movw	r18, r20
ISR(TIMER1_COMPA_vect)
{
  tick++;
  timerCounter++;
  
  if (tickDiff(seconds) >= 500)
    4986:	24 3f       	cpi	r18, 0xF4	; 244
    4988:	31 40       	sbci	r19, 0x01	; 1
    498a:	70 f0       	brcs	.+28     	; 0x49a8 <__vector_13+0x7e>
  {
  	tickS++;
    498c:	20 91 2d 01 	lds	r18, 0x012D
    4990:	30 91 2e 01 	lds	r19, 0x012E
    4994:	2f 5f       	subi	r18, 0xFF	; 255
    4996:	3f 4f       	sbci	r19, 0xFF	; 255
    4998:	30 93 2e 01 	sts	0x012E, r19
    499c:	20 93 2d 01 	sts	0x012D, r18
	seconds = tick;
    49a0:	90 93 8c 20 	sts	0x208C, r25
    49a4:	80 93 8b 20 	sts	0x208B, r24
  }

  if (tick % 10 == 0)
    49a8:	6a e0       	ldi	r22, 0x0A	; 10
    49aa:	70 e0       	ldi	r23, 0x00	; 0
    49ac:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <__udivmodhi4>
    49b0:	89 2b       	or	r24, r25
    49b2:	11 f4       	brne	.+4      	; 0x49b8 <__vector_13+0x8e>
  	twiDecTo();
    49b4:	0e 94 78 23 	call	0x46f0	; 0x46f0 <twiDecTo>
  updateCounters();
    49b8:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <updateCounters>
}
    49bc:	ff 91       	pop	r31
    49be:	ef 91       	pop	r30
    49c0:	bf 91       	pop	r27
    49c2:	af 91       	pop	r26
    49c4:	9f 91       	pop	r25
    49c6:	8f 91       	pop	r24
    49c8:	7f 91       	pop	r23
    49ca:	6f 91       	pop	r22
    49cc:	5f 91       	pop	r21
    49ce:	4f 91       	pop	r20
    49d0:	3f 91       	pop	r19
    49d2:	2f 91       	pop	r18
    49d4:	0f 90       	pop	r0
    49d6:	0b be       	out	0x3b, r0	; 59
    49d8:	0f 90       	pop	r0
    49da:	0f be       	out	0x3f, r0	; 63
    49dc:	0f 90       	pop	r0
    49de:	1f 90       	pop	r1
    49e0:	18 95       	reti

000049e2 <lcd_callback>:
	}

	return false;
}

void lcd_callback(uint8_t statuscode,uint16_t datapos, uint16_t len){
    49e2:	2f 92       	push	r2
    49e4:	3f 92       	push	r3
    49e6:	4f 92       	push	r4
    49e8:	5f 92       	push	r5
    49ea:	6f 92       	push	r6
    49ec:	7f 92       	push	r7
    49ee:	8f 92       	push	r8
    49f0:	9f 92       	push	r9
    49f2:	af 92       	push	r10
    49f4:	bf 92       	push	r11
    49f6:	cf 92       	push	r12
    49f8:	df 92       	push	r13
    49fa:	ef 92       	push	r14
    49fc:	ff 92       	push	r15
    49fe:	0f 93       	push	r16
    4a00:	1f 93       	push	r17
    4a02:	cf 93       	push	r28
    4a04:	df 93       	push	r29
    4a06:	cd b7       	in	r28, 0x3d	; 61
    4a08:	de b7       	in	r29, 0x3e	; 62
    4a0a:	2b 97       	sbiw	r28, 0x0b	; 11
    4a0c:	0f b6       	in	r0, 0x3f	; 63
    4a0e:	f8 94       	cli
    4a10:	de bf       	out	0x3e, r29	; 62
    4a12:	0f be       	out	0x3f, r0	; 63
    4a14:	cd bf       	out	0x3d, r28	; 61
    4a16:	f8 2e       	mov	r15, r24
    4a18:	8b 01       	movw	r16, r22
		printf_P(PSTR("got lcd reply ...\r\n"));
    4a1a:	2b eb       	ldi	r18, 0xBB	; 187
    4a1c:	32 e0       	ldi	r19, 0x02	; 2
    4a1e:	3f 93       	push	r19
    4a20:	2f 93       	push	r18
    4a22:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
        //datapos=0; // supress warning about unused paramter
		start_web_client=0;
    4a26:	10 92 a2 05 	sts	0x05A2, r1
        if (statuscode==0){
    4a2a:	0f 90       	pop	r0
    4a2c:	0f 90       	pop	r0
    4a2e:	f1 10       	cpse	r15, r1
    4a30:	e9 c0       	rjmp	.+466    	; 0x4c04 <lcd_callback+0x222>
                //len=0; // avoid warning about unused variable
				char* buffer = (char *)&(buf[datapos]);
				char* datapos = strstr(buffer, "\r\n\r\n");
    4a32:	68 e0       	ldi	r22, 0x08	; 8
    4a34:	72 e0       	ldi	r23, 0x02	; 2
    4a36:	c8 01       	movw	r24, r16
    4a38:	85 52       	subi	r24, 0x25	; 37
    4a3a:	96 4e       	sbci	r25, 0xE6	; 230
    4a3c:	0e 94 10 3e 	call	0x7c20	; 0x7c20 <strstr>
				datapos += 4;
    4a40:	8c 01       	movw	r16, r24
    4a42:	0c 5f       	subi	r16, 0xFC	; 252
    4a44:	1f 4f       	sbci	r17, 0xFF	; 255
				printf("Data : %s \r\n", datapos);
    4a46:	1f 93       	push	r17
    4a48:	0f 93       	push	r16
    4a4a:	8d e0       	ldi	r24, 0x0D	; 13
    4a4c:	92 e0       	ldi	r25, 0x02	; 2
    4a4e:	9f 93       	push	r25
    4a50:	8f 93       	push	r24
    4a52:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    4a56:	0f 90       	pop	r0
    4a58:	0f 90       	pop	r0
    4a5a:	0f 90       	pop	r0
    4a5c:	0f 90       	pop	r0
				{
					if (datapos[0] == '\n')
						datapos++;

					char crc[6];
					strncpy(crc, datapos+86, 5);
    4a5e:	ce 01       	movw	r24, r28
    4a60:	01 96       	adiw	r24, 0x01	; 1
    4a62:	7c 01       	movw	r14, r24
					crc[5] = '\0';
					printf("CRC IS %s \r\n", crc);
    4a64:	2a e1       	ldi	r18, 0x1A	; 26
    4a66:	82 2e       	mov	r8, r18
    4a68:	22 e0       	ldi	r18, 0x02	; 2
    4a6a:	92 2e       	mov	r9, r18
						uint8_t screenno = datapos[0] - 48;
						printf("LCD crc for screen %c (%u) is valid \r\n", datapos[0], screenno);
						

						char stimeout[5];
						strncpy(stimeout, (datapos+1), 4);
    4a6c:	6e 01       	movw	r12, r28
    4a6e:	97 e0       	ldi	r25, 0x07	; 7
    4a70:	c9 0e       	add	r12, r25
    4a72:	d1 1c       	adc	r13, r1
							lcd_current_screen = 250;
					}

					datapos++;
					datapos = strstr(datapos, "\n");
					printf("Strlen is %u \r\n", strlen(datapos));
    4a74:	33 e9       	ldi	r19, 0x93	; 147
    4a76:	43 2e       	mov	r4, r19
    4a78:	32 e0       	ldi	r19, 0x02	; 2
    4a7a:	53 2e       	mov	r5, r19
				char* buffer = (char *)&(buf[datapos]);
				char* datapos = strstr(buffer, "\r\n\r\n");
				datapos += 4;
				printf("Data : %s \r\n", datapos);

				while (datapos != NULL)
    4a7c:	01 15       	cp	r16, r1
    4a7e:	11 05       	cpc	r17, r1
    4a80:	09 f4       	brne	.+2      	; 0x4a84 <lcd_callback+0xa2>
    4a82:	c0 c0       	rjmp	.+384    	; 0x4c04 <lcd_callback+0x222>
				{
					if (datapos[0] == '\n')
    4a84:	d8 01       	movw	r26, r16
    4a86:	8c 91       	ld	r24, X
    4a88:	8a 30       	cpi	r24, 0x0A	; 10
    4a8a:	11 f4       	brne	.+4      	; 0x4a90 <lcd_callback+0xae>
						datapos++;
    4a8c:	0f 5f       	subi	r16, 0xFF	; 255
    4a8e:	1f 4f       	sbci	r17, 0xFF	; 255

					char crc[6];
					strncpy(crc, datapos+86, 5);
    4a90:	45 e0       	ldi	r20, 0x05	; 5
    4a92:	50 e0       	ldi	r21, 0x00	; 0
    4a94:	b8 01       	movw	r22, r16
    4a96:	6a 5a       	subi	r22, 0xAA	; 170
    4a98:	7f 4f       	sbci	r23, 0xFF	; 255
    4a9a:	c7 01       	movw	r24, r14
    4a9c:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <strncpy>
					crc[5] = '\0';
    4aa0:	1e 82       	std	Y+6, r1	; 0x06
					printf("CRC IS %s \r\n", crc);
    4aa2:	ff 92       	push	r15
    4aa4:	ef 92       	push	r14
    4aa6:	9f 92       	push	r9
    4aa8:	8f 92       	push	r8
    4aaa:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>

					uint16_t crci = atoi(crc);
    4aae:	c7 01       	movw	r24, r14
    4ab0:	0e 94 a4 3c 	call	0x7948	; 0x7948 <atoi>
    4ab4:	3c 01       	movw	r6, r24
    4ab6:	58 01       	movw	r10, r16
    4ab8:	bf ef       	ldi	r27, 0xFF	; 255
    4aba:	ab 1a       	sub	r10, r27
    4abc:	bb 0a       	sbc	r11, r27
    4abe:	f5 01       	movw	r30, r10
    4ac0:	0f 90       	pop	r0
    4ac2:	0f 90       	pop	r0
    4ac4:	0f 90       	pop	r0
    4ac6:	0f 90       	pop	r0
    4ac8:	84 e5       	ldi	r24, 0x54	; 84
					uint16_t crcc = 0;
    4aca:	21 2c       	mov	r2, r1
    4acc:	31 2c       	mov	r3, r1
					for (uint8_t i=0; i<84; i++)
					{
						crcc += datapos[i+1];
    4ace:	91 91       	ld	r25, Z+
    4ad0:	29 0e       	add	r2, r25
    4ad2:	31 1c       	adc	r3, r1
    4ad4:	81 50       	subi	r24, 0x01	; 1
					crc[5] = '\0';
					printf("CRC IS %s \r\n", crc);

					uint16_t crci = atoi(crc);
					uint16_t crcc = 0;
					for (uint8_t i=0; i<84; i++)
    4ad6:	d9 f7       	brne	.-10     	; 0x4ace <lcd_callback+0xec>
					{
						crcc += datapos[i+1];
					}
					printf("Calculated crc is %u \r\n", crcc);
    4ad8:	3f 92       	push	r3
    4ada:	2f 92       	push	r2
    4adc:	a7 e2       	ldi	r26, 0x27	; 39
    4ade:	b2 e0       	ldi	r27, 0x02	; 2
    4ae0:	bf 93       	push	r27
    4ae2:	af 93       	push	r26
    4ae4:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
					if (crcc == crci)
    4ae8:	0f 90       	pop	r0
    4aea:	0f 90       	pop	r0
    4aec:	0f 90       	pop	r0
    4aee:	0f 90       	pop	r0
    4af0:	26 14       	cp	r2, r6
    4af2:	37 04       	cpc	r3, r7
    4af4:	09 f0       	breq	.+2      	; 0x4af8 <lcd_callback+0x116>
    4af6:	64 c0       	rjmp	.+200    	; 0x4bc0 <lcd_callback+0x1de>
					{
						uint8_t screenno = datapos[0] - 48;
    4af8:	d8 01       	movw	r26, r16
    4afa:	8c 91       	ld	r24, X
    4afc:	90 ed       	ldi	r25, 0xD0	; 208
    4afe:	39 2e       	mov	r3, r25
    4b00:	38 0e       	add	r3, r24
						printf("LCD crc for screen %c (%u) is valid \r\n", datapos[0], screenno);
    4b02:	63 2c       	mov	r6, r3
    4b04:	71 2c       	mov	r7, r1
    4b06:	1f 92       	push	r1
    4b08:	3f 92       	push	r3
    4b0a:	1f 92       	push	r1
    4b0c:	8f 93       	push	r24
    4b0e:	af e3       	ldi	r26, 0x3F	; 63
    4b10:	b2 e0       	ldi	r27, 0x02	; 2
    4b12:	bf 93       	push	r27
    4b14:	af 93       	push	r26
    4b16:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
						

						char stimeout[5];
						strncpy(stimeout, (datapos+1), 4);
    4b1a:	44 e0       	ldi	r20, 0x04	; 4
    4b1c:	50 e0       	ldi	r21, 0x00	; 0
    4b1e:	b5 01       	movw	r22, r10
    4b20:	c6 01       	movw	r24, r12
    4b22:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <strncpy>
						stimeout[4] = '\0';
    4b26:	1b 86       	std	Y+11, r1	; 0x0b
						printf("Timeout is %s \r\n", stimeout);
    4b28:	df 92       	push	r13
    4b2a:	cf 92       	push	r12
    4b2c:	a6 e6       	ldi	r26, 0x66	; 102
    4b2e:	b2 e0       	ldi	r27, 0x02	; 2
    4b30:	bf 93       	push	r27
    4b32:	af 93       	push	r26
    4b34:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
						lcd_timeouts[screenno] = atoi(stimeout);
    4b38:	c6 01       	movw	r24, r12
    4b3a:	0e 94 a4 3c 	call	0x7948	; 0x7948 <atoi>
    4b3e:	f3 01       	movw	r30, r6
    4b40:	e1 51       	subi	r30, 0x11	; 17
    4b42:	ff 4d       	sbci	r31, 0xDF	; 223
    4b44:	80 83       	st	Z, r24
						printf("Set timeout for %u to %u \r\n", screenno, lcd_timeouts[screenno]);
    4b46:	99 27       	eor	r25, r25
    4b48:	9f 93       	push	r25
    4b4a:	8f 93       	push	r24
    4b4c:	1f 92       	push	r1
    4b4e:	3f 92       	push	r3
    4b50:	a7 e7       	ldi	r26, 0x77	; 119
    4b52:	b2 e0       	ldi	r27, 0x02	; 2
    4b54:	bf 93       	push	r27
    4b56:	af 93       	push	r26
    4b58:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    4b5c:	0b 5f       	subi	r16, 0xFB	; 251
    4b5e:	1f 4f       	sbci	r17, 0xFF	; 255
    4b60:	f4 e5       	ldi	r31, 0x54	; 84
    4b62:	3f 9e       	mul	r3, r31
    4b64:	a0 01       	movw	r20, r0
    4b66:	11 24       	eor	r1, r1
    4b68:	4b 50       	subi	r20, 0x0B	; 11
    4b6a:	5f 4d       	sbci	r21, 0xDF	; 223
    4b6c:	0f b6       	in	r0, 0x3f	; 63
    4b6e:	f8 94       	cli
    4b70:	de bf       	out	0x3e, r29	; 62
    4b72:	0f be       	out	0x3f, r0	; 63
    4b74:	cd bf       	out	0x3d, r28	; 61
    4b76:	80 e0       	ldi	r24, 0x00	; 0
    4b78:	90 e0       	ldi	r25, 0x00	; 0
    4b7a:	ba 01       	movw	r22, r20
    4b7c:	68 0f       	add	r22, r24
    4b7e:	79 1f       	adc	r23, r25
					strncpy(crc, datapos+86, 5);
					crc[5] = '\0';
					printf("CRC IS %s \r\n", crc);

					uint16_t crci = atoi(crc);
					uint16_t crcc = 0;
    4b80:	20 e0       	ldi	r18, 0x00	; 0
    4b82:	30 e0       	ldi	r19, 0x00	; 0
    4b84:	f8 01       	movw	r30, r16
    4b86:	e2 0f       	add	r30, r18
    4b88:	f3 1f       	adc	r31, r19
						uint16_t linepos = 5;
						for (uint8_t lineno=0; lineno<4; lineno++)
						{
							for (uint8_t c=0; c<20; c++)
							{
								lines[screenno][lineno][c] = datapos[linepos++];
    4b8a:	a0 81       	ld	r26, Z
    4b8c:	fb 01       	movw	r30, r22
    4b8e:	e2 0f       	add	r30, r18
    4b90:	f3 1f       	adc	r31, r19
    4b92:	a0 83       	st	Z, r26
    4b94:	2f 5f       	subi	r18, 0xFF	; 255
    4b96:	3f 4f       	sbci	r19, 0xFF	; 255
						printf("Set timeout for %u to %u \r\n", screenno, lcd_timeouts[screenno]);

						uint16_t linepos = 5;
						for (uint8_t lineno=0; lineno<4; lineno++)
						{
							for (uint8_t c=0; c<20; c++)
    4b98:	24 31       	cpi	r18, 0x14	; 20
    4b9a:	31 05       	cpc	r19, r1
    4b9c:	99 f7       	brne	.-26     	; 0x4b84 <lcd_callback+0x1a2>
    4b9e:	fa 01       	movw	r30, r20
    4ba0:	e8 0f       	add	r30, r24
    4ba2:	f9 1f       	adc	r31, r25
							{
								lines[screenno][lineno][c] = datapos[linepos++];
							}
							lines[screenno][lineno][20] = '\0';
    4ba4:	14 8a       	std	Z+20, r1	; 0x14
    4ba6:	45 96       	adiw	r24, 0x15	; 21
    4ba8:	0c 5e       	subi	r16, 0xEC	; 236
    4baa:	1f 4f       	sbci	r17, 0xFF	; 255
						printf("Timeout is %s \r\n", stimeout);
						lcd_timeouts[screenno] = atoi(stimeout);
						printf("Set timeout for %u to %u \r\n", screenno, lcd_timeouts[screenno]);

						uint16_t linepos = 5;
						for (uint8_t lineno=0; lineno<4; lineno++)
    4bac:	84 35       	cpi	r24, 0x54	; 84
    4bae:	91 05       	cpc	r25, r1
    4bb0:	21 f7       	brne	.-56     	; 0x4b7a <lcd_callback+0x198>
								lines[screenno][lineno][c] = datapos[linepos++];
							}
							lines[screenno][lineno][20] = '\0';
						}

						if (lcd_current_screen == 254)	//waiting for data
    4bb2:	80 91 2f 01 	lds	r24, 0x012F
    4bb6:	8e 3f       	cpi	r24, 0xFE	; 254
    4bb8:	19 f4       	brne	.+6      	; 0x4bc0 <lcd_callback+0x1de>
							lcd_current_screen = 250;
    4bba:	9a ef       	ldi	r25, 0xFA	; 250
    4bbc:	90 93 2f 01 	sts	0x012F, r25
					}

					datapos++;
					datapos = strstr(datapos, "\n");
    4bc0:	6a e0       	ldi	r22, 0x0A	; 10
    4bc2:	70 e0       	ldi	r23, 0x00	; 0
    4bc4:	c5 01       	movw	r24, r10
    4bc6:	0e 94 d4 3d 	call	0x7ba8	; 0x7ba8 <strchr>
    4bca:	8c 01       	movw	r16, r24
					printf("Strlen is %u \r\n", strlen(datapos));
    4bcc:	fc 01       	movw	r30, r24
    4bce:	01 90       	ld	r0, Z+
    4bd0:	00 20       	and	r0, r0
    4bd2:	e9 f7       	brne	.-6      	; 0x4bce <lcd_callback+0x1ec>
    4bd4:	31 97       	sbiw	r30, 0x01	; 1
    4bd6:	e8 1b       	sub	r30, r24
    4bd8:	f9 0b       	sbc	r31, r25
    4bda:	ff 93       	push	r31
    4bdc:	ef 93       	push	r30
    4bde:	5f 92       	push	r5
    4be0:	4f 92       	push	r4
    4be2:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
					if (strlen(datapos) < 80) break;
    4be6:	f8 01       	movw	r30, r16
    4be8:	01 90       	ld	r0, Z+
    4bea:	00 20       	and	r0, r0
    4bec:	e9 f7       	brne	.-6      	; 0x4be8 <lcd_callback+0x206>
    4bee:	31 97       	sbiw	r30, 0x01	; 1
    4bf0:	e0 1b       	sub	r30, r16
    4bf2:	f1 0b       	sbc	r31, r17
    4bf4:	0f 90       	pop	r0
    4bf6:	0f 90       	pop	r0
    4bf8:	0f 90       	pop	r0
    4bfa:	0f 90       	pop	r0
    4bfc:	e0 35       	cpi	r30, 0x50	; 80
    4bfe:	f1 05       	cpc	r31, r1
    4c00:	08 f0       	brcs	.+2      	; 0x4c04 <lcd_callback+0x222>
    4c02:	3c cf       	rjmp	.-392    	; 0x4a7c <lcd_callback+0x9a>
				}
		}
}
    4c04:	2b 96       	adiw	r28, 0x0b	; 11
    4c06:	0f b6       	in	r0, 0x3f	; 63
    4c08:	f8 94       	cli
    4c0a:	de bf       	out	0x3e, r29	; 62
    4c0c:	0f be       	out	0x3f, r0	; 63
    4c0e:	cd bf       	out	0x3d, r28	; 61
    4c10:	df 91       	pop	r29
    4c12:	cf 91       	pop	r28
    4c14:	1f 91       	pop	r17
    4c16:	0f 91       	pop	r16
    4c18:	ff 90       	pop	r15
    4c1a:	ef 90       	pop	r14
    4c1c:	df 90       	pop	r13
    4c1e:	cf 90       	pop	r12
    4c20:	bf 90       	pop	r11
    4c22:	af 90       	pop	r10
    4c24:	9f 90       	pop	r9
    4c26:	8f 90       	pop	r8
    4c28:	7f 90       	pop	r7
    4c2a:	6f 90       	pop	r6
    4c2c:	5f 90       	pop	r5
    4c2e:	4f 90       	pop	r4
    4c30:	3f 90       	pop	r3
    4c32:	2f 90       	pop	r2
    4c34:	08 95       	ret

00004c36 <lcd_write_screen>:
extern bool alarmDetected;
extern uint8_t alarmTimeout;
#endif

void lcd_write_screen(uint8_t screen)
{
    4c36:	ff 92       	push	r15
    4c38:	0f 93       	push	r16
    4c3a:	1f 93       	push	r17
    4c3c:	cf 93       	push	r28
    4c3e:	df 93       	push	r29
    4c40:	94 e5       	ldi	r25, 0x54	; 84
    4c42:	89 9f       	mul	r24, r25
    4c44:	80 01       	movw	r16, r0
    4c46:	11 24       	eor	r1, r1
    4c48:	c0 e0       	ldi	r28, 0x00	; 0
    4c4a:	d0 e0       	ldi	r29, 0x00	; 0
	for (uint8_t i=0; i<4; i++)
    4c4c:	f1 2c       	mov	r15, r1
    4c4e:	0b 50       	subi	r16, 0x0B	; 11
    4c50:	1f 4d       	sbci	r17, 0xDF	; 223
	{
		LCDsetCursor(i, 0);
    4c52:	60 e0       	ldi	r22, 0x00	; 0
    4c54:	8f 2d       	mov	r24, r15
    4c56:	0e 94 8d 37 	call	0x6f1a	; 0x6f1a <LCDsetCursor>
		LCDwrite(lines[screen][i], 0);
    4c5a:	60 e0       	ldi	r22, 0x00	; 0
    4c5c:	c8 01       	movw	r24, r16
    4c5e:	8c 0f       	add	r24, r28
    4c60:	9d 1f       	adc	r25, r29
    4c62:	0e 94 aa 37 	call	0x6f54	; 0x6f54 <LCDwrite>
extern uint8_t alarmTimeout;
#endif

void lcd_write_screen(uint8_t screen)
{
	for (uint8_t i=0; i<4; i++)
    4c66:	f3 94       	inc	r15
    4c68:	65 96       	adiw	r28, 0x15	; 21
    4c6a:	84 e0       	ldi	r24, 0x04	; 4
    4c6c:	f8 12       	cpse	r15, r24
    4c6e:	f1 cf       	rjmp	.-30     	; 0x4c52 <lcd_write_screen+0x1c>
	{
		LCDsetCursor(i, 0);
		LCDwrite(lines[screen][i], 0);
	}
}
    4c70:	df 91       	pop	r29
    4c72:	cf 91       	pop	r28
    4c74:	1f 91       	pop	r17
    4c76:	0f 91       	pop	r16
    4c78:	ff 90       	pop	r15
    4c7a:	08 95       	ret

00004c7c <lcd_update>:

//called every second
void lcd_update()
{
    4c7c:	cf 93       	push	r28
	if (lcd_current_screen == 255)
    4c7e:	80 91 2f 01 	lds	r24, 0x012F
    4c82:	8f 3f       	cpi	r24, 0xFF	; 255
    4c84:	79 f4       	brne	.+30     	; 0x4ca4 <lcd_update+0x28>
	{
		printf("First call to lcd_update, starting web client \r\n");
    4c86:	83 ea       	ldi	r24, 0xA3	; 163
    4c88:	92 e0       	ldi	r25, 0x02	; 2
    4c8a:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
		//first screen update
		if (start_web_client == 0)
    4c8e:	80 91 a2 05 	lds	r24, 0x05A2
    4c92:	81 11       	cpse	r24, r1
    4c94:	2a c0       	rjmp	.+84     	; 0x4cea <lcd_update+0x6e>
		{
			start_web_client = 10;
    4c96:	8a e0       	ldi	r24, 0x0A	; 10
    4c98:	80 93 a2 05 	sts	0x05A2, r24
			lcd_current_screen = 254;
    4c9c:	8e ef       	ldi	r24, 0xFE	; 254
    4c9e:	80 93 2f 01 	sts	0x012F, r24
    4ca2:	23 c0       	rjmp	.+70     	; 0x4cea <lcd_update+0x6e>
			//waiting for LCD data, callback function sets it to 250 when theres valid data
		}
	} else if (lcd_current_screen == 254)
    4ca4:	8e 3f       	cpi	r24, 0xFE	; 254
    4ca6:	91 f4       	brne	.+36     	; 0x4ccc <lcd_update+0x50>
	{
		if (lcd_network_timer++ > 60)
    4ca8:	80 91 97 05 	lds	r24, 0x0597
    4cac:	91 e0       	ldi	r25, 0x01	; 1
    4cae:	98 0f       	add	r25, r24
    4cb0:	90 93 97 05 	sts	0x0597, r25
    4cb4:	8d 33       	cpi	r24, 0x3D	; 61
    4cb6:	c8 f0       	brcs	.+50     	; 0x4cea <lcd_update+0x6e>
		{
			printf("Retry LCD get\r\n");
    4cb8:	83 ed       	ldi	r24, 0xD3	; 211
    4cba:	92 e0       	ldi	r25, 0x02	; 2
    4cbc:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
			start_web_client = 10;
    4cc0:	8a e0       	ldi	r24, 0x0A	; 10
    4cc2:	80 93 a2 05 	sts	0x05A2, r24
			lcd_network_timer=0;
    4cc6:	10 92 97 05 	sts	0x0597, r1
    4cca:	0f c0       	rjmp	.+30     	; 0x4cea <lcd_update+0x6e>
		}
	} else if (lcd_current_screen == 250)
    4ccc:	8a 3f       	cpi	r24, 0xFA	; 250
    4cce:	69 f4       	brne	.+26     	; 0x4cea <lcd_update+0x6e>
	{
		printf("Web client set screen to 250 \r\n");
    4cd0:	82 ee       	ldi	r24, 0xE2	; 226
    4cd2:	92 e0       	ldi	r25, 0x02	; 2
    4cd4:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
		lcd_current_screen = 0;
    4cd8:	10 92 2f 01 	sts	0x012F, r1
		lcd_current_timeleft = lcd_timeouts[0];
    4cdc:	80 91 ef 20 	lds	r24, 0x20EF
    4ce0:	80 93 98 05 	sts	0x0598, r24
		lcd_write_screen(0);
    4ce4:	80 e0       	ldi	r24, 0x00	; 0
    4ce6:	0e 94 1b 26 	call	0x4c36	; 0x4c36 <lcd_write_screen>
	}

	if (lcd_current_screen >= 0 && lcd_current_screen <= 6)
    4cea:	80 91 2f 01 	lds	r24, 0x012F
    4cee:	87 30       	cpi	r24, 0x07	; 7
    4cf0:	08 f0       	brcs	.+2      	; 0x4cf4 <lcd_update+0x78>
    4cf2:	76 c0       	rjmp	.+236    	; 0x4de0 <lcd_update+0x164>
	{
		if (lcd_current_timeleft > 0)
    4cf4:	90 91 98 05 	lds	r25, 0x0598
    4cf8:	99 23       	and	r25, r25
    4cfa:	19 f0       	breq	.+6      	; 0x4d02 <lcd_update+0x86>
			lcd_current_timeleft--;
    4cfc:	91 50       	subi	r25, 0x01	; 1
    4cfe:	90 93 98 05 	sts	0x0598, r25
		if (lcd_network_timer > 0)
    4d02:	90 91 97 05 	lds	r25, 0x0597
    4d06:	99 23       	and	r25, r25
    4d08:	19 f0       	breq	.+6      	; 0x4d10 <lcd_update+0x94>
			lcd_network_timer--;
    4d0a:	91 50       	subi	r25, 0x01	; 1
    4d0c:	90 93 97 05 	sts	0x0597, r25
    4d10:	ef ee       	ldi	r30, 0xEF	; 239
    4d12:	f0 e2       	ldi	r31, 0x20	; 32

		//regular run
		uint8_t screensDefined = 0;
    4d14:	c0 e0       	ldi	r28, 0x00	; 0
		for (uint8_t i=0; i<6; i++)
		{
			if (lcd_timeouts[i] > 0)
    4d16:	91 91       	ld	r25, Z+
    4d18:	91 11       	cpse	r25, r1
				screensDefined++;
    4d1a:	cf 5f       	subi	r28, 0xFF	; 255
		if (lcd_network_timer > 0)
			lcd_network_timer--;

		//regular run
		uint8_t screensDefined = 0;
		for (uint8_t i=0; i<6; i++)
    4d1c:	90 e2       	ldi	r25, 0x20	; 32
    4d1e:	e5 3f       	cpi	r30, 0xF5	; 245
    4d20:	f9 07       	cpc	r31, r25
    4d22:	c9 f7       	brne	.-14     	; 0x4d16 <lcd_update+0x9a>
		{
			if (lcd_timeouts[i] > 0)
				screensDefined++;
		}

		printf("Timeout left for %u is %u \r\n", lcd_current_screen, lcd_current_timeleft);
    4d24:	90 91 98 05 	lds	r25, 0x0598
    4d28:	1f 92       	push	r1
    4d2a:	9f 93       	push	r25
    4d2c:	1f 92       	push	r1
    4d2e:	8f 93       	push	r24
    4d30:	81 e0       	ldi	r24, 0x01	; 1
    4d32:	93 e0       	ldi	r25, 0x03	; 3
    4d34:	9f 93       	push	r25
    4d36:	8f 93       	push	r24
    4d38:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>

		if (lcd_network_timer == 0
    4d3c:	0f 90       	pop	r0
    4d3e:	0f 90       	pop	r0
    4d40:	0f 90       	pop	r0
    4d42:	0f 90       	pop	r0
    4d44:	0f 90       	pop	r0
    4d46:	0f 90       	pop	r0
    4d48:	80 91 97 05 	lds	r24, 0x0597
    4d4c:	81 11       	cpse	r24, r1
    4d4e:	1d c0       	rjmp	.+58     	; 0x4d8a <lcd_update+0x10e>
			&&
    4d50:	c1 30       	cpi	r28, 0x01	; 1
    4d52:	21 f4       	brne	.+8      	; 0x4d5c <lcd_update+0xe0>
			(
				(screensDefined == 1 && lcd_current_timeleft < 20)
    4d54:	80 91 98 05 	lds	r24, 0x0598
    4d58:	84 31       	cpi	r24, 0x14	; 20
    4d5a:	48 f0       	brcs	.+18     	; 0x4d6e <lcd_update+0xf2>
				||
				(screensDefined == lcd_current_screen+1)
    4d5c:	2c 2f       	mov	r18, r28
    4d5e:	30 e0       	ldi	r19, 0x00	; 0
    4d60:	80 91 2f 01 	lds	r24, 0x012F
    4d64:	90 e0       	ldi	r25, 0x00	; 0
    4d66:	01 96       	adiw	r24, 0x01	; 1

		if (lcd_network_timer == 0
			&&
			(
				(screensDefined == 1 && lcd_current_timeleft < 20)
				||
    4d68:	28 17       	cp	r18, r24
    4d6a:	39 07       	cpc	r19, r25
    4d6c:	71 f4       	brne	.+28     	; 0x4d8a <lcd_update+0x10e>
				(screensDefined == lcd_current_screen+1)
			)
		   )
		   {
				if (start_web_client == 0)
    4d6e:	80 91 a2 05 	lds	r24, 0x05A2
    4d72:	81 11       	cpse	r24, r1
    4d74:	0a c0       	rjmp	.+20     	; 0x4d8a <lcd_update+0x10e>
				{
					printf("Requesting new LCD data\r\n");
    4d76:	8e e1       	ldi	r24, 0x1E	; 30
    4d78:	93 e0       	ldi	r25, 0x03	; 3
    4d7a:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
					start_web_client = 10;
    4d7e:	8a e0       	ldi	r24, 0x0A	; 10
    4d80:	80 93 a2 05 	sts	0x05A2, r24
					lcd_network_timer = 30;
    4d84:	8e e1       	ldi	r24, 0x1E	; 30
    4d86:	80 93 97 05 	sts	0x0597, r24
				}
		   }

		   if (lcd_current_timeleft == 0)
    4d8a:	80 91 98 05 	lds	r24, 0x0598
    4d8e:	81 11       	cpse	r24, r1
    4d90:	27 c0       	rjmp	.+78     	; 0x4de0 <lcd_update+0x164>
		   {
				printf("Time to change screen ... \r\n");
    4d92:	87 e3       	ldi	r24, 0x37	; 55
    4d94:	93 e0       	ldi	r25, 0x03	; 3
    4d96:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
				lcd_current_screen++;
    4d9a:	80 91 2f 01 	lds	r24, 0x012F
    4d9e:	8f 5f       	subi	r24, 0xFF	; 255
				if (lcd_current_screen >= screensDefined) //screens are zero indexed
    4da0:	8c 17       	cp	r24, r28
    4da2:	18 f4       	brcc	.+6      	; 0x4daa <lcd_update+0x12e>
		   }

		   if (lcd_current_timeleft == 0)
		   {
				printf("Time to change screen ... \r\n");
				lcd_current_screen++;
    4da4:	80 93 2f 01 	sts	0x012F, r24
    4da8:	02 c0       	rjmp	.+4      	; 0x4dae <lcd_update+0x132>
				if (lcd_current_screen >= screensDefined) //screens are zero indexed
					lcd_current_screen = 0;
    4daa:	10 92 2f 01 	sts	0x012F, r1
				lcd_write_screen(lcd_current_screen);
    4dae:	80 91 2f 01 	lds	r24, 0x012F
    4db2:	0e 94 1b 26 	call	0x4c36	; 0x4c36 <lcd_write_screen>
				lcd_current_timeleft = lcd_timeouts[lcd_current_screen];
    4db6:	80 91 2f 01 	lds	r24, 0x012F
    4dba:	e8 2f       	mov	r30, r24
    4dbc:	f0 e0       	ldi	r31, 0x00	; 0
    4dbe:	e1 51       	subi	r30, 0x11	; 17
    4dc0:	ff 4d       	sbci	r31, 0xDF	; 223
    4dc2:	90 81       	ld	r25, Z
    4dc4:	90 93 98 05 	sts	0x0598, r25
				printf("Changed to screen %u ... \r\n",lcd_current_screen);
    4dc8:	1f 92       	push	r1
    4dca:	8f 93       	push	r24
    4dcc:	83 e5       	ldi	r24, 0x53	; 83
    4dce:	93 e0       	ldi	r25, 0x03	; 3
    4dd0:	9f 93       	push	r25
    4dd2:	8f 93       	push	r24
    4dd4:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    4dd8:	0f 90       	pop	r0
    4dda:	0f 90       	pop	r0
    4ddc:	0f 90       	pop	r0
    4dde:	0f 90       	pop	r0
		   }
	}
}
    4de0:	cf 91       	pop	r28
    4de2:	08 95       	ret

00004de4 <initTimedEvents>:
#endif

//called once per second
void initTimedEvents()
{
	printf("Init timed_events \r\n");
    4de4:	8f e6       	ldi	r24, 0x6F	; 111
    4de6:	93 e0       	ldi	r25, 0x03	; 3
    4de8:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
    4dec:	ef e8       	ldi	r30, 0x8F	; 143
    4dee:	f0 e2       	ldi	r31, 0x20	; 32
	for (uint16_t i=0; i<(12*4); i++)
	{
		timed_events[i] = 0;
    4df0:	11 92       	st	Z+, r1
    4df2:	11 92       	st	Z+, r1

//called once per second
void initTimedEvents()
{
	printf("Init timed_events \r\n");
	for (uint16_t i=0; i<(12*4); i++)
    4df4:	80 e2       	ldi	r24, 0x20	; 32
    4df6:	ef 3e       	cpi	r30, 0xEF	; 239
    4df8:	f8 07       	cpc	r31, r24
    4dfa:	d1 f7       	brne	.-12     	; 0x4df0 <initTimedEvents+0xc>
	{
		timed_events[i] = 0;
	}
}
    4dfc:	08 95       	ret

00004dfe <checkTimedEvents>:

void checkTimedEvents()
{
    4dfe:	cf 92       	push	r12
    4e00:	df 92       	push	r13
    4e02:	ef 92       	push	r14
    4e04:	ff 92       	push	r15
    4e06:	0f 93       	push	r16
    4e08:	1f 93       	push	r17
    4e0a:	cf 93       	push	r28
    4e0c:	df 93       	push	r29
	uptime++;
    4e0e:	80 91 a4 05 	lds	r24, 0x05A4
    4e12:	90 91 a5 05 	lds	r25, 0x05A5
    4e16:	a0 91 a6 05 	lds	r26, 0x05A6
    4e1a:	b0 91 a7 05 	lds	r27, 0x05A7
    4e1e:	01 96       	adiw	r24, 0x01	; 1
    4e20:	a1 1d       	adc	r26, r1
    4e22:	b1 1d       	adc	r27, r1
    4e24:	80 93 a4 05 	sts	0x05A4, r24
    4e28:	90 93 a5 05 	sts	0x05A5, r25
    4e2c:	a0 93 a6 05 	sts	0x05A6, r26
    4e30:	b0 93 a7 05 	sts	0x05A7, r27
    4e34:	cf e8       	ldi	r28, 0x8F	; 143
    4e36:	d0 e2       	ldi	r29, 0x20	; 32
    4e38:	00 e0       	ldi	r16, 0x00	; 0
    4e3a:	10 e0       	ldi	r17, 0x00	; 0

	for (uint8_t i=0; i<12; i++)
	{
		if (timed_events[i*4] != 0)
		{
			printf("Found timed event %u %u %u %u %u... \r\n", i, timed_events[(i*4)+0], timed_events[(i*4)+1], timed_events[(i*4)+2], timed_events[(i*4)+3]);
    4e3c:	43 e8       	ldi	r20, 0x83	; 131
    4e3e:	e4 2e       	mov	r14, r20
    4e40:	43 e0       	ldi	r20, 0x03	; 3
    4e42:	f4 2e       	mov	r15, r20
					} else {
				#endif
				if (timed_events[(i*4)+2] == 1)
					CLEARBIT(PORTC, (2+timed_events[(i*4)+1]));
				else
					SETBIT(PORTC, (2+timed_events[(i*4)+1]));
    4e44:	cc 24       	eor	r12, r12
    4e46:	c3 94       	inc	r12
    4e48:	d1 2c       	mov	r13, r1
{
	uptime++;

	for (uint8_t i=0; i<12; i++)
	{
		if (timed_events[i*4] != 0)
    4e4a:	88 81       	ld	r24, Y
    4e4c:	99 81       	ldd	r25, Y+1	; 0x01
    4e4e:	00 97       	sbiw	r24, 0x00	; 0
    4e50:	09 f4       	brne	.+2      	; 0x4e54 <checkTimedEvents+0x56>
    4e52:	5d c0       	rjmp	.+186    	; 0x4f0e <checkTimedEvents+0x110>
		{
			printf("Found timed event %u %u %u %u %u... \r\n", i, timed_events[(i*4)+0], timed_events[(i*4)+1], timed_events[(i*4)+2], timed_events[(i*4)+3]);
    4e54:	2f 81       	ldd	r18, Y+7	; 0x07
    4e56:	2f 93       	push	r18
    4e58:	2e 81       	ldd	r18, Y+6	; 0x06
    4e5a:	2f 93       	push	r18
    4e5c:	2d 81       	ldd	r18, Y+5	; 0x05
    4e5e:	2f 93       	push	r18
    4e60:	2c 81       	ldd	r18, Y+4	; 0x04
    4e62:	2f 93       	push	r18
    4e64:	2b 81       	ldd	r18, Y+3	; 0x03
    4e66:	2f 93       	push	r18
    4e68:	2a 81       	ldd	r18, Y+2	; 0x02
    4e6a:	2f 93       	push	r18
    4e6c:	9f 93       	push	r25
    4e6e:	8f 93       	push	r24
    4e70:	1f 93       	push	r17
    4e72:	0f 93       	push	r16
    4e74:	ff 92       	push	r15
    4e76:	ef 92       	push	r14
    4e78:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
			{
				printf("Pin not in acceptable range (%u)\r\n",timed_events[(i*4)+1]);
				break;
			}
			#else
			if (timed_events[(i*4)+1] >= 4)
    4e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4e80:	2d b7       	in	r18, 0x3d	; 61
    4e82:	3e b7       	in	r19, 0x3e	; 62
    4e84:	24 5f       	subi	r18, 0xF4	; 244
    4e86:	3f 4f       	sbci	r19, 0xFF	; 255
    4e88:	0f b6       	in	r0, 0x3f	; 63
    4e8a:	f8 94       	cli
    4e8c:	3e bf       	out	0x3e, r19	; 62
    4e8e:	0f be       	out	0x3f, r0	; 63
    4e90:	2d bf       	out	0x3d, r18	; 61
    4e92:	84 30       	cpi	r24, 0x04	; 4
    4e94:	91 05       	cpc	r25, r1
    4e96:	68 f0       	brcs	.+26     	; 0x4eb2 <checkTimedEvents+0xb4>
			{
				printf("Pin not in acceptable range (%u)\r\n",timed_events[(i*4)+1]);
    4e98:	9f 93       	push	r25
    4e9a:	8f 93       	push	r24
    4e9c:	8a ea       	ldi	r24, 0xAA	; 170
    4e9e:	93 e0       	ldi	r25, 0x03	; 3
    4ea0:	9f 93       	push	r25
    4ea2:	8f 93       	push	r24
    4ea4:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
				break;
    4ea8:	0f 90       	pop	r0
    4eaa:	0f 90       	pop	r0
    4eac:	0f 90       	pop	r0
    4eae:	0f 90       	pop	r0
    4eb0:	35 c0       	rjmp	.+106    	; 0x4f1c <checkTimedEvents+0x11e>
			}
			#endif

			timed_events[(i*4)+3] = timed_events[(i*4)+3]-1;
    4eb2:	8e 81       	ldd	r24, Y+6	; 0x06
    4eb4:	9f 81       	ldd	r25, Y+7	; 0x07
    4eb6:	01 97       	sbiw	r24, 0x01	; 1
    4eb8:	9f 83       	std	Y+7, r25	; 0x07
    4eba:	8e 83       	std	Y+6, r24	; 0x06

			if (timed_events[(i*4)+3] == 0)
    4ebc:	89 2b       	or	r24, r25
    4ebe:	39 f5       	brne	.+78     	; 0x4f0e <checkTimedEvents+0x110>
			{
				printf("TIMEOUT\r\n");
    4ec0:	8d ec       	ldi	r24, 0xCD	; 205
    4ec2:	93 e0       	ldi	r25, 0x03	; 3
    4ec4:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
							simpleSensorValues[timed_events[(i*4)+1]] = 0;
						else
							simpleSensorValues[timed_events[(i*4)+1]] = 1;
					} else {
				#endif
				if (timed_events[(i*4)+2] == 1)
    4ec8:	2c 81       	ldd	r18, Y+4	; 0x04
    4eca:	3d 81       	ldd	r19, Y+5	; 0x05
    4ecc:	8a 81       	ldd	r24, Y+2	; 0x02
    4ece:	9b 81       	ldd	r25, Y+3	; 0x03
    4ed0:	21 30       	cpi	r18, 0x01	; 1
    4ed2:	31 05       	cpc	r19, r1
    4ed4:	51 f4       	brne	.+20     	; 0x4eea <checkTimedEvents+0xec>
					CLEARBIT(PORTC, (2+timed_events[(i*4)+1]));
    4ed6:	48 b1       	in	r20, 0x08	; 8
    4ed8:	02 96       	adiw	r24, 0x02	; 2
    4eda:	08 2e       	mov	r0, r24
    4edc:	01 c0       	rjmp	.+2      	; 0x4ee0 <checkTimedEvents+0xe2>
    4ede:	22 0f       	add	r18, r18
    4ee0:	0a 94       	dec	r0
    4ee2:	ea f7       	brpl	.-6      	; 0x4ede <checkTimedEvents+0xe0>
    4ee4:	20 95       	com	r18
    4ee6:	24 23       	and	r18, r20
    4ee8:	09 c0       	rjmp	.+18     	; 0x4efc <checkTimedEvents+0xfe>
				else
					SETBIT(PORTC, (2+timed_events[(i*4)+1]));
    4eea:	28 b1       	in	r18, 0x08	; 8
    4eec:	02 96       	adiw	r24, 0x02	; 2
    4eee:	a6 01       	movw	r20, r12
    4ef0:	02 c0       	rjmp	.+4      	; 0x4ef6 <checkTimedEvents+0xf8>
    4ef2:	44 0f       	add	r20, r20
    4ef4:	55 1f       	adc	r21, r21
    4ef6:	8a 95       	dec	r24
    4ef8:	e2 f7       	brpl	.-8      	; 0x4ef2 <checkTimedEvents+0xf4>
    4efa:	24 2b       	or	r18, r20
    4efc:	28 b9       	out	0x08, r18	; 8
				#if SBNG_TARGET == 50
				}
				#endif
				//reset the array
				timed_events[(i*4)+0] = 0;
    4efe:	19 82       	std	Y+1, r1	; 0x01
    4f00:	18 82       	st	Y, r1
				timed_events[(i*4)+1] = 0;
    4f02:	1b 82       	std	Y+3, r1	; 0x03
    4f04:	1a 82       	std	Y+2, r1	; 0x02
				timed_events[(i*4)+2] = 0;
    4f06:	1d 82       	std	Y+5, r1	; 0x05
    4f08:	1c 82       	std	Y+4, r1	; 0x04
				timed_events[(i*4)+3] = 0;
    4f0a:	1f 82       	std	Y+7, r1	; 0x07
    4f0c:	1e 82       	std	Y+6, r1	; 0x06
    4f0e:	0f 5f       	subi	r16, 0xFF	; 255
    4f10:	1f 4f       	sbci	r17, 0xFF	; 255
    4f12:	28 96       	adiw	r28, 0x08	; 8

void checkTimedEvents()
{
	uptime++;

	for (uint8_t i=0; i<12; i++)
    4f14:	0c 30       	cpi	r16, 0x0C	; 12
    4f16:	11 05       	cpc	r17, r1
    4f18:	09 f0       	breq	.+2      	; 0x4f1c <checkTimedEvents+0x11e>
    4f1a:	97 cf       	rjmp	.-210    	; 0x4e4a <checkTimedEvents+0x4c>
				timed_events[(i*4)+2] = 0;
				timed_events[(i*4)+3] = 0;
			}
		}
	}
}
    4f1c:	df 91       	pop	r29
    4f1e:	cf 91       	pop	r28
    4f20:	1f 91       	pop	r17
    4f22:	0f 91       	pop	r16
    4f24:	ff 90       	pop	r15
    4f26:	ef 90       	pop	r14
    4f28:	df 90       	pop	r13
    4f2a:	cf 90       	pop	r12
    4f2c:	08 95       	ret

00004f2e <addTimedEvent>:

void addTimedEvent(uint8_t id, uint8_t pin, uint8_t state, uint8_t delay)
{
    4f2e:	ef 92       	push	r14
    4f30:	ff 92       	push	r15
    4f32:	1f 93       	push	r17
    4f34:	cf 93       	push	r28
    4f36:	df 93       	push	r29
    4f38:	00 d0       	rcall	.+0      	; 0x4f3a <addTimedEvent+0xc>
    4f3a:	1f 92       	push	r1
    4f3c:	cd b7       	in	r28, 0x3d	; 61
    4f3e:	de b7       	in	r29, 0x3e	; 62
    4f40:	18 2f       	mov	r17, r24
	printf("addTimedEvent(%d, %d, %d, %d)\r\n",id,pin,state,delay);
    4f42:	1f 92       	push	r1
    4f44:	2f 93       	push	r18
    4f46:	1f 92       	push	r1
    4f48:	4f 93       	push	r20
    4f4a:	1f 92       	push	r1
    4f4c:	6f 93       	push	r22
    4f4e:	1f 92       	push	r1
    4f50:	8f 93       	push	r24
    4f52:	e6 ed       	ldi	r30, 0xD6	; 214
    4f54:	f3 e0       	ldi	r31, 0x03	; 3
    4f56:	ff 93       	push	r31
    4f58:	ef 93       	push	r30
    4f5a:	2b 83       	std	Y+3, r18	; 0x03
    4f5c:	4a 83       	std	Y+2, r20	; 0x02
    4f5e:	69 83       	std	Y+1, r22	; 0x01
    4f60:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    4f64:	2f e8       	ldi	r18, 0x8F	; 143
    4f66:	e2 2e       	mov	r14, r18
    4f68:	20 e2       	ldi	r18, 0x20	; 32
    4f6a:	f2 2e       	mov	r15, r18
    4f6c:	0f b6       	in	r0, 0x3f	; 63
    4f6e:	f8 94       	cli
    4f70:	de bf       	out	0x3e, r29	; 62
    4f72:	0f be       	out	0x3f, r0	; 63
    4f74:	cd bf       	out	0x3d, r28	; 61
    4f76:	e0 e0       	ldi	r30, 0x00	; 0
    4f78:	f0 e0       	ldi	r31, 0x00	; 0
    4f7a:	69 81       	ldd	r22, Y+1	; 0x01
    4f7c:	4a 81       	ldd	r20, Y+2	; 0x02
    4f7e:	2b 81       	ldd	r18, Y+3	; 0x03

	for (uint8_t i=0; i<12; i++)
	{
		if (timed_events[i*4] == 0)
    4f80:	d7 01       	movw	r26, r14
    4f82:	8d 91       	ld	r24, X+
    4f84:	9c 91       	ld	r25, X
    4f86:	89 2b       	or	r24, r25
    4f88:	09 f5       	brne	.+66     	; 0x4fcc <addTimedEvent+0x9e>
		{
			timed_events[(i*4)+0] = id;
    4f8a:	df 01       	movw	r26, r30
    4f8c:	aa 0f       	add	r26, r26
    4f8e:	bb 1f       	adc	r27, r27
    4f90:	a1 57       	subi	r26, 0x71	; 113
    4f92:	bf 4d       	sbci	r27, 0xDF	; 223
    4f94:	81 2f       	mov	r24, r17
    4f96:	90 e0       	ldi	r25, 0x00	; 0
    4f98:	8d 93       	st	X+, r24
    4f9a:	9c 93       	st	X, r25
			timed_events[(i*4)+1] = pin;
    4f9c:	df 01       	movw	r26, r30
    4f9e:	aa 0f       	add	r26, r26
    4fa0:	bb 1f       	adc	r27, r27
    4fa2:	af 56       	subi	r26, 0x6F	; 111
    4fa4:	bf 4d       	sbci	r27, 0xDF	; 223
    4fa6:	70 e0       	ldi	r23, 0x00	; 0
    4fa8:	6d 93       	st	X+, r22
    4faa:	7c 93       	st	X, r23
			timed_events[(i*4)+2] = state;
    4fac:	df 01       	movw	r26, r30
    4fae:	aa 0f       	add	r26, r26
    4fb0:	bb 1f       	adc	r27, r27
    4fb2:	ad 56       	subi	r26, 0x6D	; 109
    4fb4:	bf 4d       	sbci	r27, 0xDF	; 223
    4fb6:	50 e0       	ldi	r21, 0x00	; 0
    4fb8:	4d 93       	st	X+, r20
    4fba:	5c 93       	st	X, r21
			timed_events[(i*4)+3] = delay;
    4fbc:	ee 0f       	add	r30, r30
    4fbe:	ff 1f       	adc	r31, r31
    4fc0:	eb 56       	subi	r30, 0x6B	; 107
    4fc2:	ff 4d       	sbci	r31, 0xDF	; 223
    4fc4:	30 e0       	ldi	r19, 0x00	; 0
    4fc6:	31 83       	std	Z+1, r19	; 0x01
    4fc8:	20 83       	st	Z, r18
			break;
    4fca:	07 c0       	rjmp	.+14     	; 0x4fda <addTimedEvent+0xac>
    4fcc:	34 96       	adiw	r30, 0x04	; 4
    4fce:	b8 e0       	ldi	r27, 0x08	; 8
    4fd0:	eb 0e       	add	r14, r27
    4fd2:	f1 1c       	adc	r15, r1

void addTimedEvent(uint8_t id, uint8_t pin, uint8_t state, uint8_t delay)
{
	printf("addTimedEvent(%d, %d, %d, %d)\r\n",id,pin,state,delay);

	for (uint8_t i=0; i<12; i++)
    4fd4:	e0 33       	cpi	r30, 0x30	; 48
    4fd6:	f1 05       	cpc	r31, r1
    4fd8:	99 f6       	brne	.-90     	; 0x4f80 <addTimedEvent+0x52>
			timed_events[(i*4)+2] = state;
			timed_events[(i*4)+3] = delay;
			break;
		}
	}
}
    4fda:	0f 90       	pop	r0
    4fdc:	0f 90       	pop	r0
    4fde:	0f 90       	pop	r0
    4fe0:	df 91       	pop	r29
    4fe2:	cf 91       	pop	r28
    4fe4:	1f 91       	pop	r17
    4fe6:	ff 90       	pop	r15
    4fe8:	ef 90       	pop	r14
    4fea:	08 95       	ret

00004fec <browserresult_callback>:
				}
		}
}

//Her skal vi hndtere svaret fra stokerlog, der kan komme SET PIN STATE, LCD LINE TEXT, TIME DDMMYY HHMMSS
void browserresult_callback(uint8_t statuscode,uint16_t datapos, uint16_t len){
    4fec:	2f 92       	push	r2
    4fee:	3f 92       	push	r3
    4ff0:	4f 92       	push	r4
    4ff2:	5f 92       	push	r5
    4ff4:	6f 92       	push	r6
    4ff6:	7f 92       	push	r7
    4ff8:	8f 92       	push	r8
    4ffa:	9f 92       	push	r9
    4ffc:	af 92       	push	r10
    4ffe:	bf 92       	push	r11
    5000:	cf 92       	push	r12
    5002:	df 92       	push	r13
    5004:	ef 92       	push	r14
    5006:	ff 92       	push	r15
    5008:	0f 93       	push	r16
    500a:	1f 93       	push	r17
    500c:	cf 93       	push	r28
    500e:	df 93       	push	r29
    5010:	cd b7       	in	r28, 0x3d	; 61
    5012:	de b7       	in	r29, 0x3e	; 62
    5014:	2c 97       	sbiw	r28, 0x0c	; 12
    5016:	0f b6       	in	r0, 0x3f	; 63
    5018:	f8 94       	cli
    501a:	de bf       	out	0x3e, r29	; 62
    501c:	0f be       	out	0x3f, r0	; 63
    501e:	cd bf       	out	0x3d, r28	; 61
    5020:	f8 2e       	mov	r15, r24
    5022:	8b 01       	movw	r16, r22
		printf_P(PSTR("got reply ...\r\n"));
    5024:	2b ea       	ldi	r18, 0xAB	; 171
    5026:	32 e0       	ldi	r19, 0x02	; 2
    5028:	3f 93       	push	r19
    502a:	2f 93       	push	r18
    502c:	4b 87       	std	Y+11, r20	; 0x0b
    502e:	5c 87       	std	Y+12, r21	; 0x0c
    5030:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
        //datapos=0; // supress warning about unused paramter
		start_web_client=0;
    5034:	10 92 a2 05 	sts	0x05A2, r1
        if (statuscode==0){
    5038:	0f 90       	pop	r0
    503a:	0f 90       	pop	r0
    503c:	4b 85       	ldd	r20, Y+11	; 0x0b
    503e:	5c 85       	ldd	r21, Y+12	; 0x0c
    5040:	f1 10       	cpse	r15, r1
    5042:	fa c0       	rjmp	.+500    	; 0x5238 <browserresult_callback+0x24c>
                //len=0; // avoid warning about unused variable
				printf("Datapos %u len %u \r\n", datapos, len);
    5044:	5f 93       	push	r21
    5046:	4f 93       	push	r20
    5048:	1f 93       	push	r17
    504a:	0f 93       	push	r16
    504c:	86 ef       	ldi	r24, 0xF6	; 246
    504e:	93 e0       	ldi	r25, 0x03	; 3
    5050:	9f 93       	push	r25
    5052:	8f 93       	push	r24
    5054:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
				char* buffer = (char *)&(buf[datapos]);
    5058:	05 52       	subi	r16, 0x25	; 37
    505a:	16 4e       	sbci	r17, 0xE6	; 230
				printf("%s \r\n\r\nEND\r\n", buffer);
    505c:	1f 93       	push	r17
    505e:	0f 93       	push	r16
    5060:	8b e0       	ldi	r24, 0x0B	; 11
    5062:	94 e0       	ldi	r25, 0x04	; 4
    5064:	9f 93       	push	r25
    5066:	8f 93       	push	r24
    5068:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
				char* datapos = strstr(buffer, "\r\n\r\n");
    506c:	68 e0       	ldi	r22, 0x08	; 8
    506e:	72 e0       	ldi	r23, 0x02	; 2
    5070:	c8 01       	movw	r24, r16
    5072:	0e 94 10 3e 	call	0x7c20	; 0x7c20 <strstr>
				datapos += 4;
    5076:	04 96       	adiw	r24, 0x04	; 4
				printf("Data : %s \r\n", datapos);
    5078:	9f 93       	push	r25
    507a:	8f 93       	push	r24
    507c:	8d e0       	ldi	r24, 0x0D	; 13
    507e:	92 e0       	ldi	r25, 0x02	; 2
    5080:	9f 93       	push	r25
    5082:	8f 93       	push	r24
    5084:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
*/
//For each line, parse contents

//This is a safety measure, to prevent the bot from running a bad event when rebooted, events time out after 5minutes
//if (uptime > 300) {
			char* line = strstr(buffer, "RIO");
    5088:	68 e1       	ldi	r22, 0x18	; 24
    508a:	74 e0       	ldi	r23, 0x04	; 4
    508c:	c8 01       	movw	r24, r16
    508e:	0e 94 10 3e 	call	0x7c20	; 0x7c20 <strstr>
    5092:	8c 01       	movw	r16, r24
    5094:	0f b6       	in	r0, 0x3f	; 63
    5096:	f8 94       	cli
    5098:	de bf       	out	0x3e, r29	; 62
    509a:	0f be       	out	0x3f, r0	; 63
    509c:	cd bf       	out	0x3d, r28	; 61
			while (line != NULL)
			{
				unsigned int id, pin, state, delay;
				printf("RAW %s \r\n", line);
				sscanf(line, "RIO %u %u %u %u", &id, &pin, &state, &delay);
    509e:	ce 01       	movw	r24, r28
    50a0:	01 96       	adiw	r24, 0x01	; 1
    50a2:	9a 87       	std	Y+10, r25	; 0x0a
    50a4:	89 87       	std	Y+9, r24	; 0x09
    50a6:	1e 01       	movw	r2, r28
    50a8:	93 e0       	ldi	r25, 0x03	; 3
    50aa:	29 0e       	add	r2, r25
    50ac:	31 1c       	adc	r3, r1
    50ae:	2e 01       	movw	r4, r28
    50b0:	a5 e0       	ldi	r26, 0x05	; 5
    50b2:	4a 0e       	add	r4, r26
    50b4:	51 1c       	adc	r5, r1
    50b6:	7e 01       	movw	r14, r28
    50b8:	b7 e0       	ldi	r27, 0x07	; 7
    50ba:	eb 0e       	add	r14, r27
    50bc:	f1 1c       	adc	r15, r1
    50be:	36 e2       	ldi	r19, 0x26	; 38
    50c0:	c3 2e       	mov	r12, r19
    50c2:	34 e0       	ldi	r19, 0x04	; 4
    50c4:	d3 2e       	mov	r13, r19
				printf("Found RIO line id:%u pin:%u state:%u delay:%u \r\n",id,pin,state,delay);
    50c6:	46 e3       	ldi	r20, 0x36	; 54
    50c8:	a4 2e       	mov	r10, r20
    50ca:	44 e0       	ldi	r20, 0x04	; 4
    50cc:	b4 2e       	mov	r11, r20
				printf("Last event is %lu \r\n", last_rio_event);
    50ce:	57 e6       	ldi	r21, 0x67	; 103
    50d0:	85 2e       	mov	r8, r21
    50d2:	54 e0       	ldi	r21, 0x04	; 4
    50d4:	95 2e       	mov	r9, r21
					} else {
					#endif
						if (state == 1)
							SETBIT(PORTC, (2+pin));
						else
							CLEARBIT(PORTC, (2+pin));
    50d6:	66 24       	eor	r6, r6
    50d8:	63 94       	inc	r6
    50da:	71 2c       	mov	r7, r1
//For each line, parse contents

//This is a safety measure, to prevent the bot from running a bad event when rebooted, events time out after 5minutes
//if (uptime > 300) {
			char* line = strstr(buffer, "RIO");
			while (line != NULL)
    50dc:	01 15       	cp	r16, r1
    50de:	11 05       	cpc	r17, r1
    50e0:	09 f4       	brne	.+2      	; 0x50e4 <browserresult_callback+0xf8>
    50e2:	95 c0       	rjmp	.+298    	; 0x520e <browserresult_callback+0x222>
			{
				unsigned int id, pin, state, delay;
				printf("RAW %s \r\n", line);
    50e4:	1f 93       	push	r17
    50e6:	0f 93       	push	r16
    50e8:	ac e1       	ldi	r26, 0x1C	; 28
    50ea:	b4 e0       	ldi	r27, 0x04	; 4
    50ec:	bf 93       	push	r27
    50ee:	af 93       	push	r26
    50f0:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
				sscanf(line, "RIO %u %u %u %u", &id, &pin, &state, &delay);
    50f4:	5a 85       	ldd	r21, Y+10	; 0x0a
    50f6:	5f 93       	push	r21
    50f8:	89 85       	ldd	r24, Y+9	; 0x09
    50fa:	8f 93       	push	r24
    50fc:	3f 92       	push	r3
    50fe:	2f 92       	push	r2
    5100:	5f 92       	push	r5
    5102:	4f 92       	push	r4
    5104:	ff 92       	push	r15
    5106:	ef 92       	push	r14
    5108:	df 92       	push	r13
    510a:	cf 92       	push	r12
    510c:	1f 93       	push	r17
    510e:	0f 93       	push	r16
    5110:	0e 94 4a 3f 	call	0x7e94	; 0x7e94 <sscanf>
				printf("Found RIO line id:%u pin:%u state:%u delay:%u \r\n",id,pin,state,delay);
    5114:	8a 81       	ldd	r24, Y+2	; 0x02
    5116:	8f 93       	push	r24
    5118:	89 81       	ldd	r24, Y+1	; 0x01
    511a:	8f 93       	push	r24
    511c:	8c 81       	ldd	r24, Y+4	; 0x04
    511e:	8f 93       	push	r24
    5120:	8b 81       	ldd	r24, Y+3	; 0x03
    5122:	8f 93       	push	r24
    5124:	8e 81       	ldd	r24, Y+6	; 0x06
    5126:	8f 93       	push	r24
    5128:	8d 81       	ldd	r24, Y+5	; 0x05
    512a:	8f 93       	push	r24
    512c:	88 85       	ldd	r24, Y+8	; 0x08
    512e:	8f 93       	push	r24
    5130:	8f 81       	ldd	r24, Y+7	; 0x07
    5132:	8f 93       	push	r24
    5134:	bf 92       	push	r11
    5136:	af 92       	push	r10
    5138:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
				printf("Last event is %lu \r\n", last_rio_event);
    513c:	80 91 ab 05 	lds	r24, 0x05AB
    5140:	8f 93       	push	r24
    5142:	80 91 aa 05 	lds	r24, 0x05AA
    5146:	8f 93       	push	r24
    5148:	80 91 a9 05 	lds	r24, 0x05A9
    514c:	8f 93       	push	r24
    514e:	80 91 a8 05 	lds	r24, 0x05A8
    5152:	8f 93       	push	r24
    5154:	9f 92       	push	r9
    5156:	8f 92       	push	r8
    5158:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
				if (id <= last_rio_event)
    515c:	4f 81       	ldd	r20, Y+7	; 0x07
    515e:	58 85       	ldd	r21, Y+8	; 0x08
    5160:	60 e0       	ldi	r22, 0x00	; 0
    5162:	70 e0       	ldi	r23, 0x00	; 0
    5164:	0f b6       	in	r0, 0x3f	; 63
    5166:	f8 94       	cli
    5168:	de bf       	out	0x3e, r29	; 62
    516a:	0f be       	out	0x3f, r0	; 63
    516c:	cd bf       	out	0x3d, r28	; 61
    516e:	80 91 a8 05 	lds	r24, 0x05A8
    5172:	90 91 a9 05 	lds	r25, 0x05A9
    5176:	a0 91 aa 05 	lds	r26, 0x05AA
    517a:	b0 91 ab 05 	lds	r27, 0x05AB
    517e:	84 17       	cp	r24, r20
    5180:	95 07       	cpc	r25, r21
    5182:	a6 07       	cpc	r26, r22
    5184:	b7 07       	cpc	r27, r23
    5186:	28 f0       	brcs	.+10     	; 0x5192 <browserresult_callback+0x1a6>
				{
					printf("Repeated RIO event detected \r\n");
    5188:	8c e7       	ldi	r24, 0x7C	; 124
    518a:	94 e0       	ldi	r25, 0x04	; 4
    518c:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
    5190:	33 c0       	rjmp	.+102    	; 0x51f8 <browserresult_callback+0x20c>
					if (pin > 20)
					{
						simpleSensorValues[pin] = state;
					} else {
					#endif
						if (state == 1)
    5192:	2b 81       	ldd	r18, Y+3	; 0x03
    5194:	3c 81       	ldd	r19, Y+4	; 0x04
    5196:	8d 81       	ldd	r24, Y+5	; 0x05
    5198:	9e 81       	ldd	r25, Y+6	; 0x06
    519a:	21 30       	cpi	r18, 0x01	; 1
    519c:	31 05       	cpc	r19, r1
    519e:	51 f4       	brne	.+20     	; 0x51b4 <browserresult_callback+0x1c8>
							SETBIT(PORTC, (2+pin));
    51a0:	48 b1       	in	r20, 0x08	; 8
    51a2:	02 96       	adiw	r24, 0x02	; 2
    51a4:	08 2e       	mov	r0, r24
    51a6:	01 c0       	rjmp	.+2      	; 0x51aa <browserresult_callback+0x1be>
    51a8:	22 0f       	add	r18, r18
    51aa:	0a 94       	dec	r0
    51ac:	ea f7       	brpl	.-6      	; 0x51a8 <browserresult_callback+0x1bc>
    51ae:	42 2b       	or	r20, r18
    51b0:	48 b9       	out	0x08, r20	; 8
    51b2:	0c c0       	rjmp	.+24     	; 0x51cc <browserresult_callback+0x1e0>
						else
							CLEARBIT(PORTC, (2+pin));
    51b4:	28 b1       	in	r18, 0x08	; 8
    51b6:	02 96       	adiw	r24, 0x02	; 2
    51b8:	a3 01       	movw	r20, r6
    51ba:	02 c0       	rjmp	.+4      	; 0x51c0 <browserresult_callback+0x1d4>
    51bc:	44 0f       	add	r20, r20
    51be:	55 1f       	adc	r21, r21
    51c0:	8a 95       	dec	r24
    51c2:	e2 f7       	brpl	.-8      	; 0x51bc <browserresult_callback+0x1d0>
    51c4:	ca 01       	movw	r24, r20
    51c6:	80 95       	com	r24
    51c8:	82 23       	and	r24, r18
    51ca:	88 b9       	out	0x08, r24	; 8
					#if SBNG_TARGET == 50
					}
					#endif
					if (delay != 0)
    51cc:	29 81       	ldd	r18, Y+1	; 0x01
    51ce:	3a 81       	ldd	r19, Y+2	; 0x02
    51d0:	21 15       	cp	r18, r1
    51d2:	31 05       	cpc	r19, r1
    51d4:	29 f0       	breq	.+10     	; 0x51e0 <browserresult_callback+0x1f4>
						addTimedEvent(id, pin, state, delay);
    51d6:	4b 81       	ldd	r20, Y+3	; 0x03
    51d8:	6d 81       	ldd	r22, Y+5	; 0x05
    51da:	8f 81       	ldd	r24, Y+7	; 0x07
    51dc:	0e 94 97 27 	call	0x4f2e	; 0x4f2e <addTimedEvent>

					last_rio_event=id;
    51e0:	8f 81       	ldd	r24, Y+7	; 0x07
    51e2:	98 85       	ldd	r25, Y+8	; 0x08
    51e4:	a0 e0       	ldi	r26, 0x00	; 0
    51e6:	b0 e0       	ldi	r27, 0x00	; 0
    51e8:	80 93 a8 05 	sts	0x05A8, r24
    51ec:	90 93 a9 05 	sts	0x05A9, r25
    51f0:	a0 93 aa 05 	sts	0x05AA, r26
    51f4:	b0 93 ab 05 	sts	0x05AB, r27
				}

				line = strstr(line, "\n");
    51f8:	6a e0       	ldi	r22, 0x0A	; 10
    51fa:	70 e0       	ldi	r23, 0x00	; 0
    51fc:	c8 01       	movw	r24, r16
    51fe:	0e 94 d4 3d 	call	0x7ba8	; 0x7ba8 <strchr>
				line = strstr(line, "RIO");
    5202:	68 e1       	ldi	r22, 0x18	; 24
    5204:	74 e0       	ldi	r23, 0x04	; 4
    5206:	0e 94 10 3e 	call	0x7c20	; 0x7c20 <strstr>
    520a:	8c 01       	movw	r16, r24
    520c:	67 cf       	rjmp	.-306    	; 0x50dc <browserresult_callback+0xf0>
			}
//}

                web_client_sendok++;
    520e:	80 91 9a 05 	lds	r24, 0x059A
    5212:	90 91 9b 05 	lds	r25, 0x059B
    5216:	a0 91 9c 05 	lds	r26, 0x059C
    521a:	b0 91 9d 05 	lds	r27, 0x059D
    521e:	01 96       	adiw	r24, 0x01	; 1
    5220:	a1 1d       	adc	r26, r1
    5222:	b1 1d       	adc	r27, r1
    5224:	80 93 9a 05 	sts	0x059A, r24
    5228:	90 93 9b 05 	sts	0x059B, r25
    522c:	a0 93 9c 05 	sts	0x059C, r26
    5230:	b0 93 9d 05 	sts	0x059D, r27
				web_client_monitor=0;
    5234:	10 92 99 05 	sts	0x0599, r1
        }
}
    5238:	2c 96       	adiw	r28, 0x0c	; 12
    523a:	0f b6       	in	r0, 0x3f	; 63
    523c:	f8 94       	cli
    523e:	de bf       	out	0x3e, r29	; 62
    5240:	0f be       	out	0x3f, r0	; 63
    5242:	cd bf       	out	0x3d, r28	; 61
    5244:	df 91       	pop	r29
    5246:	cf 91       	pop	r28
    5248:	1f 91       	pop	r17
    524a:	0f 91       	pop	r16
    524c:	ff 90       	pop	r15
    524e:	ef 90       	pop	r14
    5250:	df 90       	pop	r13
    5252:	cf 90       	pop	r12
    5254:	bf 90       	pop	r11
    5256:	af 90       	pop	r10
    5258:	9f 90       	pop	r9
    525a:	8f 90       	pop	r8
    525c:	7f 90       	pop	r7
    525e:	6f 90       	pop	r6
    5260:	5f 90       	pop	r5
    5262:	4f 90       	pop	r4
    5264:	3f 90       	pop	r3
    5266:	2f 90       	pop	r2
    5268:	08 95       	ret

0000526a <http200ok>:
}


uint16_t http200ok(void)
{
        return(fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Type: text/html\r\nPragma: no-cache\r\n\r\n")));
    526a:	42 e8       	ldi	r20, 0x82	; 130
    526c:	5c e0       	ldi	r21, 0x0C	; 12
    526e:	60 e0       	ldi	r22, 0x00	; 0
    5270:	70 e0       	ldi	r23, 0x00	; 0
    5272:	8b ed       	ldi	r24, 0xDB	; 219
    5274:	99 e1       	ldi	r25, 0x19	; 25
    5276:	0c 94 30 12 	jmp	0x2460	; 0x2460 <fill_tcp_data_p>

0000527a <http200gzok>:
}

uint16_t http200gzok(void)
{
        return(fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 200 OK\r\nContent-Encoding: gzip\r\nContent-Type: text/html\r\nPragma: no-cache\r\n\r\n")));
    527a:	4b e2       	ldi	r20, 0x2B	; 43
    527c:	5c e0       	ldi	r21, 0x0C	; 12
    527e:	60 e0       	ldi	r22, 0x00	; 0
    5280:	70 e0       	ldi	r23, 0x00	; 0
    5282:	8b ed       	ldi	r24, 0xDB	; 219
    5284:	99 e1       	ldi	r25, 0x19	; 25
    5286:	0c 94 30 12 	jmp	0x2460	; 0x2460 <fill_tcp_data_p>

0000528a <https401>:
}

uint16_t https401(void)
{
        return(fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 401 Authorization Required\r\nWWW-Authenticate: Basic realm=\"Stokerbot admin\"\r\nContent-Type: text/html\r\nPragma: no-cache\r\n\r\n")));
    528a:	47 ea       	ldi	r20, 0xA7	; 167
    528c:	5b e0       	ldi	r21, 0x0B	; 11
    528e:	60 e0       	ldi	r22, 0x00	; 0
    5290:	70 e0       	ldi	r23, 0x00	; 0
    5292:	8b ed       	ldi	r24, 0xDB	; 219
    5294:	99 e1       	ldi	r25, 0x19	; 25
    5296:	0c 94 30 12 	jmp	0x2460	; 0x2460 <fill_tcp_data_p>

0000529a <print_export_htm>:
}


uint16_t print_export_htm(uint8_t *buf)
{
    529a:	2f 92       	push	r2
    529c:	3f 92       	push	r3
    529e:	4f 92       	push	r4
    52a0:	5f 92       	push	r5
    52a2:	6f 92       	push	r6
    52a4:	7f 92       	push	r7
    52a6:	8f 92       	push	r8
    52a8:	9f 92       	push	r9
    52aa:	af 92       	push	r10
    52ac:	bf 92       	push	r11
    52ae:	cf 92       	push	r12
    52b0:	df 92       	push	r13
    52b2:	ef 92       	push	r14
    52b4:	ff 92       	push	r15
    52b6:	0f 93       	push	r16
    52b8:	1f 93       	push	r17
    52ba:	cf 93       	push	r28
    52bc:	df 93       	push	r29
    52be:	00 d0       	rcall	.+0      	; 0x52c0 <print_export_htm+0x26>
    52c0:	00 d0       	rcall	.+0      	; 0x52c2 <print_export_htm+0x28>
    52c2:	cd b7       	in	r28, 0x3d	; 61
    52c4:	de b7       	in	r29, 0x3e	; 62
    52c6:	7c 01       	movw	r14, r24
        uint16_t plen;

		plen=http200ok();
    52c8:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>
    52cc:	9c 83       	std	Y+4, r25	; 0x04
    52ce:	8b 83       	std	Y+3, r24	; 0x03
    52d0:	0a e1       	ldi	r16, 0x1A	; 26
    52d2:	16 e0       	ldi	r17, 0x06	; 6

	    for (uint8_t i=0; i<MAXSENSORS; i++)
	    {  
	      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
	      {
	        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    52d4:	e1 e7       	ldi	r30, 0x71	; 113
    52d6:	8e 2e       	mov	r8, r30
    52d8:	e2 e0       	ldi	r30, 0x02	; 2
    52da:	9e 2e       	mov	r9, r30
    
	        sprintf_P(tempbuf, PSTR("%02X%02X%02X%02X%02X%02X%02X%02X %c%d.%04d\r\n"),
    52dc:	fa e7       	ldi	r31, 0x7A	; 122
    52de:	cf 2e       	mov	r12, r31
    52e0:	fb e0       	ldi	r31, 0x0B	; 11
    52e2:	df 2e       	mov	r13, r31
    52e4:	aa e0       	ldi	r26, 0x0A	; 10
    52e6:	aa 2e       	mov	r10, r26
    52e8:	a9 e0       	ldi	r26, 0x09	; 9
    52ea:	ba 2e       	mov	r11, r26
    52ec:	f8 01       	movw	r30, r16
    52ee:	3a 97       	sbiw	r30, 0x0a	; 10

		plen=http200ok();

	    for (uint8_t i=0; i<MAXSENSORS; i++)
	    {  
	      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
    52f0:	20 81       	ld	r18, Z
    52f2:	22 23       	and	r18, r18
    52f4:	09 f4       	brne	.+2      	; 0x52f8 <print_export_htm+0x5e>
    52f6:	43 c0       	rjmp	.+134    	; 0x537e <print_export_htm+0xe4>
    52f8:	39 96       	adiw	r30, 0x09	; 9
	      {
	        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    52fa:	30 81       	ld	r19, Z
    52fc:	38 9d       	mul	r19, r8
    52fe:	c0 01       	movw	r24, r0
    5300:	39 9d       	mul	r19, r9
    5302:	90 0d       	add	r25, r0
    5304:	11 24       	eor	r1, r1
    
	        sprintf_P(tempbuf, PSTR("%02X%02X%02X%02X%02X%02X%02X%02X %c%d.%04d\r\n"),
    5306:	9f 93       	push	r25
    5308:	8f 93       	push	r24
    530a:	31 97       	sbiw	r30, 0x01	; 1
    530c:	80 81       	ld	r24, Z
    530e:	1f 92       	push	r1
    5310:	8f 93       	push	r24
    5312:	d8 01       	movw	r26, r16
    5314:	8c 91       	ld	r24, X
    5316:	1f 92       	push	r1
    5318:	8f 93       	push	r24
    531a:	31 97       	sbiw	r30, 0x01	; 1
    531c:	80 81       	ld	r24, Z
    531e:	1f 92       	push	r1
    5320:	8f 93       	push	r24
    5322:	31 97       	sbiw	r30, 0x01	; 1
    5324:	80 81       	ld	r24, Z
    5326:	1f 92       	push	r1
    5328:	8f 93       	push	r24
    532a:	31 97       	sbiw	r30, 0x01	; 1
    532c:	80 81       	ld	r24, Z
    532e:	1f 92       	push	r1
    5330:	8f 93       	push	r24
    5332:	31 97       	sbiw	r30, 0x01	; 1
    5334:	80 81       	ld	r24, Z
    5336:	1f 92       	push	r1
    5338:	8f 93       	push	r24
    533a:	31 97       	sbiw	r30, 0x01	; 1
    533c:	80 81       	ld	r24, Z
    533e:	1f 92       	push	r1
    5340:	8f 93       	push	r24
    5342:	31 97       	sbiw	r30, 0x01	; 1
    5344:	80 81       	ld	r24, Z
    5346:	1f 92       	push	r1
    5348:	8f 93       	push	r24
    534a:	31 97       	sbiw	r30, 0x01	; 1
    534c:	80 81       	ld	r24, Z
    534e:	1f 92       	push	r1
    5350:	8f 93       	push	r24
    5352:	1f 92       	push	r1
    5354:	2f 93       	push	r18
    5356:	df 92       	push	r13
    5358:	cf 92       	push	r12
    535a:	bf 92       	push	r11
    535c:	af 92       	push	r10
    535e:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
	              sensorValues[(i*SENSORSIZE)+SIGN],
	              sensorValues[(i*SENSORSIZE)+VALUE1],
	              frac
	            );      

	            plen = fill_tcp_data(buf,plen,tempbuf);
    5362:	4a e0       	ldi	r20, 0x0A	; 10
    5364:	59 e0       	ldi	r21, 0x09	; 9
    5366:	6b 81       	ldd	r22, Y+3	; 0x03
    5368:	7c 81       	ldd	r23, Y+4	; 0x04
    536a:	c7 01       	movw	r24, r14
    536c:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5370:	9c 83       	std	Y+4, r25	; 0x04
    5372:	8b 83       	std	Y+3, r24	; 0x03
    5374:	0f b6       	in	r0, 0x3f	; 63
    5376:	f8 94       	cli
    5378:	de bf       	out	0x3e, r29	; 62
    537a:	0f be       	out	0x3f, r0	; 63
    537c:	cd bf       	out	0x3d, r28	; 61
    537e:	05 5f       	subi	r16, 0xF5	; 245
    5380:	1f 4f       	sbci	r17, 0xFF	; 255
{
        uint16_t plen;

		plen=http200ok();

	    for (uint8_t i=0; i<MAXSENSORS; i++)
    5382:	f8 e0       	ldi	r31, 0x08	; 8
    5384:	0e 3a       	cpi	r16, 0xAE	; 174
    5386:	1f 07       	cpc	r17, r31
    5388:	09 f0       	breq	.+2      	; 0x538c <print_export_htm+0xf2>
    538a:	b0 cf       	rjmp	.-160    	; 0x52ec <print_export_htm+0x52>
    538c:	5a e0       	ldi	r21, 0x0A	; 10
    538e:	c5 2e       	mov	r12, r21
    5390:	59 e1       	ldi	r21, 0x19	; 25
    5392:	d5 2e       	mov	r13, r21
    5394:	00 e0       	ldi	r16, 0x00	; 0
    5396:	10 e0       	ldi	r17, 0x00	; 0
		}
	
		//Analog pins
		for (uint8_t i=0; i<=7; i++)
		{
			sprintf_P(tempbuf, PSTR("A%u %u\r\n"),i,simpleSensorValues[i]);
    5398:	61 e7       	ldi	r22, 0x71	; 113
    539a:	86 2e       	mov	r8, r22
    539c:	6b e0       	ldi	r22, 0x0B	; 11
    539e:	96 2e       	mov	r9, r22
    53a0:	7a e0       	ldi	r23, 0x0A	; 10
    53a2:	a7 2e       	mov	r10, r23
    53a4:	79 e0       	ldi	r23, 0x09	; 9
    53a6:	b7 2e       	mov	r11, r23
    53a8:	d6 01       	movw	r26, r12
    53aa:	8c 91       	ld	r24, X
    53ac:	11 96       	adiw	r26, 0x01	; 1
    53ae:	9c 91       	ld	r25, X
    53b0:	b2 e0       	ldi	r27, 0x02	; 2
    53b2:	cb 0e       	add	r12, r27
    53b4:	d1 1c       	adc	r13, r1
    53b6:	9f 93       	push	r25
    53b8:	8f 93       	push	r24
    53ba:	1f 93       	push	r17
    53bc:	0f 93       	push	r16
    53be:	9f 92       	push	r9
    53c0:	8f 92       	push	r8
    53c2:	bf 92       	push	r11
    53c4:	af 92       	push	r10
    53c6:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			plen = fill_tcp_data(buf,plen,tempbuf);
    53ca:	4a e0       	ldi	r20, 0x0A	; 10
    53cc:	59 e0       	ldi	r21, 0x09	; 9
    53ce:	6b 81       	ldd	r22, Y+3	; 0x03
    53d0:	7c 81       	ldd	r23, Y+4	; 0x04
    53d2:	c7 01       	movw	r24, r14
    53d4:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    53d8:	9c 83       	std	Y+4, r25	; 0x04
    53da:	8b 83       	std	Y+3, r24	; 0x03
    53dc:	0f 5f       	subi	r16, 0xFF	; 255
    53de:	1f 4f       	sbci	r17, 0xFF	; 255
	            plen = fill_tcp_data(buf,plen,tempbuf);
	      }
		}
	
		//Analog pins
		for (uint8_t i=0; i<=7; i++)
    53e0:	0f b6       	in	r0, 0x3f	; 63
    53e2:	f8 94       	cli
    53e4:	de bf       	out	0x3e, r29	; 62
    53e6:	0f be       	out	0x3f, r0	; 63
    53e8:	cd bf       	out	0x3d, r28	; 61
    53ea:	08 30       	cpi	r16, 0x08	; 8
    53ec:	11 05       	cpc	r17, r1
    53ee:	e1 f6       	brne	.-72     	; 0x53a8 <print_export_htm+0x10e>
    53f0:	2a e1       	ldi	r18, 0x1A	; 26
    53f2:	c2 2e       	mov	r12, r18
    53f4:	29 e1       	ldi	r18, 0x19	; 25
    53f6:	d2 2e       	mov	r13, r18
    53f8:	00 e0       	ldi	r16, 0x00	; 0
    53fa:	10 e0       	ldi	r17, 0x00	; 0
		}

		//Digital pins
		for (uint8_t i=0; i<=3; i++)
		{
			sprintf_P(tempbuf, PSTR("D%u %u\r\n"),i,simpleSensorValues[i+8]);
    53fc:	38 e6       	ldi	r19, 0x68	; 104
    53fe:	83 2e       	mov	r8, r19
    5400:	3b e0       	ldi	r19, 0x0B	; 11
    5402:	93 2e       	mov	r9, r19
    5404:	4a e0       	ldi	r20, 0x0A	; 10
    5406:	a4 2e       	mov	r10, r20
    5408:	49 e0       	ldi	r20, 0x09	; 9
    540a:	b4 2e       	mov	r11, r20
    540c:	d6 01       	movw	r26, r12
    540e:	8c 91       	ld	r24, X
    5410:	11 96       	adiw	r26, 0x01	; 1
    5412:	9c 91       	ld	r25, X
    5414:	b2 e0       	ldi	r27, 0x02	; 2
    5416:	cb 0e       	add	r12, r27
    5418:	d1 1c       	adc	r13, r1
    541a:	9f 93       	push	r25
    541c:	8f 93       	push	r24
    541e:	1f 93       	push	r17
    5420:	0f 93       	push	r16
    5422:	9f 92       	push	r9
    5424:	8f 92       	push	r8
    5426:	bf 92       	push	r11
    5428:	af 92       	push	r10
    542a:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			plen = fill_tcp_data(buf,plen,tempbuf);
    542e:	4a e0       	ldi	r20, 0x0A	; 10
    5430:	59 e0       	ldi	r21, 0x09	; 9
    5432:	6b 81       	ldd	r22, Y+3	; 0x03
    5434:	7c 81       	ldd	r23, Y+4	; 0x04
    5436:	c7 01       	movw	r24, r14
    5438:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    543c:	9c 83       	std	Y+4, r25	; 0x04
    543e:	8b 83       	std	Y+3, r24	; 0x03
    5440:	0f 5f       	subi	r16, 0xFF	; 255
    5442:	1f 4f       	sbci	r17, 0xFF	; 255
			sprintf_P(tempbuf, PSTR("A%u %u\r\n"),i,simpleSensorValues[i]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}

		//Digital pins
		for (uint8_t i=0; i<=3; i++)
    5444:	0f b6       	in	r0, 0x3f	; 63
    5446:	f8 94       	cli
    5448:	de bf       	out	0x3e, r29	; 62
    544a:	0f be       	out	0x3f, r0	; 63
    544c:	cd bf       	out	0x3d, r28	; 61
    544e:	04 30       	cpi	r16, 0x04	; 4
    5450:	11 05       	cpc	r17, r1
    5452:	e1 f6       	brne	.-72     	; 0x540c <print_export_htm+0x172>
    5454:	1a e3       	ldi	r17, 0x3A	; 58
    5456:	c1 2e       	mov	r12, r17
    5458:	19 e1       	ldi	r17, 0x19	; 25
    545a:	d1 2e       	mov	r13, r17
    545c:	08 e1       	ldi	r16, 0x18	; 24
    545e:	10 e0       	ldi	r17, 0x00	; 0
		}

		//Relay states
		for (uint8_t i=24; i<=27; i++)
		{
			sprintf_P(tempbuf, PSTR("RL%u %u\r\n"),i,simpleSensorValues[i]);
    5460:	8e e5       	ldi	r24, 0x5E	; 94
    5462:	88 2e       	mov	r8, r24
    5464:	8b e0       	ldi	r24, 0x0B	; 11
    5466:	98 2e       	mov	r9, r24
    5468:	9a e0       	ldi	r25, 0x0A	; 10
    546a:	a9 2e       	mov	r10, r25
    546c:	99 e0       	ldi	r25, 0x09	; 9
    546e:	b9 2e       	mov	r11, r25
    5470:	d6 01       	movw	r26, r12
    5472:	8c 91       	ld	r24, X
    5474:	11 96       	adiw	r26, 0x01	; 1
    5476:	9c 91       	ld	r25, X
    5478:	b2 e0       	ldi	r27, 0x02	; 2
    547a:	cb 0e       	add	r12, r27
    547c:	d1 1c       	adc	r13, r1
    547e:	9f 93       	push	r25
    5480:	8f 93       	push	r24
    5482:	1f 93       	push	r17
    5484:	0f 93       	push	r16
    5486:	9f 92       	push	r9
    5488:	8f 92       	push	r8
    548a:	bf 92       	push	r11
    548c:	af 92       	push	r10
    548e:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			plen = fill_tcp_data(buf,plen,tempbuf);
    5492:	4a e0       	ldi	r20, 0x0A	; 10
    5494:	59 e0       	ldi	r21, 0x09	; 9
    5496:	6b 81       	ldd	r22, Y+3	; 0x03
    5498:	7c 81       	ldd	r23, Y+4	; 0x04
    549a:	c7 01       	movw	r24, r14
    549c:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    54a0:	9c 83       	std	Y+4, r25	; 0x04
    54a2:	8b 83       	std	Y+3, r24	; 0x03
    54a4:	0f 5f       	subi	r16, 0xFF	; 255
    54a6:	1f 4f       	sbci	r17, 0xFF	; 255
			sprintf_P(tempbuf, PSTR("D%u %u\r\n"),i,simpleSensorValues[i+8]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}

		//Relay states
		for (uint8_t i=24; i<=27; i++)
    54a8:	0f b6       	in	r0, 0x3f	; 63
    54aa:	f8 94       	cli
    54ac:	de bf       	out	0x3e, r29	; 62
    54ae:	0f be       	out	0x3f, r0	; 63
    54b0:	cd bf       	out	0x3d, r28	; 61
    54b2:	0c 31       	cpi	r16, 0x1C	; 28
    54b4:	11 05       	cpc	r17, r1
    54b6:	e1 f6       	brne	.-72     	; 0x5470 <print_export_htm+0x1d6>
    54b8:	f2 e3       	ldi	r31, 0x32	; 50
    54ba:	cf 2e       	mov	r12, r31
    54bc:	f9 e1       	ldi	r31, 0x19	; 25
    54be:	df 2e       	mov	r13, r31
    54c0:	04 e1       	ldi	r16, 0x14	; 20
    54c2:	10 e0       	ldi	r17, 0x00	; 0
		}

		//Opto states
		for (uint8_t i=20; i<=23; i++)
		{
			sprintf_P(tempbuf, PSTR("OP%u %u\r\n"),i,simpleSensorValues[i]);
    54c4:	a4 e5       	ldi	r26, 0x54	; 84
    54c6:	8a 2e       	mov	r8, r26
    54c8:	ab e0       	ldi	r26, 0x0B	; 11
    54ca:	9a 2e       	mov	r9, r26
    54cc:	ba e0       	ldi	r27, 0x0A	; 10
    54ce:	ab 2e       	mov	r10, r27
    54d0:	b9 e0       	ldi	r27, 0x09	; 9
    54d2:	bb 2e       	mov	r11, r27
    54d4:	d6 01       	movw	r26, r12
    54d6:	8c 91       	ld	r24, X
    54d8:	11 96       	adiw	r26, 0x01	; 1
    54da:	9c 91       	ld	r25, X
    54dc:	b2 e0       	ldi	r27, 0x02	; 2
    54de:	cb 0e       	add	r12, r27
    54e0:	d1 1c       	adc	r13, r1
    54e2:	9f 93       	push	r25
    54e4:	8f 93       	push	r24
    54e6:	1f 93       	push	r17
    54e8:	0f 93       	push	r16
    54ea:	9f 92       	push	r9
    54ec:	8f 92       	push	r8
    54ee:	bf 92       	push	r11
    54f0:	af 92       	push	r10
    54f2:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			plen = fill_tcp_data(buf,plen,tempbuf);
    54f6:	4a e0       	ldi	r20, 0x0A	; 10
    54f8:	59 e0       	ldi	r21, 0x09	; 9
    54fa:	6b 81       	ldd	r22, Y+3	; 0x03
    54fc:	7c 81       	ldd	r23, Y+4	; 0x04
    54fe:	c7 01       	movw	r24, r14
    5500:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5504:	9c 83       	std	Y+4, r25	; 0x04
    5506:	8b 83       	std	Y+3, r24	; 0x03
    5508:	0f 5f       	subi	r16, 0xFF	; 255
    550a:	1f 4f       	sbci	r17, 0xFF	; 255
			sprintf_P(tempbuf, PSTR("RL%u %u\r\n"),i,simpleSensorValues[i]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}

		//Opto states
		for (uint8_t i=20; i<=23; i++)
    550c:	0f b6       	in	r0, 0x3f	; 63
    550e:	f8 94       	cli
    5510:	de bf       	out	0x3e, r29	; 62
    5512:	0f be       	out	0x3f, r0	; 63
    5514:	cd bf       	out	0x3d, r28	; 61
    5516:	08 31       	cpi	r16, 0x18	; 24
    5518:	11 05       	cpc	r17, r1
    551a:	e1 f6       	brne	.-72     	; 0x54d4 <print_export_htm+0x23a>
    551c:	74 eb       	ldi	r23, 0xB4	; 180
    551e:	a7 2e       	mov	r10, r23
    5520:	75 e0       	ldi	r23, 0x05	; 5
    5522:	b7 2e       	mov	r11, r23
    5524:	0e e6       	ldi	r16, 0x6E	; 110
    5526:	19 e1       	ldi	r17, 0x19	; 25
    5528:	c1 2c       	mov	r12, r1
    552a:	d1 2c       	mov	r13, r1
					temperature = (float)((simpleSensorValues[50+(i*2)] & 0x7FFF) / 10.0) * -1.0;
					} else {
					temperature = (float)(simpleSensorValues[50+(i*2)])/10.0;
				}
				humidity = (float)(simpleSensorValues[50+(i*2)+1])/10.0;
				sprintf_P(tempbuf, PSTR("D%dT %g\r\nD%dH %g\r\n"),i,temperature,i,humidity);
    552c:	ea e0       	ldi	r30, 0x0A	; 10
    552e:	2e 2e       	mov	r2, r30
    5530:	e9 e0       	ldi	r30, 0x09	; 9
    5532:	3e 2e       	mov	r3, r30
			plen = fill_tcp_data(buf,plen,tempbuf);
		}

		for (uint8_t i=0; i<4; i++)
		{
			if (simpleSensorTypes[i+8] == TYPE_DHT22)
    5534:	9c 2c       	mov	r9, r12
    5536:	8d 2c       	mov	r8, r13
    5538:	ba 82       	std	Y+2, r11	; 0x02
    553a:	a9 82       	std	Y+1, r10	; 0x01
    553c:	d5 01       	movw	r26, r10
    553e:	8c 91       	ld	r24, X
    5540:	84 30       	cpi	r24, 0x04	; 4
    5542:	09 f0       	breq	.+2      	; 0x5546 <print_export_htm+0x2ac>
    5544:	5c c0       	rjmp	.+184    	; 0x55fe <print_export_htm+0x364>
			{
				float temperature=0;
				float humidity=0;
				if(simpleSensorValues[50] & 0x8000) {
    5546:	80 91 6e 19 	lds	r24, 0x196E
    554a:	90 91 6f 19 	lds	r25, 0x196F
    554e:	97 ff       	sbrs	r25, 7
    5550:	16 c0       	rjmp	.+44     	; 0x557e <print_export_htm+0x2e4>
					temperature = (float)((simpleSensorValues[50+(i*2)] & 0x7FFF) / 10.0) * -1.0;
    5552:	f8 01       	movw	r30, r16
    5554:	80 81       	ld	r24, Z
    5556:	91 81       	ldd	r25, Z+1	; 0x01
    5558:	9f 77       	andi	r25, 0x7F	; 127
    555a:	bc 01       	movw	r22, r24
    555c:	80 e0       	ldi	r24, 0x00	; 0
    555e:	90 e0       	ldi	r25, 0x00	; 0
    5560:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
    5564:	20 e0       	ldi	r18, 0x00	; 0
    5566:	30 e0       	ldi	r19, 0x00	; 0
    5568:	40 e2       	ldi	r20, 0x20	; 32
    556a:	51 e4       	ldi	r21, 0x41	; 65
    556c:	0e 94 ae 3b 	call	0x775c	; 0x775c <__divsf3>
    5570:	2b 01       	movw	r4, r22
    5572:	3c 01       	movw	r6, r24
    5574:	77 fa       	bst	r7, 7
    5576:	70 94       	com	r7
    5578:	77 f8       	bld	r7, 7
    557a:	70 94       	com	r7
    557c:	10 c0       	rjmp	.+32     	; 0x559e <print_export_htm+0x304>
					} else {
					temperature = (float)(simpleSensorValues[50+(i*2)])/10.0;
    557e:	d8 01       	movw	r26, r16
    5580:	8d 91       	ld	r24, X+
    5582:	9c 91       	ld	r25, X
    5584:	bc 01       	movw	r22, r24
    5586:	80 e0       	ldi	r24, 0x00	; 0
    5588:	90 e0       	ldi	r25, 0x00	; 0
    558a:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
    558e:	20 e0       	ldi	r18, 0x00	; 0
    5590:	30 e0       	ldi	r19, 0x00	; 0
    5592:	40 e2       	ldi	r20, 0x20	; 32
    5594:	51 e4       	ldi	r21, 0x41	; 65
    5596:	0e 94 ae 3b 	call	0x775c	; 0x775c <__divsf3>
    559a:	2b 01       	movw	r4, r22
    559c:	3c 01       	movw	r6, r24
				}
				humidity = (float)(simpleSensorValues[50+(i*2)+1])/10.0;
    559e:	f8 01       	movw	r30, r16
    55a0:	82 81       	ldd	r24, Z+2	; 0x02
    55a2:	93 81       	ldd	r25, Z+3	; 0x03
    55a4:	bc 01       	movw	r22, r24
    55a6:	80 e0       	ldi	r24, 0x00	; 0
    55a8:	90 e0       	ldi	r25, 0x00	; 0
    55aa:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
    55ae:	20 e0       	ldi	r18, 0x00	; 0
    55b0:	30 e0       	ldi	r19, 0x00	; 0
    55b2:	40 e2       	ldi	r20, 0x20	; 32
    55b4:	51 e4       	ldi	r21, 0x41	; 65
    55b6:	0e 94 ae 3b 	call	0x775c	; 0x775c <__divsf3>
				sprintf_P(tempbuf, PSTR("D%dT %g\r\nD%dH %g\r\n"),i,temperature,i,humidity);
    55ba:	9f 93       	push	r25
    55bc:	8f 93       	push	r24
    55be:	7f 93       	push	r23
    55c0:	6f 93       	push	r22
    55c2:	8f 92       	push	r8
    55c4:	9f 92       	push	r9
    55c6:	7f 92       	push	r7
    55c8:	6f 92       	push	r6
    55ca:	5f 92       	push	r5
    55cc:	4f 92       	push	r4
    55ce:	8f 92       	push	r8
    55d0:	9f 92       	push	r9
    55d2:	a1 e4       	ldi	r26, 0x41	; 65
    55d4:	bb e0       	ldi	r27, 0x0B	; 11
    55d6:	bf 93       	push	r27
    55d8:	af 93       	push	r26
    55da:	3f 92       	push	r3
    55dc:	2f 92       	push	r2
    55de:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
				plen = fill_tcp_data(buf,plen,tempbuf);
    55e2:	4a e0       	ldi	r20, 0x0A	; 10
    55e4:	59 e0       	ldi	r21, 0x09	; 9
    55e6:	6b 81       	ldd	r22, Y+3	; 0x03
    55e8:	7c 81       	ldd	r23, Y+4	; 0x04
    55ea:	c7 01       	movw	r24, r14
    55ec:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    55f0:	9c 83       	std	Y+4, r25	; 0x04
    55f2:	8b 83       	std	Y+3, r24	; 0x03
    55f4:	0f b6       	in	r0, 0x3f	; 63
    55f6:	f8 94       	cli
    55f8:	de bf       	out	0x3e, r29	; 62
    55fa:	0f be       	out	0x3f, r0	; 63
    55fc:	cd bf       	out	0x3d, r28	; 61
    55fe:	9f ef       	ldi	r25, 0xFF	; 255
    5600:	a9 1a       	sub	r10, r25
    5602:	b9 0a       	sbc	r11, r25
			}
			if (simpleSensorTypes[i+8] == TYPE_DHT11)
    5604:	a9 81       	ldd	r26, Y+1	; 0x01
    5606:	ba 81       	ldd	r27, Y+2	; 0x02
    5608:	8c 91       	ld	r24, X
    560a:	85 30       	cpi	r24, 0x05	; 5
    560c:	81 f5       	brne	.+96     	; 0x566e <print_export_htm+0x3d4>
			{
				float temperature=simpleSensorValues[50+(i*2)];
				float humidity=simpleSensorValues[50+(i*2)+1];
    560e:	f8 01       	movw	r30, r16
    5610:	62 81       	ldd	r22, Z+2	; 0x02
    5612:	73 81       	ldd	r23, Z+3	; 0x03
    5614:	80 e0       	ldi	r24, 0x00	; 0
    5616:	90 e0       	ldi	r25, 0x00	; 0
    5618:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
				sprintf_P(tempbuf, PSTR("D%dT %g\r\nD%dH %g\r\n"),i,temperature,i,humidity);
    561c:	9f 93       	push	r25
    561e:	8f 93       	push	r24
    5620:	7f 93       	push	r23
    5622:	6f 93       	push	r22
    5624:	8f 92       	push	r8
    5626:	9f 92       	push	r9
				sprintf_P(tempbuf, PSTR("D%dT %g\r\nD%dH %g\r\n"),i,temperature,i,humidity);
				plen = fill_tcp_data(buf,plen,tempbuf);
			}
			if (simpleSensorTypes[i+8] == TYPE_DHT11)
			{
				float temperature=simpleSensorValues[50+(i*2)];
    5628:	d8 01       	movw	r26, r16
    562a:	6d 91       	ld	r22, X+
    562c:	7c 91       	ld	r23, X
    562e:	80 e0       	ldi	r24, 0x00	; 0
    5630:	90 e0       	ldi	r25, 0x00	; 0
    5632:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
				float humidity=simpleSensorValues[50+(i*2)+1];
				sprintf_P(tempbuf, PSTR("D%dT %g\r\nD%dH %g\r\n"),i,temperature,i,humidity);
    5636:	9f 93       	push	r25
    5638:	8f 93       	push	r24
    563a:	7f 93       	push	r23
    563c:	6f 93       	push	r22
    563e:	8f 92       	push	r8
    5640:	9f 92       	push	r9
    5642:	ae e2       	ldi	r26, 0x2E	; 46
    5644:	bb e0       	ldi	r27, 0x0B	; 11
    5646:	bf 93       	push	r27
    5648:	af 93       	push	r26
    564a:	3f 92       	push	r3
    564c:	2f 92       	push	r2
    564e:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
				plen = fill_tcp_data(buf,plen,tempbuf);
    5652:	4a e0       	ldi	r20, 0x0A	; 10
    5654:	59 e0       	ldi	r21, 0x09	; 9
    5656:	6b 81       	ldd	r22, Y+3	; 0x03
    5658:	7c 81       	ldd	r23, Y+4	; 0x04
    565a:	c7 01       	movw	r24, r14
    565c:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5660:	9c 83       	std	Y+4, r25	; 0x04
    5662:	8b 83       	std	Y+3, r24	; 0x03
    5664:	0f b6       	in	r0, 0x3f	; 63
    5666:	f8 94       	cli
    5668:	de bf       	out	0x3e, r29	; 62
    566a:	0f be       	out	0x3f, r0	; 63
    566c:	cd bf       	out	0x3d, r28	; 61
    566e:	9f ef       	ldi	r25, 0xFF	; 255
    5670:	c9 1a       	sub	r12, r25
    5672:	d9 0a       	sbc	r13, r25
    5674:	0c 5f       	subi	r16, 0xFC	; 252
    5676:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			sprintf_P(tempbuf, PSTR("OP%u %u\r\n"),i,simpleSensorValues[i]);
			plen = fill_tcp_data(buf,plen,tempbuf);
		}

		for (uint8_t i=0; i<4; i++)
    5678:	a4 e0       	ldi	r26, 0x04	; 4
    567a:	ca 16       	cp	r12, r26
    567c:	d1 04       	cpc	r13, r1
    567e:	09 f0       	breq	.+2      	; 0x5682 <print_export_htm+0x3e8>
    5680:	59 cf       	rjmp	.-334    	; 0x5534 <print_export_htm+0x29a>
				plen = fill_tcp_data(buf,plen,tempbuf);
			}
		}

        return plen;
}
    5682:	8b 81       	ldd	r24, Y+3	; 0x03
    5684:	9c 81       	ldd	r25, Y+4	; 0x04
    5686:	0f 90       	pop	r0
    5688:	0f 90       	pop	r0
    568a:	0f 90       	pop	r0
    568c:	0f 90       	pop	r0
    568e:	df 91       	pop	r29
    5690:	cf 91       	pop	r28
    5692:	1f 91       	pop	r17
    5694:	0f 91       	pop	r16
    5696:	ff 90       	pop	r15
    5698:	ef 90       	pop	r14
    569a:	df 90       	pop	r13
    569c:	cf 90       	pop	r12
    569e:	bf 90       	pop	r11
    56a0:	af 90       	pop	r10
    56a2:	9f 90       	pop	r9
    56a4:	8f 90       	pop	r8
    56a6:	7f 90       	pop	r7
    56a8:	6f 90       	pop	r6
    56aa:	5f 90       	pop	r5
    56ac:	4f 90       	pop	r4
    56ae:	3f 90       	pop	r3
    56b0:	2f 90       	pop	r2
    56b2:	08 95       	ret

000056b4 <print_webpage>:



// prepare the webpage by writing the data to the tcp send buffer
uint16_t print_webpage(uint8_t *buf)
{
    56b4:	ef 92       	push	r14
    56b6:	ff 92       	push	r15
    56b8:	0f 93       	push	r16
    56ba:	1f 93       	push	r17
    56bc:	cf 93       	push	r28
    56be:	df 93       	push	r29
    56c0:	ec 01       	movw	r28, r24
        uint16_t plen;

		plen=http200ok();
    56c2:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>
    56c6:	7c 01       	movw	r14, r24

		sprintf_P(tempbuf, PSTR("<SCRIPT SRC='/loader.js?%u'></SCRIPT>"),tickS);
    56c8:	80 91 2e 01 	lds	r24, 0x012E
    56cc:	8f 93       	push	r24
    56ce:	80 91 2d 01 	lds	r24, 0x012D
    56d2:	8f 93       	push	r24
    56d4:	28 e0       	ldi	r18, 0x08	; 8
    56d6:	3b e0       	ldi	r19, 0x0B	; 11
    56d8:	3f 93       	push	r19
    56da:	2f 93       	push	r18
    56dc:	0a e0       	ldi	r16, 0x0A	; 10
    56de:	19 e0       	ldi	r17, 0x09	; 9
    56e0:	1f 93       	push	r17
    56e2:	0f 93       	push	r16
    56e4:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    56e8:	a8 01       	movw	r20, r16
    56ea:	b7 01       	movw	r22, r14
    56ec:	ce 01       	movw	r24, r28
    56ee:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    56f2:	7c 01       	movw	r14, r24

		sprintf_P(tempbuf, PSTR("<SCRIPT>menu(2,1);</SCRIPT><PRE>"));
    56f4:	27 ee       	ldi	r18, 0xE7	; 231
    56f6:	3a e0       	ldi	r19, 0x0A	; 10
    56f8:	3f 93       	push	r19
    56fa:	2f 93       	push	r18
    56fc:	1f 93       	push	r17
    56fe:	0f 93       	push	r16
    5700:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5704:	a8 01       	movw	r20, r16
    5706:	b7 01       	movw	r22, r14
    5708:	ce 01       	movw	r24, r28
    570a:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    570e:	7c 01       	movw	r14, r24

		sprintf_P(tempbuf, PSTR("\nSystemID: %02X%02X%02X%02X%02X%02X%02X%02X\n"),systemID[0],systemID[1],systemID[2],systemID[3],systemID[4],systemID[5],systemID[6],systemID[7]);
    5710:	80 91 da 19 	lds	r24, 0x19DA
    5714:	1f 92       	push	r1
    5716:	8f 93       	push	r24
    5718:	80 91 d9 19 	lds	r24, 0x19D9
    571c:	1f 92       	push	r1
    571e:	8f 93       	push	r24
    5720:	80 91 d8 19 	lds	r24, 0x19D8
    5724:	1f 92       	push	r1
    5726:	8f 93       	push	r24
    5728:	80 91 d7 19 	lds	r24, 0x19D7
    572c:	1f 92       	push	r1
    572e:	8f 93       	push	r24
    5730:	80 91 d6 19 	lds	r24, 0x19D6
    5734:	1f 92       	push	r1
    5736:	8f 93       	push	r24
    5738:	80 91 d5 19 	lds	r24, 0x19D5
    573c:	1f 92       	push	r1
    573e:	8f 93       	push	r24
    5740:	80 91 d4 19 	lds	r24, 0x19D4
    5744:	1f 92       	push	r1
    5746:	8f 93       	push	r24
    5748:	80 91 d3 19 	lds	r24, 0x19D3
    574c:	1f 92       	push	r1
    574e:	8f 93       	push	r24
    5750:	2a eb       	ldi	r18, 0xBA	; 186
    5752:	3a e0       	ldi	r19, 0x0A	; 10
    5754:	3f 93       	push	r19
    5756:	2f 93       	push	r18
    5758:	1f 93       	push	r17
    575a:	0f 93       	push	r16
    575c:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5760:	a8 01       	movw	r20, r16
    5762:	b7 01       	movw	r22, r14
    5764:	ce 01       	movw	r24, r28
    5766:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    576a:	8c 01       	movw	r16, r24

        if (client_waiting_gw()){
    576c:	0e 94 93 14 	call	0x2926	; 0x2926 <client_waiting_gw>
    5770:	2d b7       	in	r18, 0x3d	; 61
    5772:	3e b7       	in	r19, 0x3e	; 62
    5774:	22 5e       	subi	r18, 0xE2	; 226
    5776:	3f 4f       	sbci	r19, 0xFF	; 255
    5778:	0f b6       	in	r0, 0x3f	; 63
    577a:	f8 94       	cli
    577c:	3e bf       	out	0x3e, r19	; 62
    577e:	0f be       	out	0x3f, r0	; 63
    5780:	2d bf       	out	0x3d, r18	; 61
    5782:	88 23       	and	r24, r24
    5784:	19 f0       	breq	.+6      	; 0x578c <print_webpage+0xd8>
                plen=fill_tcp_data_p(buf,plen,PSTR("\nwaiting for GW IP to answer arp.\n"));
    5786:	47 e9       	ldi	r20, 0x97	; 151
    5788:	5a e0       	ldi	r21, 0x0A	; 10
    578a:	06 c0       	rjmp	.+12     	; 0x5798 <print_webpage+0xe4>
                return(plen);
        }
        if (dns_state==1){
    578c:	80 91 a3 05 	lds	r24, 0x05A3
    5790:	81 30       	cpi	r24, 0x01	; 1
    5792:	61 f4       	brne	.+24     	; 0x57ac <print_webpage+0xf8>
                plen=fill_tcp_data_p(buf,plen,PSTR("\nwaiting for DNS answer.\n"));
    5794:	4d e7       	ldi	r20, 0x7D	; 125
    5796:	5a e0       	ldi	r21, 0x0A	; 10
    5798:	b8 01       	movw	r22, r16
    579a:	ce 01       	movw	r24, r28
		
		//Debug for at se hvor tt vi er p grnsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);
        
		return(plen);
}
    579c:	df 91       	pop	r29
    579e:	cf 91       	pop	r28
    57a0:	1f 91       	pop	r17
    57a2:	0f 91       	pop	r16
    57a4:	ff 90       	pop	r15
    57a6:	ef 90       	pop	r14
        if (client_waiting_gw()){
                plen=fill_tcp_data_p(buf,plen,PSTR("\nwaiting for GW IP to answer arp.\n"));
                return(plen);
        }
        if (dns_state==1){
                plen=fill_tcp_data_p(buf,plen,PSTR("\nwaiting for DNS answer.\n"));
    57a8:	0c 94 30 12 	jmp	0x2460	; 0x2460 <fill_tcp_data_p>

		uint8_t days = 0;
		uint8_t hours = 0;
		uint8_t minutes = 0;
		uint8_t seconds = 0;
		uint32_t up = uptime;
    57ac:	40 91 a4 05 	lds	r20, 0x05A4
    57b0:	50 91 a5 05 	lds	r21, 0x05A5
    57b4:	60 91 a6 05 	lds	r22, 0x05A6
    57b8:	70 91 a7 05 	lds	r23, 0x05A7
                plen=fill_tcp_data_p(buf,plen,PSTR("\nwaiting for DNS answer.\n"));
                return(plen);
        }


		uint8_t days = 0;
    57bc:	80 e0       	ldi	r24, 0x00	; 0
		uint8_t hours = 0;
		uint8_t minutes = 0;
		uint8_t seconds = 0;
		uint32_t up = uptime;
		while (up >= 86400)
    57be:	40 38       	cpi	r20, 0x80	; 128
    57c0:	31 e5       	ldi	r19, 0x51	; 81
    57c2:	53 07       	cpc	r21, r19
    57c4:	31 e0       	ldi	r19, 0x01	; 1
    57c6:	63 07       	cpc	r22, r19
    57c8:	71 05       	cpc	r23, r1
    57ca:	30 f0       	brcs	.+12     	; 0x57d8 <print_webpage+0x124>
		{
			days++;
    57cc:	8f 5f       	subi	r24, 0xFF	; 255
			up -= 86400;
    57ce:	40 58       	subi	r20, 0x80	; 128
    57d0:	51 45       	sbci	r21, 0x51	; 81
    57d2:	61 40       	sbci	r22, 0x01	; 1
    57d4:	71 09       	sbc	r23, r1
    57d6:	f3 cf       	rjmp	.-26     	; 0x57be <print_webpage+0x10a>
		uint8_t days = 0;
		uint8_t hours = 0;
		uint8_t minutes = 0;
		uint8_t seconds = 0;
		uint32_t up = uptime;
		while (up >= 86400)
    57d8:	90 e0       	ldi	r25, 0x00	; 0
		{
			days++;
			up -= 86400;
		}
		while (up >= 3600)
    57da:	40 31       	cpi	r20, 0x10	; 16
    57dc:	2e e0       	ldi	r18, 0x0E	; 14
    57de:	52 07       	cpc	r21, r18
    57e0:	61 05       	cpc	r22, r1
    57e2:	71 05       	cpc	r23, r1
    57e4:	30 f0       	brcs	.+12     	; 0x57f2 <print_webpage+0x13e>
		{
			hours++;
    57e6:	9f 5f       	subi	r25, 0xFF	; 255
			up -= 3600;
    57e8:	40 51       	subi	r20, 0x10	; 16
    57ea:	5e 40       	sbci	r21, 0x0E	; 14
    57ec:	61 09       	sbc	r22, r1
    57ee:	71 09       	sbc	r23, r1
    57f0:	f4 cf       	rjmp	.-24     	; 0x57da <print_webpage+0x126>
		while (up >= 86400)
		{
			days++;
			up -= 86400;
		}
		while (up >= 3600)
    57f2:	20 e0       	ldi	r18, 0x00	; 0
		{
			hours++;
			up -= 3600;
		}
		while (up >= 60)
    57f4:	4c 33       	cpi	r20, 0x3C	; 60
    57f6:	51 05       	cpc	r21, r1
    57f8:	61 05       	cpc	r22, r1
    57fa:	71 05       	cpc	r23, r1
    57fc:	30 f0       	brcs	.+12     	; 0x580a <print_webpage+0x156>
		{
			minutes++;
    57fe:	2f 5f       	subi	r18, 0xFF	; 255
			up -= 60;
    5800:	4c 53       	subi	r20, 0x3C	; 60
    5802:	51 09       	sbc	r21, r1
    5804:	61 09       	sbc	r22, r1
    5806:	71 09       	sbc	r23, r1
    5808:	f5 cf       	rjmp	.-22     	; 0x57f4 <print_webpage+0x140>
		}
		seconds = up;

		sprintf_P(tempbuf, PSTR("\nUptime: %udays %uhours %uminutes %useconds\n"),days, hours, minutes, seconds);
    580a:	5f 93       	push	r21
    580c:	4f 93       	push	r20
    580e:	1f 92       	push	r1
    5810:	2f 93       	push	r18
    5812:	1f 92       	push	r1
    5814:	9f 93       	push	r25
    5816:	1f 92       	push	r1
    5818:	8f 93       	push	r24
    581a:	80 e5       	ldi	r24, 0x50	; 80
    581c:	9a e0       	ldi	r25, 0x0A	; 10
    581e:	9f 93       	push	r25
    5820:	8f 93       	push	r24
    5822:	8a e0       	ldi	r24, 0x0A	; 10
    5824:	99 e0       	ldi	r25, 0x09	; 9
    5826:	9f 93       	push	r25
    5828:	8f 93       	push	r24
    582a:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    582e:	4a e0       	ldi	r20, 0x0A	; 10
    5830:	59 e0       	ldi	r21, 0x09	; 9
    5832:	b8 01       	movw	r22, r16
    5834:	ce 01       	movw	r24, r28
    5836:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>

        plen=fill_tcp_data_p(buf,plen,PSTR("\nNumber of data uploads : "));
    583a:	45 e3       	ldi	r20, 0x35	; 53
    583c:	5a e0       	ldi	r21, 0x0A	; 10
    583e:	bc 01       	movw	r22, r24
    5840:	ce 01       	movw	r24, r28
    5842:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    5846:	8c 01       	movw	r16, r24
    5848:	4a e0       	ldi	r20, 0x0A	; 10
    584a:	6a e0       	ldi	r22, 0x0A	; 10
    584c:	79 e0       	ldi	r23, 0x09	; 9
    584e:	80 91 9e 05 	lds	r24, 0x059E
    5852:	90 91 9f 05 	lds	r25, 0x059F
    5856:	0e 94 2a 3e 	call	0x7c54	; 0x7c54 <__itoa_ncheck>
        // convert number to string:
        itoa(web_client_attempts,tempbuf,10);
        plen=fill_tcp_data(buf,plen,tempbuf);
    585a:	4a e0       	ldi	r20, 0x0A	; 10
    585c:	59 e0       	ldi	r21, 0x09	; 9
    585e:	b8 01       	movw	r22, r16
    5860:	ce 01       	movw	r24, r28
    5862:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>

        plen=fill_tcp_data_p(buf,plen,PSTR("\nNumber successful data uploads : "));
    5866:	42 e1       	ldi	r20, 0x12	; 18
    5868:	5a e0       	ldi	r21, 0x0A	; 10
    586a:	bc 01       	movw	r22, r24
    586c:	ce 01       	movw	r24, r28
    586e:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    5872:	8c 01       	movw	r16, r24
    5874:	4a e0       	ldi	r20, 0x0A	; 10
    5876:	6a e0       	ldi	r22, 0x0A	; 10
    5878:	79 e0       	ldi	r23, 0x09	; 9
    587a:	80 91 9a 05 	lds	r24, 0x059A
    587e:	90 91 9b 05 	lds	r25, 0x059B
    5882:	0e 94 2a 3e 	call	0x7c54	; 0x7c54 <__itoa_ncheck>
        // convert number to string:
        itoa(web_client_sendok,tempbuf,10);
        plen=fill_tcp_data(buf,plen,tempbuf);
    5886:	4a e0       	ldi	r20, 0x0A	; 10
    5888:	59 e0       	ldi	r21, 0x09	; 9
    588a:	b8 01       	movw	r22, r16
    588c:	ce 01       	movw	r24, r28
    588e:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>

		plen=fill_tcp_data_p(buf,plen,PSTR("</pre><script>for (i=0; i < sensors.length; i++) { dw(sensors[i][1]+' = '+sensors[i][2]+'<br>'); }</script>"));
    5892:	46 ea       	ldi	r20, 0xA6	; 166
    5894:	59 e0       	ldi	r21, 0x09	; 9
    5896:	bc 01       	movw	r22, r24
    5898:	ce 01       	movw	r24, r28
    589a:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    589e:	d8 2f       	mov	r29, r24
    58a0:	c9 2f       	mov	r28, r25
		
		//Debug for at se hvor tt vi er p grnsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);
    58a2:	9f 93       	push	r25
    58a4:	8f 93       	push	r24
    58a6:	28 e9       	ldi	r18, 0x98	; 152
    58a8:	39 e0       	ldi	r19, 0x09	; 9
    58aa:	3f 93       	push	r19
    58ac:	2f 93       	push	r18
    58ae:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
        
		return(plen);
    58b2:	8d b7       	in	r24, 0x3d	; 61
    58b4:	9e b7       	in	r25, 0x3e	; 62
    58b6:	40 96       	adiw	r24, 0x10	; 16
    58b8:	0f b6       	in	r0, 0x3f	; 63
    58ba:	f8 94       	cli
    58bc:	9e bf       	out	0x3e, r25	; 62
    58be:	0f be       	out	0x3f, r0	; 63
    58c0:	8d bf       	out	0x3d, r24	; 61
}
    58c2:	8d 2f       	mov	r24, r29
    58c4:	9c 2f       	mov	r25, r28
    58c6:	df 91       	pop	r29
    58c8:	cf 91       	pop	r28
    58ca:	1f 91       	pop	r17
    58cc:	0f 91       	pop	r16
    58ce:	ff 90       	pop	r15
    58d0:	ef 90       	pop	r14
    58d2:	08 95       	ret

000058d4 <print_sensorlist>:


// prepare the webpage by writing the data to the tcp send buffer

uint16_t print_sensorlist(uint8_t *buf)
{
    58d4:	2f 92       	push	r2
    58d6:	3f 92       	push	r3
    58d8:	4f 92       	push	r4
    58da:	5f 92       	push	r5
    58dc:	6f 92       	push	r6
    58de:	7f 92       	push	r7
    58e0:	8f 92       	push	r8
    58e2:	9f 92       	push	r9
    58e4:	af 92       	push	r10
    58e6:	bf 92       	push	r11
    58e8:	cf 92       	push	r12
    58ea:	df 92       	push	r13
    58ec:	ef 92       	push	r14
    58ee:	ff 92       	push	r15
    58f0:	0f 93       	push	r16
    58f2:	1f 93       	push	r17
    58f4:	cf 93       	push	r28
    58f6:	df 93       	push	r29
    58f8:	00 d0       	rcall	.+0      	; 0x58fa <print_sensorlist+0x26>
    58fa:	cd b7       	in	r28, 0x3d	; 61
    58fc:	de b7       	in	r29, 0x3e	; 62
    58fe:	8c 01       	movw	r16, r24
        uint16_t plen;
		bool first = true;

		plen=http200ok();
    5900:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>
    5904:	7c 01       	movw	r14, r24
    
		sprintf_P(tempbuf, PSTR("var sensors=["));
    5906:	2a e8       	ldi	r18, 0x8A	; 138
    5908:	39 e0       	ldi	r19, 0x09	; 9
    590a:	3f 93       	push	r19
    590c:	2f 93       	push	r18
    590e:	2a e0       	ldi	r18, 0x0A	; 10
    5910:	39 e0       	ldi	r19, 0x09	; 9
    5912:	3f 93       	push	r19
    5914:	2f 93       	push	r18
    5916:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen = fill_tcp_data(buf,plen,tempbuf);
    591a:	4a e0       	ldi	r20, 0x0A	; 10
    591c:	59 e0       	ldi	r21, 0x09	; 9
    591e:	b7 01       	movw	r22, r14
    5920:	c8 01       	movw	r24, r16
    5922:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5926:	bc 01       	movw	r22, r24
    5928:	b0 e1       	ldi	r27, 0x10	; 16
    592a:	eb 2e       	mov	r14, r27
    592c:	b6 e0       	ldi	r27, 0x06	; 6
    592e:	fb 2e       	mov	r15, r27
    5930:	8a e1       	ldi	r24, 0x1A	; 26
    5932:	68 2e       	mov	r6, r24
    5934:	86 e0       	ldi	r24, 0x06	; 6
    5936:	78 2e       	mov	r7, r24
    5938:	0f 90       	pop	r0
    593a:	0f 90       	pop	r0
    593c:	0f 90       	pop	r0
    593e:	0f 90       	pop	r0
    5940:	21 2c       	mov	r2, r1
    5942:	31 2c       	mov	r3, r1
// prepare the webpage by writing the data to the tcp send buffer

uint16_t print_sensorlist(uint8_t *buf)
{
        uint16_t plen;
		bool first = true;
    5944:	81 e0       	ldi	r24, 0x01	; 1
		  	if (!first)
				plen = fill_tcp_data(buf,plen,",");
			else
				first=false;

	        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    5946:	91 e7       	ldi	r25, 0x71	; 113
    5948:	89 2e       	mov	r8, r25
    594a:	92 e0       	ldi	r25, 0x02	; 2
    594c:	99 2e       	mov	r9, r25
    
	        sprintf_P(tempbuf, PSTR("[%u, '%02X%02X%02X%02X%02X%02X%02X%02X', '%c%d.%04d']"),i,
    594e:	24 e5       	ldi	r18, 0x54	; 84
    5950:	c2 2e       	mov	r12, r18
    5952:	29 e0       	ldi	r18, 0x09	; 9
    5954:	d2 2e       	mov	r13, r18
    5956:	3a e0       	ldi	r19, 0x0A	; 10
    5958:	a3 2e       	mov	r10, r19
    595a:	39 e0       	ldi	r19, 0x09	; 9
    595c:	b3 2e       	mov	r11, r19
		sprintf_P(tempbuf, PSTR("var sensors=["));
		plen = fill_tcp_data(buf,plen,tempbuf);

	    for (uint8_t i=0; i<MAXSENSORS; i++)
	    {  
	      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
    595e:	52 2c       	mov	r5, r2
    5960:	43 2c       	mov	r4, r3
    5962:	f7 01       	movw	r30, r14
    5964:	90 81       	ld	r25, Z
    5966:	99 23       	and	r25, r25
    5968:	09 f4       	brne	.+2      	; 0x596c <print_sensorlist+0x98>
    596a:	52 c0       	rjmp	.+164    	; 0x5a10 <print_sensorlist+0x13c>
	      {
		  	if (!first)
    596c:	81 11       	cpse	r24, r1
    596e:	06 c0       	rjmp	.+12     	; 0x597c <print_sensorlist+0xa8>
				plen = fill_tcp_data(buf,plen,",");
    5970:	4a e9       	ldi	r20, 0x9A	; 154
    5972:	54 e0       	ldi	r21, 0x04	; 4
    5974:	c8 01       	movw	r24, r16
    5976:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    597a:	bc 01       	movw	r22, r24
    597c:	f3 01       	movw	r30, r6
    597e:	31 97       	sbiw	r30, 0x01	; 1
			else
				first=false;

	        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    5980:	20 81       	ld	r18, Z
    5982:	28 9d       	mul	r18, r8
    5984:	c0 01       	movw	r24, r0
    5986:	29 9d       	mul	r18, r9
    5988:	90 0d       	add	r25, r0
    598a:	11 24       	eor	r1, r1
    
	        sprintf_P(tempbuf, PSTR("[%u, '%02X%02X%02X%02X%02X%02X%02X%02X', '%c%d.%04d']"),i,
    598c:	9f 93       	push	r25
    598e:	8f 93       	push	r24
    5990:	31 97       	sbiw	r30, 0x01	; 1
    5992:	80 81       	ld	r24, Z
    5994:	1f 92       	push	r1
    5996:	8f 93       	push	r24
    5998:	f3 01       	movw	r30, r6
    599a:	80 81       	ld	r24, Z
    599c:	1f 92       	push	r1
    599e:	8f 93       	push	r24
    59a0:	33 97       	sbiw	r30, 0x03	; 3
    59a2:	80 81       	ld	r24, Z
    59a4:	1f 92       	push	r1
    59a6:	8f 93       	push	r24
    59a8:	31 97       	sbiw	r30, 0x01	; 1
    59aa:	80 81       	ld	r24, Z
    59ac:	1f 92       	push	r1
    59ae:	8f 93       	push	r24
    59b0:	31 97       	sbiw	r30, 0x01	; 1
    59b2:	80 81       	ld	r24, Z
    59b4:	1f 92       	push	r1
    59b6:	8f 93       	push	r24
    59b8:	31 97       	sbiw	r30, 0x01	; 1
    59ba:	80 81       	ld	r24, Z
    59bc:	1f 92       	push	r1
    59be:	8f 93       	push	r24
    59c0:	31 97       	sbiw	r30, 0x01	; 1
    59c2:	80 81       	ld	r24, Z
    59c4:	1f 92       	push	r1
    59c6:	8f 93       	push	r24
    59c8:	31 97       	sbiw	r30, 0x01	; 1
    59ca:	80 81       	ld	r24, Z
    59cc:	1f 92       	push	r1
    59ce:	8f 93       	push	r24
    59d0:	31 97       	sbiw	r30, 0x01	; 1
    59d2:	80 81       	ld	r24, Z
    59d4:	1f 92       	push	r1
    59d6:	8f 93       	push	r24
    59d8:	f7 01       	movw	r30, r14
    59da:	80 81       	ld	r24, Z
    59dc:	1f 92       	push	r1
    59de:	8f 93       	push	r24
    59e0:	4f 92       	push	r4
    59e2:	5f 92       	push	r5
    59e4:	df 92       	push	r13
    59e6:	cf 92       	push	r12
    59e8:	bf 92       	push	r11
    59ea:	af 92       	push	r10
    59ec:	69 83       	std	Y+1, r22	; 0x01
    59ee:	7a 83       	std	Y+2, r23	; 0x02
    59f0:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
	              sensorValues[(i*SENSORSIZE)+SIGN],
	              sensorValues[(i*SENSORSIZE)+VALUE1],
	              frac
	            );      

	            plen = fill_tcp_data(buf,plen,tempbuf);
    59f4:	4a e0       	ldi	r20, 0x0A	; 10
    59f6:	59 e0       	ldi	r21, 0x09	; 9
    59f8:	69 81       	ldd	r22, Y+1	; 0x01
    59fa:	7a 81       	ldd	r23, Y+2	; 0x02
    59fc:	c8 01       	movw	r24, r16
    59fe:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5a02:	bc 01       	movw	r22, r24
    5a04:	0f b6       	in	r0, 0x3f	; 63
    5a06:	f8 94       	cli
    5a08:	de bf       	out	0x3e, r29	; 62
    5a0a:	0f be       	out	0x3f, r0	; 63
    5a0c:	cd bf       	out	0x3d, r28	; 61
    5a0e:	80 e0       	ldi	r24, 0x00	; 0
    5a10:	9f ef       	ldi	r25, 0xFF	; 255
    5a12:	29 1a       	sub	r2, r25
    5a14:	39 0a       	sbc	r3, r25
    5a16:	eb e0       	ldi	r30, 0x0B	; 11
    5a18:	ee 0e       	add	r14, r30
    5a1a:	f1 1c       	adc	r15, r1
    5a1c:	fb e0       	ldi	r31, 0x0B	; 11
    5a1e:	6f 0e       	add	r6, r31
    5a20:	71 1c       	adc	r7, r1
		plen=http200ok();
    
		sprintf_P(tempbuf, PSTR("var sensors=["));
		plen = fill_tcp_data(buf,plen,tempbuf);

	    for (uint8_t i=0; i<MAXSENSORS; i++)
    5a22:	9c e3       	ldi	r25, 0x3C	; 60
    5a24:	29 16       	cp	r2, r25
    5a26:	31 04       	cpc	r3, r1
    5a28:	09 f0       	breq	.+2      	; 0x5a2c <print_sensorlist+0x158>
    5a2a:	99 cf       	rjmp	.-206    	; 0x595e <print_sensorlist+0x8a>

	            plen = fill_tcp_data(buf,plen,tempbuf);
	      }
		}
	
		plen=fill_tcp_data_p(buf,plen,PSTR("];"));
    5a2c:	41 e5       	ldi	r20, 0x51	; 81
    5a2e:	59 e0       	ldi	r21, 0x09	; 9
    5a30:	c8 01       	movw	r24, r16

        return plen;
}
    5a32:	0f 90       	pop	r0
    5a34:	0f 90       	pop	r0
    5a36:	df 91       	pop	r29
    5a38:	cf 91       	pop	r28
    5a3a:	1f 91       	pop	r17
    5a3c:	0f 91       	pop	r16
    5a3e:	ff 90       	pop	r15
    5a40:	ef 90       	pop	r14
    5a42:	df 90       	pop	r13
    5a44:	cf 90       	pop	r12
    5a46:	bf 90       	pop	r11
    5a48:	af 90       	pop	r10
    5a4a:	9f 90       	pop	r9
    5a4c:	8f 90       	pop	r8
    5a4e:	7f 90       	pop	r7
    5a50:	6f 90       	pop	r6
    5a52:	5f 90       	pop	r5
    5a54:	4f 90       	pop	r4
    5a56:	3f 90       	pop	r3
    5a58:	2f 90       	pop	r2

	            plen = fill_tcp_data(buf,plen,tempbuf);
	      }
		}
	
		plen=fill_tcp_data_p(buf,plen,PSTR("];"));
    5a5a:	0c 94 30 12 	jmp	0x2460	; 0x2460 <fill_tcp_data_p>

00005a5e <print_alarmlist>:

        return plen;
}

uint16_t print_alarmlist(uint8_t *buf)
{
    5a5e:	2f 92       	push	r2
    5a60:	3f 92       	push	r3
    5a62:	4f 92       	push	r4
    5a64:	5f 92       	push	r5
    5a66:	6f 92       	push	r6
    5a68:	7f 92       	push	r7
    5a6a:	8f 92       	push	r8
    5a6c:	9f 92       	push	r9
    5a6e:	af 92       	push	r10
    5a70:	bf 92       	push	r11
    5a72:	cf 92       	push	r12
    5a74:	df 92       	push	r13
    5a76:	ef 92       	push	r14
    5a78:	ff 92       	push	r15
    5a7a:	0f 93       	push	r16
    5a7c:	1f 93       	push	r17
    5a7e:	cf 93       	push	r28
    5a80:	df 93       	push	r29
    5a82:	00 d0       	rcall	.+0      	; 0x5a84 <print_alarmlist+0x26>
    5a84:	00 d0       	rcall	.+0      	; 0x5a86 <print_alarmlist+0x28>
    5a86:	1f 92       	push	r1
    5a88:	cd b7       	in	r28, 0x3d	; 61
    5a8a:	de b7       	in	r29, 0x3e	; 62
    5a8c:	2c 01       	movw	r4, r24
4 445

*/
        uint16_t plen;

		plen=http200ok();
    5a8e:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>

		plen=fill_tcp_data_p(buf,plen,PSTR("var alarms = new Array();"));
    5a92:	47 e3       	ldi	r20, 0x37	; 55
    5a94:	59 e0       	ldi	r21, 0x09	; 9
    5a96:	bc 01       	movw	r22, r24
    5a98:	c2 01       	movw	r24, r4
    5a9a:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    5a9e:	3c 01       	movw	r6, r24
    5aa0:	88 24       	eor	r8, r8
    5aa2:	83 94       	inc	r8
    5aa4:	91 2c       	mov	r9, r1
    5aa6:	81 e9       	ldi	r24, 0x91	; 145
    5aa8:	91 e0       	ldi	r25, 0x01	; 1
    5aaa:	9d 83       	std	Y+5, r25	; 0x05
    5aac:	8c 83       	std	Y+4, r24	; 0x04

		for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
		{
			uint16_t pos = 400 + ((alarm-1)*15); //400 415 430 445
    5aae:	f8 2c       	mov	r15, r8
    5ab0:	19 2d       	mov	r17, r9
    5ab2:	2c 80       	ldd	r2, Y+4	; 0x04
    5ab4:	3d 80       	ldd	r3, Y+5	; 0x05
    5ab6:	91 e0       	ldi	r25, 0x01	; 1
    5ab8:	29 1a       	sub	r2, r25
    5aba:	31 08       	sbc	r3, r1
			uint16_t sensorid  = 255;
			if (eepromReadByte(pos+1) != 0 && eepromReadByte(pos+1) != 0xFF)
    5abc:	8c 81       	ldd	r24, Y+4	; 0x04
    5abe:	9d 81       	ldd	r25, Y+5	; 0x05
    5ac0:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5ac4:	81 11       	cpse	r24, r1
    5ac6:	03 c0       	rjmp	.+6      	; 0x5ace <print_alarmlist+0x70>
		plen=fill_tcp_data_p(buf,plen,PSTR("var alarms = new Array();"));

		for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
		{
			uint16_t pos = 400 + ((alarm-1)*15); //400 415 430 445
			uint16_t sensorid  = 255;
    5ac8:	0f ef       	ldi	r16, 0xFF	; 255
    5aca:	e1 2c       	mov	r14, r1
    5acc:	3e c0       	rjmp	.+124    	; 0x5b4a <print_alarmlist+0xec>
			if (eepromReadByte(pos+1) != 0 && eepromReadByte(pos+1) != 0xFF)
    5ace:	8c 81       	ldd	r24, Y+4	; 0x04
    5ad0:	9d 81       	ldd	r25, Y+5	; 0x05
    5ad2:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5ad6:	8f 3f       	cpi	r24, 0xFF	; 255
    5ad8:	b9 f3       	breq	.-18     	; 0x5ac8 <print_alarmlist+0x6a>
			{
					sensorid = findSensor(
    5ada:	8c 81       	ldd	r24, Y+4	; 0x04
    5adc:	9d 81       	ldd	r25, Y+5	; 0x05
    5ade:	07 96       	adiw	r24, 0x07	; 7
    5ae0:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5ae4:	a8 2e       	mov	r10, r24
    5ae6:	8c 81       	ldd	r24, Y+4	; 0x04
    5ae8:	9d 81       	ldd	r25, Y+5	; 0x05
    5aea:	06 96       	adiw	r24, 0x06	; 6
    5aec:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5af0:	c8 2e       	mov	r12, r24
    5af2:	8c 81       	ldd	r24, Y+4	; 0x04
    5af4:	9d 81       	ldd	r25, Y+5	; 0x05
    5af6:	05 96       	adiw	r24, 0x05	; 5
    5af8:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5afc:	e8 2e       	mov	r14, r24
    5afe:	8c 81       	ldd	r24, Y+4	; 0x04
    5b00:	9d 81       	ldd	r25, Y+5	; 0x05
    5b02:	04 96       	adiw	r24, 0x04	; 4
    5b04:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b08:	08 2f       	mov	r16, r24
    5b0a:	8c 81       	ldd	r24, Y+4	; 0x04
    5b0c:	9d 81       	ldd	r25, Y+5	; 0x05
    5b0e:	03 96       	adiw	r24, 0x03	; 3
    5b10:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b14:	28 2f       	mov	r18, r24
    5b16:	8c 81       	ldd	r24, Y+4	; 0x04
    5b18:	9d 81       	ldd	r25, Y+5	; 0x05
    5b1a:	02 96       	adiw	r24, 0x02	; 2
    5b1c:	2b 83       	std	Y+3, r18	; 0x03
    5b1e:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b22:	48 2f       	mov	r20, r24
    5b24:	8c 81       	ldd	r24, Y+4	; 0x04
    5b26:	9d 81       	ldd	r25, Y+5	; 0x05
    5b28:	01 96       	adiw	r24, 0x01	; 1
    5b2a:	4a 83       	std	Y+2, r20	; 0x02
    5b2c:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b30:	68 2f       	mov	r22, r24
    5b32:	8c 81       	ldd	r24, Y+4	; 0x04
    5b34:	9d 81       	ldd	r25, Y+5	; 0x05
    5b36:	69 83       	std	Y+1, r22	; 0x01
    5b38:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b3c:	2b 81       	ldd	r18, Y+3	; 0x03
    5b3e:	4a 81       	ldd	r20, Y+2	; 0x02
    5b40:	69 81       	ldd	r22, Y+1	; 0x01
    5b42:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <findSensor>
    5b46:	08 2f       	mov	r16, r24
    5b48:	e9 2e       	mov	r14, r25
				);
			}

			sprintf_P(tempbuf, PSTR("alarms[%u] = [%u, '%u','%i','%u','%u','%u','%u'];"), alarm, sensorid,
			eepromReadByte(pos+9), eepromReadByteSigned(pos+10),eepromReadByte(pos+11),eepromReadByte(pos+12),
			eepromReadByte(pos+13),eepromReadByte(pos+0));
    5b4a:	c1 01       	movw	r24, r2
    5b4c:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b50:	b8 2e       	mov	r11, r24
    5b52:	8c 81       	ldd	r24, Y+4	; 0x04
    5b54:	9d 81       	ldd	r25, Y+5	; 0x05
    5b56:	0c 96       	adiw	r24, 0x0c	; 12
    5b58:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b5c:	d8 2e       	mov	r13, r24
					eepromReadByte(pos+5), eepromReadByte(pos+6), eepromReadByte(pos+7), eepromReadByte(pos+8)
				);
			}

			sprintf_P(tempbuf, PSTR("alarms[%u] = [%u, '%u','%i','%u','%u','%u','%u'];"), alarm, sensorid,
			eepromReadByte(pos+9), eepromReadByteSigned(pos+10),eepromReadByte(pos+11),eepromReadByte(pos+12),
    5b5e:	8c 81       	ldd	r24, Y+4	; 0x04
    5b60:	9d 81       	ldd	r25, Y+5	; 0x05
    5b62:	0b 96       	adiw	r24, 0x0b	; 11
    5b64:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b68:	28 2e       	mov	r2, r24
    5b6a:	8c 81       	ldd	r24, Y+4	; 0x04
    5b6c:	9d 81       	ldd	r25, Y+5	; 0x05
    5b6e:	0a 96       	adiw	r24, 0x0a	; 10
    5b70:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    5b74:	c8 2e       	mov	r12, r24
    5b76:	8c 81       	ldd	r24, Y+4	; 0x04
    5b78:	9d 81       	ldd	r25, Y+5	; 0x05
    5b7a:	09 96       	adiw	r24, 0x09	; 9
    5b7c:	0e 94 59 21 	call	0x42b2	; 0x42b2 <eepromReadByteSigned>
    5b80:	38 2e       	mov	r3, r24
    5b82:	8c 81       	ldd	r24, Y+4	; 0x04
    5b84:	9d 81       	ldd	r25, Y+5	; 0x05
    5b86:	08 96       	adiw	r24, 0x08	; 8
    5b88:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
					eepromReadByte(pos+1), eepromReadByte(pos+2), eepromReadByte(pos+3), eepromReadByte(pos+4),
					eepromReadByte(pos+5), eepromReadByte(pos+6), eepromReadByte(pos+7), eepromReadByte(pos+8)
				);
			}

			sprintf_P(tempbuf, PSTR("alarms[%u] = [%u, '%u','%i','%u','%u','%u','%u'];"), alarm, sensorid,
    5b8c:	1f 92       	push	r1
    5b8e:	bf 92       	push	r11
    5b90:	1f 92       	push	r1
    5b92:	df 92       	push	r13
    5b94:	1f 92       	push	r1
    5b96:	2f 92       	push	r2
    5b98:	1f 92       	push	r1
    5b9a:	cf 92       	push	r12
    5b9c:	23 2d       	mov	r18, r3
    5b9e:	33 27       	eor	r19, r19
    5ba0:	27 fd       	sbrc	r18, 7
    5ba2:	30 95       	com	r19
    5ba4:	3f 93       	push	r19
    5ba6:	3f 92       	push	r3
    5ba8:	1f 92       	push	r1
    5baa:	8f 93       	push	r24
    5bac:	ef 92       	push	r14
    5bae:	0f 93       	push	r16
    5bb0:	1f 93       	push	r17
    5bb2:	ff 92       	push	r15
    5bb4:	a5 e0       	ldi	r26, 0x05	; 5
    5bb6:	b9 e0       	ldi	r27, 0x09	; 9
    5bb8:	bf 93       	push	r27
    5bba:	af 93       	push	r26
    5bbc:	aa e0       	ldi	r26, 0x0A	; 10
    5bbe:	b9 e0       	ldi	r27, 0x09	; 9
    5bc0:	bf 93       	push	r27
    5bc2:	af 93       	push	r26
    5bc4:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			eepromReadByte(pos+9), eepromReadByteSigned(pos+10),eepromReadByte(pos+11),eepromReadByte(pos+12),
			eepromReadByte(pos+13),eepromReadByte(pos+0));
			
			plen=fill_tcp_data(buf,plen,tempbuf);
    5bc8:	4a e0       	ldi	r20, 0x0A	; 10
    5bca:	59 e0       	ldi	r21, 0x09	; 9
    5bcc:	b3 01       	movw	r22, r6
    5bce:	c2 01       	movw	r24, r4
    5bd0:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5bd4:	3c 01       	movw	r6, r24
    5bd6:	8c 81       	ldd	r24, Y+4	; 0x04
    5bd8:	9d 81       	ldd	r25, Y+5	; 0x05
    5bda:	0f 96       	adiw	r24, 0x0f	; 15
    5bdc:	9d 83       	std	Y+5, r25	; 0x05
    5bde:	8c 83       	std	Y+4, r24	; 0x04
    5be0:	9f ef       	ldi	r25, 0xFF	; 255
    5be2:	89 1a       	sub	r8, r25
    5be4:	99 0a       	sbc	r9, r25

		plen=http200ok();

		plen=fill_tcp_data_p(buf,plen,PSTR("var alarms = new Array();"));

		for (uint8_t alarm=1; alarm<=NUMALARMS; alarm++)
    5be6:	0f b6       	in	r0, 0x3f	; 63
    5be8:	f8 94       	cli
    5bea:	de bf       	out	0x3e, r29	; 62
    5bec:	0f be       	out	0x3f, r0	; 63
    5bee:	cd bf       	out	0x3d, r28	; 61
    5bf0:	ec 81       	ldd	r30, Y+4	; 0x04
    5bf2:	fd 81       	ldd	r31, Y+5	; 0x05
    5bf4:	ed 3c       	cpi	r30, 0xCD	; 205
    5bf6:	f1 40       	sbci	r31, 0x01	; 1
    5bf8:	09 f0       	breq	.+2      	; 0x5bfc <print_alarmlist+0x19e>
    5bfa:	59 cf       	rjmp	.-334    	; 0x5aae <print_alarmlist+0x50>
			
			plen=fill_tcp_data(buf,plen,tempbuf);
		}
    	
        return plen;
}
    5bfc:	c3 01       	movw	r24, r6
    5bfe:	0f 90       	pop	r0
    5c00:	0f 90       	pop	r0
    5c02:	0f 90       	pop	r0
    5c04:	0f 90       	pop	r0
    5c06:	0f 90       	pop	r0
    5c08:	df 91       	pop	r29
    5c0a:	cf 91       	pop	r28
    5c0c:	1f 91       	pop	r17
    5c0e:	0f 91       	pop	r16
    5c10:	ff 90       	pop	r15
    5c12:	ef 90       	pop	r14
    5c14:	df 90       	pop	r13
    5c16:	cf 90       	pop	r12
    5c18:	bf 90       	pop	r11
    5c1a:	af 90       	pop	r10
    5c1c:	9f 90       	pop	r9
    5c1e:	8f 90       	pop	r8
    5c20:	7f 90       	pop	r7
    5c22:	6f 90       	pop	r6
    5c24:	5f 90       	pop	r5
    5c26:	4f 90       	pop	r4
    5c28:	3f 90       	pop	r3
    5c2a:	2f 90       	pop	r2
    5c2c:	08 95       	ret

00005c2e <print_settings_general_webpage>:


uint16_t print_settings_general_webpage(uint8_t *buf)
{
    5c2e:	cf 92       	push	r12
    5c30:	df 92       	push	r13
    5c32:	ef 92       	push	r14
    5c34:	ff 92       	push	r15
    5c36:	0f 93       	push	r16
    5c38:	1f 93       	push	r17
    5c3a:	cf 93       	push	r28
    5c3c:	df 93       	push	r29
    5c3e:	cd b7       	in	r28, 0x3d	; 61
    5c40:	de b7       	in	r29, 0x3e	; 62
    5c42:	2b 97       	sbiw	r28, 0x0b	; 11
    5c44:	0f b6       	in	r0, 0x3f	; 63
    5c46:	f8 94       	cli
    5c48:	de bf       	out	0x3e, r29	; 62
    5c4a:	0f be       	out	0x3f, r0	; 63
    5c4c:	cd bf       	out	0x3d, r28	; 61
    5c4e:	7c 01       	movw	r14, r24
        uint16_t plen;

		plen=http200ok();
    5c50:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>
        plen=fill_tcp_data_p(buf,plen,PSTR("<SCRIPT SRC='/loader.js'></SCRIPT><script>menu(2,1);formstart('/settings/general');"));
    5c54:	41 eb       	ldi	r20, 0xB1	; 177
    5c56:	58 e0       	ldi	r21, 0x08	; 8
    5c58:	bc 01       	movw	r22, r24
    5c5a:	c7 01       	movw	r24, r14
    5c5c:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    5c60:	6c 01       	movw	r12, r24

		char realpassword[11];
		eepromReadStr(200, realpassword, 10);      
    5c62:	4a e0       	ldi	r20, 0x0A	; 10
    5c64:	8e 01       	movw	r16, r28
    5c66:	0f 5f       	subi	r16, 0xFF	; 255
    5c68:	1f 4f       	sbci	r17, 0xFF	; 255
    5c6a:	b8 01       	movw	r22, r16
    5c6c:	88 ec       	ldi	r24, 0xC8	; 200
    5c6e:	90 e0       	ldi	r25, 0x00	; 0
    5c70:	0e 94 88 21 	call	0x4310	; 0x4310 <eepromReadStr>
		sprintf_P(tempbuf, PSTR("dw('Password : ');tf('PASS', '%s', 10);dw('<br>');"), realpassword);
    5c74:	1f 93       	push	r17
    5c76:	0f 93       	push	r16
    5c78:	2e e7       	ldi	r18, 0x7E	; 126
    5c7a:	38 e0       	ldi	r19, 0x08	; 8
    5c7c:	3f 93       	push	r19
    5c7e:	2f 93       	push	r18
    5c80:	0a e0       	ldi	r16, 0x0A	; 10
    5c82:	19 e0       	ldi	r17, 0x09	; 9
    5c84:	1f 93       	push	r17
    5c86:	0f 93       	push	r16
    5c88:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5c8c:	a8 01       	movw	r20, r16
    5c8e:	b6 01       	movw	r22, r12
    5c90:	c7 01       	movw	r24, r14
    5c92:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5c96:	6c 01       	movw	r12, r24

		uint8_t hasLcd = eepromReadByte(50);
    5c98:	82 e3       	ldi	r24, 0x32	; 50
    5c9a:	90 e0       	ldi	r25, 0x00	; 0
    5c9c:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
		sprintf_P(tempbuf, PSTR("dw('LCD : ');cb('LCD', '%u', 1);dw('<br>');"), hasLcd);
    5ca0:	1f 92       	push	r1
    5ca2:	8f 93       	push	r24
    5ca4:	22 e5       	ldi	r18, 0x52	; 82
    5ca6:	38 e0       	ldi	r19, 0x08	; 8
    5ca8:	3f 93       	push	r19
    5caa:	2f 93       	push	r18
    5cac:	1f 93       	push	r17
    5cae:	0f 93       	push	r16
    5cb0:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5cb4:	a8 01       	movw	r20, r16
    5cb6:	b6 01       	movw	r22, r12
    5cb8:	c7 01       	movw	r24, r14
    5cba:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5cbe:	6c 01       	movw	r12, r24

		sprintf_P(tempbuf, PSTR("formend();</script><br>"));
    5cc0:	2a e3       	ldi	r18, 0x3A	; 58
    5cc2:	38 e0       	ldi	r19, 0x08	; 8
    5cc4:	3f 93       	push	r19
    5cc6:	2f 93       	push	r18
    5cc8:	1f 93       	push	r17
    5cca:	0f 93       	push	r16
    5ccc:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5cd0:	a8 01       	movw	r20, r16
    5cd2:	b6 01       	movw	r22, r12
    5cd4:	c7 01       	movw	r24, r14
    5cd6:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5cda:	8c 01       	movw	r16, r24

		//Debug for at se hvor tt vi er p grnsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);
    5cdc:	1f 93       	push	r17
    5cde:	8f 93       	push	r24
    5ce0:	2c e2       	ldi	r18, 0x2C	; 44
    5ce2:	38 e0       	ldi	r19, 0x08	; 8
    5ce4:	3f 93       	push	r19
    5ce6:	2f 93       	push	r18
    5ce8:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>

        return(plen);
    5cec:	0f b6       	in	r0, 0x3f	; 63
    5cee:	f8 94       	cli
    5cf0:	de bf       	out	0x3e, r29	; 62
    5cf2:	0f be       	out	0x3f, r0	; 63
    5cf4:	cd bf       	out	0x3d, r28	; 61
}
    5cf6:	c8 01       	movw	r24, r16
    5cf8:	2b 96       	adiw	r28, 0x0b	; 11
    5cfa:	0f b6       	in	r0, 0x3f	; 63
    5cfc:	f8 94       	cli
    5cfe:	de bf       	out	0x3e, r29	; 62
    5d00:	0f be       	out	0x3f, r0	; 63
    5d02:	cd bf       	out	0x3d, r28	; 61
    5d04:	df 91       	pop	r29
    5d06:	cf 91       	pop	r28
    5d08:	1f 91       	pop	r17
    5d0a:	0f 91       	pop	r16
    5d0c:	ff 90       	pop	r15
    5d0e:	ef 90       	pop	r14
    5d10:	df 90       	pop	r13
    5d12:	cf 90       	pop	r12
    5d14:	08 95       	ret

00005d16 <print_settings_webpage>:

uint16_t print_settings_webpage(uint8_t *buf)
{
    5d16:	ef 92       	push	r14
    5d18:	ff 92       	push	r15
    5d1a:	0f 93       	push	r16
    5d1c:	1f 93       	push	r17
    5d1e:	cf 93       	push	r28
    5d20:	df 93       	push	r29
    5d22:	8c 01       	movw	r16, r24
        uint16_t plen;

		plen=http200ok();
    5d24:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>
        plen=fill_tcp_data_p(buf,plen,PSTR("<SCRIPT SRC='/loader.js'></SCRIPT><script>menu(2,1);formstart('/settings/net');"));
    5d28:	4c ed       	ldi	r20, 0xDC	; 220
    5d2a:	57 e0       	ldi	r21, 0x07	; 7
    5d2c:	bc 01       	movw	r22, r24
    5d2e:	c8 01       	movw	r24, r16
    5d30:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    5d34:	7c 01       	movw	r14, r24
      
		sprintf_P(tempbuf, PSTR("dw('IP : ');tf('IP0', %d, 2);tf('IP1', %d, 2);tf('IP2', %d, 2);tf('IP3', %d, 2);dw('<br>');"), myip[0], myip[1], myip[2], myip[3]);
    5d36:	80 91 22 01 	lds	r24, 0x0122
    5d3a:	1f 92       	push	r1
    5d3c:	8f 93       	push	r24
    5d3e:	80 91 21 01 	lds	r24, 0x0121
    5d42:	1f 92       	push	r1
    5d44:	8f 93       	push	r24
    5d46:	80 91 20 01 	lds	r24, 0x0120
    5d4a:	1f 92       	push	r1
    5d4c:	8f 93       	push	r24
    5d4e:	80 91 1f 01 	lds	r24, 0x011F
    5d52:	1f 92       	push	r1
    5d54:	8f 93       	push	r24
    5d56:	20 e8       	ldi	r18, 0x80	; 128
    5d58:	37 e0       	ldi	r19, 0x07	; 7
    5d5a:	3f 93       	push	r19
    5d5c:	2f 93       	push	r18
    5d5e:	ca e0       	ldi	r28, 0x0A	; 10
    5d60:	d9 e0       	ldi	r29, 0x09	; 9
    5d62:	df 93       	push	r29
    5d64:	cf 93       	push	r28
    5d66:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5d6a:	ae 01       	movw	r20, r28
    5d6c:	b7 01       	movw	r22, r14
    5d6e:	c8 01       	movw	r24, r16
    5d70:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5d74:	7c 01       	movw	r14, r24

		sprintf_P(tempbuf, PSTR("dw('GW : ');tf('GW0', %d, 2);tf('GW1', %d, 2);tf('GW2', %d, 2);tf('GW3', %d, 2);dw('<br>');"), gwip[0], gwip[1], gwip[2], gwip[3]);
    5d76:	80 91 26 01 	lds	r24, 0x0126
    5d7a:	1f 92       	push	r1
    5d7c:	8f 93       	push	r24
    5d7e:	80 91 25 01 	lds	r24, 0x0125
    5d82:	1f 92       	push	r1
    5d84:	8f 93       	push	r24
    5d86:	80 91 24 01 	lds	r24, 0x0124
    5d8a:	1f 92       	push	r1
    5d8c:	8f 93       	push	r24
    5d8e:	80 91 23 01 	lds	r24, 0x0123
    5d92:	1f 92       	push	r1
    5d94:	8f 93       	push	r24
    5d96:	24 e2       	ldi	r18, 0x24	; 36
    5d98:	37 e0       	ldi	r19, 0x07	; 7
    5d9a:	3f 93       	push	r19
    5d9c:	2f 93       	push	r18
    5d9e:	df 93       	push	r29
    5da0:	cf 93       	push	r28
    5da2:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5da6:	ae 01       	movw	r20, r28
    5da8:	b7 01       	movw	r22, r14
    5daa:	c8 01       	movw	r24, r16
    5dac:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5db0:	7c 01       	movw	r14, r24

		sprintf_P(tempbuf, PSTR("dw('DNS: ');tf('DNS0', %d, 2);tf('DNS1', %d, 2);tf('DNS2', %d, 2);tf('DNS3', %d, 2);dw('<br>');"), dnsip[0], dnsip[1], dnsip[2], dnsip[3]);
    5db2:	80 91 16 01 	lds	r24, 0x0116
    5db6:	1f 92       	push	r1
    5db8:	8f 93       	push	r24
    5dba:	80 91 15 01 	lds	r24, 0x0115
    5dbe:	1f 92       	push	r1
    5dc0:	8f 93       	push	r24
    5dc2:	80 91 14 01 	lds	r24, 0x0114
    5dc6:	1f 92       	push	r1
    5dc8:	8f 93       	push	r24
    5dca:	80 91 13 01 	lds	r24, 0x0113
    5dce:	1f 92       	push	r1
    5dd0:	8f 93       	push	r24
    5dd2:	24 ec       	ldi	r18, 0xC4	; 196
    5dd4:	36 e0       	ldi	r19, 0x06	; 6
    5dd6:	3f 93       	push	r19
    5dd8:	2f 93       	push	r18
    5dda:	df 93       	push	r29
    5ddc:	cf 93       	push	r28
    5dde:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5de2:	8d b7       	in	r24, 0x3d	; 61
    5de4:	9e b7       	in	r25, 0x3e	; 62
    5de6:	84 96       	adiw	r24, 0x24	; 36
    5de8:	0f b6       	in	r0, 0x3f	; 63
    5dea:	f8 94       	cli
    5dec:	9e bf       	out	0x3e, r25	; 62
    5dee:	0f be       	out	0x3f, r0	; 63
    5df0:	8d bf       	out	0x3d, r24	; 61
    5df2:	ae 01       	movw	r20, r28
    5df4:	b7 01       	movw	r22, r14
    5df6:	c8 01       	movw	r24, r16
    5df8:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5dfc:	7c 01       	movw	r14, r24

		sprintf_P(tempbuf, PSTR("dw('MASK: ');tf('MASK0', %d, 2);tf('MASK1', %d, 2);tf('MASK2', %d, 2);tf('MASK3', %d, 2);formend();</script><br>"), netmask[0], netmask[1], netmask[2], netmask[3]);
    5dfe:	80 91 1a 01 	lds	r24, 0x011A
    5e02:	1f 92       	push	r1
    5e04:	8f 93       	push	r24
    5e06:	80 91 19 01 	lds	r24, 0x0119
    5e0a:	1f 92       	push	r1
    5e0c:	8f 93       	push	r24
    5e0e:	80 91 18 01 	lds	r24, 0x0118
    5e12:	1f 92       	push	r1
    5e14:	8f 93       	push	r24
    5e16:	80 91 17 01 	lds	r24, 0x0117
    5e1a:	1f 92       	push	r1
    5e1c:	8f 93       	push	r24
    5e1e:	23 e5       	ldi	r18, 0x53	; 83
    5e20:	36 e0       	ldi	r19, 0x06	; 6
    5e22:	3f 93       	push	r19
    5e24:	2f 93       	push	r18
    5e26:	df 93       	push	r29
    5e28:	cf 93       	push	r28
    5e2a:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		plen=fill_tcp_data(buf,plen,tempbuf);
    5e2e:	ae 01       	movw	r20, r28
    5e30:	b7 01       	movw	r22, r14
    5e32:	c8 01       	movw	r24, r16
    5e34:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5e38:	d8 2f       	mov	r29, r24
    5e3a:	c9 2f       	mov	r28, r25

		//Debug for at se hvor tt vi er p grnsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);
    5e3c:	9f 93       	push	r25
    5e3e:	8f 93       	push	r24
    5e40:	25 e4       	ldi	r18, 0x45	; 69
    5e42:	36 e0       	ldi	r19, 0x06	; 6
    5e44:	3f 93       	push	r19
    5e46:	2f 93       	push	r18
    5e48:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>

        return(plen);
    5e4c:	8d b7       	in	r24, 0x3d	; 61
    5e4e:	9e b7       	in	r25, 0x3e	; 62
    5e50:	40 96       	adiw	r24, 0x10	; 16
    5e52:	0f b6       	in	r0, 0x3f	; 63
    5e54:	f8 94       	cli
    5e56:	9e bf       	out	0x3e, r25	; 62
    5e58:	0f be       	out	0x3f, r0	; 63
    5e5a:	8d bf       	out	0x3d, r24	; 61
}
    5e5c:	8d 2f       	mov	r24, r29
    5e5e:	9c 2f       	mov	r25, r28
    5e60:	df 91       	pop	r29
    5e62:	cf 91       	pop	r28
    5e64:	1f 91       	pop	r17
    5e66:	0f 91       	pop	r16
    5e68:	ff 90       	pop	r15
    5e6a:	ef 90       	pop	r14
    5e6c:	08 95       	ret

00005e6e <print_settings_io_webpage>:

uint16_t print_settings_io_webpage(uint8_t *buf)
{
    5e6e:	8f 92       	push	r8
    5e70:	9f 92       	push	r9
    5e72:	af 92       	push	r10
    5e74:	bf 92       	push	r11
    5e76:	cf 92       	push	r12
    5e78:	df 92       	push	r13
    5e7a:	ef 92       	push	r14
    5e7c:	ff 92       	push	r15
    5e7e:	0f 93       	push	r16
    5e80:	1f 93       	push	r17
    5e82:	cf 93       	push	r28
    5e84:	df 93       	push	r29
    5e86:	7c 01       	movw	r14, r24
        uint16_t plen;

		plen=http200ok();
    5e88:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>
        plen=fill_tcp_data_p(buf,plen,PSTR("<SCRIPT SRC='/loader.js'></SCRIPT><script>menu(2,1);formstart('/settings/io');tfh('io','1',0);dw('<table border=0>');"));
    5e8c:	4f ec       	ldi	r20, 0xCF	; 207
    5e8e:	55 e0       	ldi	r21, 0x05	; 5
    5e90:	bc 01       	movw	r22, r24
    5e92:	c7 01       	movw	r24, r14
    5e94:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    5e98:	8c 01       	movw	r16, r24
    5e9a:	ec ea       	ldi	r30, 0xAC	; 172
    5e9c:	8e 2e       	mov	r8, r30
    5e9e:	e5 e0       	ldi	r30, 0x05	; 5
    5ea0:	9e 2e       	mov	r9, r30
    5ea2:	c0 e0       	ldi	r28, 0x00	; 0
    5ea4:	d0 e0       	ldi	r29, 0x00	; 0
    
	  	for (uint8_t i=0; i<8; i++)
		{
			sprintf_P(tempbuf, PSTR("adcset(%d, 'ADC%d', %d);"),i,i,simpleSensorTypes[i]);
    5ea6:	f6 eb       	ldi	r31, 0xB6	; 182
    5ea8:	af 2e       	mov	r10, r31
    5eaa:	f5 e0       	ldi	r31, 0x05	; 5
    5eac:	bf 2e       	mov	r11, r31
    5eae:	aa e0       	ldi	r26, 0x0A	; 10
    5eb0:	ca 2e       	mov	r12, r26
    5eb2:	a9 e0       	ldi	r26, 0x09	; 9
    5eb4:	da 2e       	mov	r13, r26
    5eb6:	f4 01       	movw	r30, r8
    5eb8:	81 91       	ld	r24, Z+
    5eba:	4f 01       	movw	r8, r30
    5ebc:	1f 92       	push	r1
    5ebe:	8f 93       	push	r24
    5ec0:	df 93       	push	r29
    5ec2:	cf 93       	push	r28
    5ec4:	df 93       	push	r29
    5ec6:	cf 93       	push	r28
    5ec8:	bf 92       	push	r11
    5eca:	af 92       	push	r10
    5ecc:	df 92       	push	r13
    5ece:	cf 92       	push	r12
    5ed0:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			plen=fill_tcp_data(buf,plen,tempbuf);
    5ed4:	4a e0       	ldi	r20, 0x0A	; 10
    5ed6:	59 e0       	ldi	r21, 0x09	; 9
    5ed8:	b8 01       	movw	r22, r16
    5eda:	c7 01       	movw	r24, r14
    5edc:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5ee0:	8c 01       	movw	r16, r24
    5ee2:	21 96       	adiw	r28, 0x01	; 1
        uint16_t plen;

		plen=http200ok();
        plen=fill_tcp_data_p(buf,plen,PSTR("<SCRIPT SRC='/loader.js'></SCRIPT><script>menu(2,1);formstart('/settings/io');tfh('io','1',0);dw('<table border=0>');"));
    
	  	for (uint8_t i=0; i<8; i++)
    5ee4:	ed b7       	in	r30, 0x3d	; 61
    5ee6:	fe b7       	in	r31, 0x3e	; 62
    5ee8:	3a 96       	adiw	r30, 0x0a	; 10
    5eea:	0f b6       	in	r0, 0x3f	; 63
    5eec:	f8 94       	cli
    5eee:	fe bf       	out	0x3e, r31	; 62
    5ef0:	0f be       	out	0x3f, r0	; 63
    5ef2:	ed bf       	out	0x3d, r30	; 61
    5ef4:	c8 30       	cpi	r28, 0x08	; 8
    5ef6:	d1 05       	cpc	r29, r1
    5ef8:	f1 f6       	brne	.-68     	; 0x5eb6 <print_settings_io_webpage+0x48>
    5efa:	54 eb       	ldi	r21, 0xB4	; 180
    5efc:	85 2e       	mov	r8, r21
    5efe:	55 e0       	ldi	r21, 0x05	; 5
    5f00:	95 2e       	mov	r9, r21
    5f02:	c0 e0       	ldi	r28, 0x00	; 0
    5f04:	d0 e0       	ldi	r29, 0x00	; 0
			plen=fill_tcp_data(buf,plen,tempbuf);
		}

	  	for (uint8_t i=0; i<4; i++)
		{
			sprintf_P(tempbuf, PSTR("dport(%d, 'D%d', %d);"),i,i,simpleSensorTypes[i+8]);
    5f06:	60 ea       	ldi	r22, 0xA0	; 160
    5f08:	a6 2e       	mov	r10, r22
    5f0a:	65 e0       	ldi	r22, 0x05	; 5
    5f0c:	b6 2e       	mov	r11, r22
    5f0e:	7a e0       	ldi	r23, 0x0A	; 10
    5f10:	c7 2e       	mov	r12, r23
    5f12:	79 e0       	ldi	r23, 0x09	; 9
    5f14:	d7 2e       	mov	r13, r23
    5f16:	f4 01       	movw	r30, r8
    5f18:	81 91       	ld	r24, Z+
    5f1a:	4f 01       	movw	r8, r30
    5f1c:	1f 92       	push	r1
    5f1e:	8f 93       	push	r24
    5f20:	df 93       	push	r29
    5f22:	cf 93       	push	r28
    5f24:	df 93       	push	r29
    5f26:	cf 93       	push	r28
    5f28:	bf 92       	push	r11
    5f2a:	af 92       	push	r10
    5f2c:	df 92       	push	r13
    5f2e:	cf 92       	push	r12
    5f30:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			plen=fill_tcp_data(buf,plen,tempbuf);
    5f34:	4a e0       	ldi	r20, 0x0A	; 10
    5f36:	59 e0       	ldi	r21, 0x09	; 9
    5f38:	b8 01       	movw	r22, r16
    5f3a:	c7 01       	movw	r24, r14
    5f3c:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    5f40:	8c 01       	movw	r16, r24
    5f42:	21 96       	adiw	r28, 0x01	; 1
		{
			sprintf_P(tempbuf, PSTR("adcset(%d, 'ADC%d', %d);"),i,i,simpleSensorTypes[i]);
			plen=fill_tcp_data(buf,plen,tempbuf);
		}

	  	for (uint8_t i=0; i<4; i++)
    5f44:	ed b7       	in	r30, 0x3d	; 61
    5f46:	fe b7       	in	r31, 0x3e	; 62
    5f48:	3a 96       	adiw	r30, 0x0a	; 10
    5f4a:	0f b6       	in	r0, 0x3f	; 63
    5f4c:	f8 94       	cli
    5f4e:	fe bf       	out	0x3e, r31	; 62
    5f50:	0f be       	out	0x3f, r0	; 63
    5f52:	ed bf       	out	0x3d, r30	; 61
    5f54:	c4 30       	cpi	r28, 0x04	; 4
    5f56:	d1 05       	cpc	r29, r1
    5f58:	f1 f6       	brne	.-68     	; 0x5f16 <print_settings_io_webpage+0xa8>
		{
			sprintf_P(tempbuf, PSTR("dport(%d, 'D%d', %d);"),i,i,simpleSensorTypes[i+8]);
			plen=fill_tcp_data(buf,plen,tempbuf);
		}

		plen=fill_tcp_data_p(buf,plen,PSTR("dw('</table>');formend();</script>"));
    5f5a:	4d e7       	ldi	r20, 0x7D	; 125
    5f5c:	55 e0       	ldi	r21, 0x05	; 5
    5f5e:	bc 01       	movw	r22, r24
    5f60:	c7 01       	movw	r24, r14
    5f62:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
    5f66:	d8 2f       	mov	r29, r24
    5f68:	c9 2f       	mov	r28, r25

		//Debug for at se hvor tt vi er p grnsen (buffer size - lidt)
		printf_P(PSTR("Plen is %d \r\n"), plen);
    5f6a:	9f 93       	push	r25
    5f6c:	8f 93       	push	r24
    5f6e:	2f e6       	ldi	r18, 0x6F	; 111
    5f70:	35 e0       	ldi	r19, 0x05	; 5
    5f72:	3f 93       	push	r19
    5f74:	2f 93       	push	r18
    5f76:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>

        return(plen);
    5f7a:	0f 90       	pop	r0
    5f7c:	0f 90       	pop	r0
    5f7e:	0f 90       	pop	r0
    5f80:	0f 90       	pop	r0
}
    5f82:	8d 2f       	mov	r24, r29
    5f84:	9c 2f       	mov	r25, r28
    5f86:	df 91       	pop	r29
    5f88:	cf 91       	pop	r28
    5f8a:	1f 91       	pop	r17
    5f8c:	0f 91       	pop	r16
    5f8e:	ff 90       	pop	r15
    5f90:	ef 90       	pop	r14
    5f92:	df 90       	pop	r13
    5f94:	cf 90       	pop	r12
    5f96:	bf 90       	pop	r11
    5f98:	af 90       	pop	r10
    5f9a:	9f 90       	pop	r9
    5f9c:	8f 90       	pop	r8
    5f9e:	08 95       	ret

00005fa0 <print_flash_webpage>:


uint16_t print_flash_webpage(bool gzip, const char * pos, uint8_t *buf)
{
    5fa0:	cf 92       	push	r12
    5fa2:	df 92       	push	r13
    5fa4:	ef 92       	push	r14
    5fa6:	ff 92       	push	r15
    5fa8:	0f 93       	push	r16
    5faa:	1f 93       	push	r17
    5fac:	cf 93       	push	r28
    5fae:	df 93       	push	r29
    5fb0:	1f 92       	push	r1
    5fb2:	cd b7       	in	r28, 0x3d	; 61
    5fb4:	de b7       	in	r29, 0x3e	; 62
    5fb6:	8b 01       	movw	r16, r22
    5fb8:	6a 01       	movw	r12, r20
        uint16_t plen;
		uint8_t c;

		if (gzip) 
    5fba:	88 23       	and	r24, r24
    5fbc:	19 f0       	breq	.+6      	; 0x5fc4 <print_flash_webpage+0x24>
			plen=http200gzok();
    5fbe:	0e 94 3d 29 	call	0x527a	; 0x527a <http200gzok>
    5fc2:	02 c0       	rjmp	.+4      	; 0x5fc8 <print_flash_webpage+0x28>
		else
			plen=http200ok();
    5fc4:	0e 94 35 29 	call	0x526a	; 0x526a <http200ok>

		while (true)
		{
			if (
			(c = pgm_read_byte(pos)) == '%' && 
    5fc8:	f8 01       	movw	r30, r16
    5fca:	24 91       	lpm	r18, Z
    5fcc:	29 83       	std	Y+1, r18	; 0x01
    5fce:	a8 01       	movw	r20, r16
    5fd0:	4f 5f       	subi	r20, 0xFF	; 255
    5fd2:	5f 4f       	sbci	r21, 0xFF	; 255
    5fd4:	7a 01       	movw	r14, r20
		else
			plen=http200ok();

		while (true)
		{
			if (
    5fd6:	25 32       	cpi	r18, 0x25	; 37
    5fd8:	69 f4       	brne	.+26     	; 0x5ff4 <print_flash_webpage+0x54>
			(c = pgm_read_byte(pos)) == '%' && 
			pgm_read_byte(pos+1) == 'E' &&
    5fda:	fa 01       	movw	r30, r20
    5fdc:	24 91       	lpm	r18, Z
			plen=http200ok();

		while (true)
		{
			if (
			(c = pgm_read_byte(pos)) == '%' && 
    5fde:	25 34       	cpi	r18, 0x45	; 69
    5fe0:	49 f4       	brne	.+18     	; 0x5ff4 <print_flash_webpage+0x54>
    5fe2:	31 96       	adiw	r30, 0x01	; 1
			pgm_read_byte(pos+1) == 'E' &&
			pgm_read_byte(pos+2) == 'N' &&
    5fe4:	e4 91       	lpm	r30, Z

		while (true)
		{
			if (
			(c = pgm_read_byte(pos)) == '%' && 
			pgm_read_byte(pos+1) == 'E' &&
    5fe6:	ee 34       	cpi	r30, 0x4E	; 78
    5fe8:	29 f4       	brne	.+10     	; 0x5ff4 <print_flash_webpage+0x54>
    5fea:	f8 01       	movw	r30, r16
    5fec:	33 96       	adiw	r30, 0x03	; 3
			pgm_read_byte(pos+2) == 'N' &&
			pgm_read_byte(pos+3) == 'D'
    5fee:	04 91       	lpm	r16, Z
		while (true)
		{
			if (
			(c = pgm_read_byte(pos)) == '%' && 
			pgm_read_byte(pos+1) == 'E' &&
			pgm_read_byte(pos+2) == 'N' &&
    5ff0:	04 34       	cpi	r16, 0x44	; 68
    5ff2:	51 f0       	breq	.+20     	; 0x6008 <print_flash_webpage+0x68>
			pgm_read_byte(pos+3) == 'D'
			)
			{
				break;
			} else {
				plen = fill_tcp_data_len(buf, plen, &c, 1);
    5ff4:	21 e0       	ldi	r18, 0x01	; 1
    5ff6:	ae 01       	movw	r20, r28
    5ff8:	4f 5f       	subi	r20, 0xFF	; 255
    5ffa:	5f 4f       	sbci	r21, 0xFF	; 255
    5ffc:	bc 01       	movw	r22, r24
    5ffe:	c6 01       	movw	r24, r12
    6000:	0e 94 42 12 	call	0x2484	; 0x2484 <fill_tcp_data_len>
				pos++;
    6004:	87 01       	movw	r16, r14
			}
		}
    6006:	e0 cf       	rjmp	.-64     	; 0x5fc8 <print_flash_webpage+0x28>

        return(plen);
}
    6008:	0f 90       	pop	r0
    600a:	df 91       	pop	r29
    600c:	cf 91       	pop	r28
    600e:	1f 91       	pop	r17
    6010:	0f 91       	pop	r16
    6012:	ff 90       	pop	r15
    6014:	ef 90       	pop	r14
    6016:	df 90       	pop	r13
    6018:	cf 90       	pop	r12
    601a:	08 95       	ret

0000601c <user_is_auth>:

bool user_is_auth(char* buffer)
{
    601c:	0f 93       	push	r16
    601e:	1f 93       	push	r17
    6020:	cf 93       	push	r28
    6022:	df 93       	push	r29
    6024:	cd b7       	in	r28, 0x3d	; 61
    6026:	de b7       	in	r29, 0x3e	; 62
    6028:	2b 97       	sbiw	r28, 0x0b	; 11
    602a:	0f b6       	in	r0, 0x3f	; 63
    602c:	f8 94       	cli
    602e:	de bf       	out	0x3e, r29	; 62
    6030:	0f be       	out	0x3f, r0	; 63
    6032:	cd bf       	out	0x3d, r28	; 61
    6034:	8c 01       	movw	r16, r24
printf_P(PSTR("buf = %s \r\n"), buffer);
    6036:	1f 93       	push	r17
    6038:	8f 93       	push	r24
    603a:	23 e6       	ldi	r18, 0x63	; 99
    603c:	35 e0       	ldi	r19, 0x05	; 5
    603e:	3f 93       	push	r19
    6040:	2f 93       	push	r18
    6042:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
	char* pos = strstr_P(buffer, PSTR("Authorization"));
    6046:	65 e5       	ldi	r22, 0x55	; 85
    6048:	75 e0       	ldi	r23, 0x05	; 5
    604a:	c8 01       	movw	r24, r16
    604c:	0e 94 b3 3d 	call	0x7b66	; 0x7b66 <strstr_P>
	pos+= 21; //Authorization: Basic
    6050:	bc 01       	movw	r22, r24
    6052:	6b 5e       	subi	r22, 0xEB	; 235
    6054:	7f 4f       	sbci	r23, 0xFF	; 255
	if (pos != NULL)
    6056:	0f 90       	pop	r0
    6058:	0f 90       	pop	r0
    605a:	0f 90       	pop	r0
    605c:	0f 90       	pop	r0
    605e:	61 15       	cp	r22, r1
    6060:	71 05       	cpc	r23, r1
    6062:	89 f1       	breq	.+98     	; 0x60c6 <user_is_auth+0xaa>
    6064:	fb 01       	movw	r30, r22
    6066:	df 01       	movw	r26, r30
	{
		char* ptr2 = (char*)pos;
		while (*ptr2 != '\r' && *ptr2 != '\n') ptr2++;
    6068:	81 91       	ld	r24, Z+
    606a:	8d 30       	cpi	r24, 0x0D	; 13
    606c:	b1 f4       	brne	.+44     	; 0x609a <user_is_auth+0x7e>
		*ptr2 = '\0';
    606e:	1c 92       	st	X, r1
	
		memset(tempbuf, '\0', 25);
    6070:	89 e1       	ldi	r24, 0x19	; 25
    6072:	ea e0       	ldi	r30, 0x0A	; 10
    6074:	f9 e0       	ldi	r31, 0x09	; 9
    6076:	df 01       	movw	r26, r30
    6078:	1d 92       	st	X+, r1
    607a:	8a 95       	dec	r24
    607c:	e9 f7       	brne	.-6      	; 0x6078 <user_is_auth+0x5c>
		base64dec(tempbuf, pos, 1);
    607e:	41 e0       	ldi	r20, 0x01	; 1
    6080:	cf 01       	movw	r24, r30
    6082:	0e 94 b7 23 	call	0x476e	; 0x476e <base64dec>

		char* password = strstr(tempbuf, ":");
    6086:	6a e3       	ldi	r22, 0x3A	; 58
    6088:	70 e0       	ldi	r23, 0x00	; 0
    608a:	8a e0       	ldi	r24, 0x0A	; 10
    608c:	99 e0       	ldi	r25, 0x09	; 9
    608e:	0e 94 d4 3d 	call	0x7ba8	; 0x7ba8 <strchr>
    6092:	8c 01       	movw	r16, r24

		if (password != NULL)
    6094:	00 97       	sbiw	r24, 0x00	; 0
    6096:	21 f4       	brne	.+8      	; 0x60a0 <user_is_auth+0x84>
    6098:	16 c0       	rjmp	.+44     	; 0x60c6 <user_is_auth+0xaa>
	char* pos = strstr_P(buffer, PSTR("Authorization"));
	pos+= 21; //Authorization: Basic
	if (pos != NULL)
	{
		char* ptr2 = (char*)pos;
		while (*ptr2 != '\r' && *ptr2 != '\n') ptr2++;
    609a:	8a 30       	cpi	r24, 0x0A	; 10
    609c:	21 f7       	brne	.-56     	; 0x6066 <user_is_auth+0x4a>
    609e:	e7 cf       	rjmp	.-50     	; 0x606e <user_is_auth+0x52>
		if (password != NULL)
		{
			password++;

			char realpassword[11];
			eepromReadStr(200, realpassword, 10);
    60a0:	4a e0       	ldi	r20, 0x0A	; 10
    60a2:	be 01       	movw	r22, r28
    60a4:	6f 5f       	subi	r22, 0xFF	; 255
    60a6:	7f 4f       	sbci	r23, 0xFF	; 255
    60a8:	88 ec       	ldi	r24, 0xC8	; 200
    60aa:	90 e0       	ldi	r25, 0x00	; 0
    60ac:	0e 94 88 21 	call	0x4310	; 0x4310 <eepromReadStr>

			if (strcmp(password, realpassword)==0)
    60b0:	be 01       	movw	r22, r28
    60b2:	6f 5f       	subi	r22, 0xFF	; 255
    60b4:	7f 4f       	sbci	r23, 0xFF	; 255
    60b6:	c8 01       	movw	r24, r16
    60b8:	01 96       	adiw	r24, 0x01	; 1
    60ba:	0e 94 df 3d 	call	0x7bbe	; 0x7bbe <strcmp>
    60be:	89 2b       	or	r24, r25
    60c0:	11 f4       	brne	.+4      	; 0x60c6 <user_is_auth+0xaa>
			{
				return true;
    60c2:	81 e0       	ldi	r24, 0x01	; 1
    60c4:	01 c0       	rjmp	.+2      	; 0x60c8 <user_is_auth+0xac>
			}
		}

		return false;
    60c6:	80 e0       	ldi	r24, 0x00	; 0
	}
	return false;
}
    60c8:	2b 96       	adiw	r28, 0x0b	; 11
    60ca:	0f b6       	in	r0, 0x3f	; 63
    60cc:	f8 94       	cli
    60ce:	de bf       	out	0x3e, r29	; 62
    60d0:	0f be       	out	0x3f, r0	; 63
    60d2:	cd bf       	out	0x3d, r28	; 61
    60d4:	df 91       	pop	r29
    60d6:	cf 91       	pop	r28
    60d8:	1f 91       	pop	r17
    60da:	0f 91       	pop	r16
    60dc:	08 95       	ret

000060de <fill_custom_client_data>:

//Bliver kaldt nr vi er forbundet til serveren og skal sende GET url...
uint16_t fill_custom_client_data(uint8_t *bufptr,uint16_t len)
{
    60de:	2f 92       	push	r2
    60e0:	3f 92       	push	r3
    60e2:	4f 92       	push	r4
    60e4:	5f 92       	push	r5
    60e6:	6f 92       	push	r6
    60e8:	7f 92       	push	r7
    60ea:	8f 92       	push	r8
    60ec:	9f 92       	push	r9
    60ee:	af 92       	push	r10
    60f0:	bf 92       	push	r11
    60f2:	cf 92       	push	r12
    60f4:	df 92       	push	r13
    60f6:	ef 92       	push	r14
    60f8:	ff 92       	push	r15
    60fa:	0f 93       	push	r16
    60fc:	1f 93       	push	r17
    60fe:	cf 93       	push	r28
    6100:	df 93       	push	r29
    6102:	00 d0       	rcall	.+0      	; 0x6104 <fill_custom_client_data+0x26>
    6104:	00 d0       	rcall	.+0      	; 0x6106 <fill_custom_client_data+0x28>
    6106:	cd b7       	in	r28, 0x3d	; 61
    6108:	de b7       	in	r29, 0x3e	; 62
    610a:	6c 01       	movw	r12, r24
    610c:	7c 83       	std	Y+4, r23	; 0x04
    610e:	6b 83       	std	Y+3, r22	; 0x03

	if (start_web_client == 10)
    6110:	80 91 a2 05 	lds	r24, 0x05A2
    6114:	8a 30       	cpi	r24, 0x0A	; 10
    6116:	09 f4       	brne	.+2      	; 0x611a <fill_custom_client_data+0x3c>
    6118:	75 c1       	rjmp	.+746    	; 0x6404 <fill_custom_client_data+0x326>
    611a:	7a e0       	ldi	r23, 0x0A	; 10
    611c:	e7 2e       	mov	r14, r23
    611e:	79 e1       	ldi	r23, 0x19	; 25
    6120:	f7 2e       	mov	r15, r23
    6122:	00 e0       	ldi	r16, 0x00	; 0
    6124:	10 e0       	ldi	r17, 0x00	; 0
		len = fill_tcp_data(bufptr,len,tempbuf);
#endif

	for (uint8_t i=0; i<8; i++)
	{
		sprintf_P(tempbuf, PSTR("&ADC%u=%u"), i, simpleSensorValues[i]);
    6126:	eb e4       	ldi	r30, 0x4B	; 75
    6128:	8e 2e       	mov	r8, r30
    612a:	e5 e0       	ldi	r30, 0x05	; 5
    612c:	9e 2e       	mov	r9, r30
    612e:	fa e0       	ldi	r31, 0x0A	; 10
    6130:	af 2e       	mov	r10, r31
    6132:	f9 e0       	ldi	r31, 0x09	; 9
    6134:	bf 2e       	mov	r11, r31
    6136:	d7 01       	movw	r26, r14
    6138:	8c 91       	ld	r24, X
    613a:	11 96       	adiw	r26, 0x01	; 1
    613c:	9c 91       	ld	r25, X
    613e:	b2 e0       	ldi	r27, 0x02	; 2
    6140:	eb 0e       	add	r14, r27
    6142:	f1 1c       	adc	r15, r1
    6144:	9f 93       	push	r25
    6146:	8f 93       	push	r24
    6148:	1f 93       	push	r17
    614a:	0f 93       	push	r16
    614c:	9f 92       	push	r9
    614e:	8f 92       	push	r8
    6150:	bf 92       	push	r11
    6152:	af 92       	push	r10
    6154:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		len = fill_tcp_data(bufptr,len,tempbuf);
    6158:	4a e0       	ldi	r20, 0x0A	; 10
    615a:	59 e0       	ldi	r21, 0x09	; 9
    615c:	6b 81       	ldd	r22, Y+3	; 0x03
    615e:	7c 81       	ldd	r23, Y+4	; 0x04
    6160:	c6 01       	movw	r24, r12
    6162:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    6166:	9c 83       	std	Y+4, r25	; 0x04
    6168:	8b 83       	std	Y+3, r24	; 0x03
    616a:	0f 5f       	subi	r16, 0xFF	; 255
    616c:	1f 4f       	sbci	r17, 0xFF	; 255
#if SBNG_TARGET == 50
		sprintf_P(tempbuf, PSTR("&ALARM=%u"), alarmTimeout);
		len = fill_tcp_data(bufptr,len,tempbuf);
#endif

	for (uint8_t i=0; i<8; i++)
    616e:	0f b6       	in	r0, 0x3f	; 63
    6170:	f8 94       	cli
    6172:	de bf       	out	0x3e, r29	; 62
    6174:	0f be       	out	0x3f, r0	; 63
    6176:	cd bf       	out	0x3d, r28	; 61
    6178:	08 30       	cpi	r16, 0x08	; 8
    617a:	11 05       	cpc	r17, r1
    617c:	e1 f6       	brne	.-72     	; 0x6136 <fill_custom_client_data+0x58>
    617e:	4a e1       	ldi	r20, 0x1A	; 26
    6180:	e4 2e       	mov	r14, r20
    6182:	49 e1       	ldi	r20, 0x19	; 25
    6184:	f4 2e       	mov	r15, r20
    6186:	00 e0       	ldi	r16, 0x00	; 0
    6188:	10 e0       	ldi	r17, 0x00	; 0
		len = fill_tcp_data(bufptr,len,tempbuf);
	}

	for (uint8_t i=0; i<4; i++)
	{
		sprintf_P(tempbuf, PSTR("&D%u=%u"), i, simpleSensorValues[i+8]);
    618a:	53 e4       	ldi	r21, 0x43	; 67
    618c:	85 2e       	mov	r8, r21
    618e:	55 e0       	ldi	r21, 0x05	; 5
    6190:	95 2e       	mov	r9, r21
    6192:	6a e0       	ldi	r22, 0x0A	; 10
    6194:	a6 2e       	mov	r10, r22
    6196:	69 e0       	ldi	r22, 0x09	; 9
    6198:	b6 2e       	mov	r11, r22
    619a:	d7 01       	movw	r26, r14
    619c:	8c 91       	ld	r24, X
    619e:	11 96       	adiw	r26, 0x01	; 1
    61a0:	9c 91       	ld	r25, X
    61a2:	b2 e0       	ldi	r27, 0x02	; 2
    61a4:	eb 0e       	add	r14, r27
    61a6:	f1 1c       	adc	r15, r1
    61a8:	9f 93       	push	r25
    61aa:	8f 93       	push	r24
    61ac:	1f 93       	push	r17
    61ae:	0f 93       	push	r16
    61b0:	9f 92       	push	r9
    61b2:	8f 92       	push	r8
    61b4:	bf 92       	push	r11
    61b6:	af 92       	push	r10
    61b8:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		len = fill_tcp_data(bufptr,len,tempbuf);
    61bc:	4a e0       	ldi	r20, 0x0A	; 10
    61be:	59 e0       	ldi	r21, 0x09	; 9
    61c0:	6b 81       	ldd	r22, Y+3	; 0x03
    61c2:	7c 81       	ldd	r23, Y+4	; 0x04
    61c4:	c6 01       	movw	r24, r12
    61c6:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    61ca:	9c 83       	std	Y+4, r25	; 0x04
    61cc:	8b 83       	std	Y+3, r24	; 0x03
    61ce:	0f 5f       	subi	r16, 0xFF	; 255
    61d0:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		sprintf_P(tempbuf, PSTR("&ADC%u=%u"), i, simpleSensorValues[i]);
		len = fill_tcp_data(bufptr,len,tempbuf);
	}

	for (uint8_t i=0; i<4; i++)
    61d2:	0f b6       	in	r0, 0x3f	; 63
    61d4:	f8 94       	cli
    61d6:	de bf       	out	0x3e, r29	; 62
    61d8:	0f be       	out	0x3f, r0	; 63
    61da:	cd bf       	out	0x3d, r28	; 61
    61dc:	04 30       	cpi	r16, 0x04	; 4
    61de:	11 05       	cpc	r17, r1
    61e0:	e1 f6       	brne	.-72     	; 0x619a <fill_custom_client_data+0xbc>
    61e2:	0a e1       	ldi	r16, 0x1A	; 26
    61e4:	16 e0       	ldi	r17, 0x06	; 6

    for (uint8_t i=0; i<MAXSENSORS; i++)
    {  
      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
      {
        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    61e6:	91 e7       	ldi	r25, 0x71	; 113
    61e8:	89 2e       	mov	r8, r25
    61ea:	92 e0       	ldi	r25, 0x02	; 2
    61ec:	99 2e       	mov	r9, r25
    
        sprintf_P(tempbuf, PSTR("&%02X%02X%02X%02X%02X%02X%02X%02X=%c%d.%04d"),
    61ee:	27 e1       	ldi	r18, 0x17	; 23
    61f0:	e2 2e       	mov	r14, r18
    61f2:	25 e0       	ldi	r18, 0x05	; 5
    61f4:	f2 2e       	mov	r15, r18
    61f6:	3a e0       	ldi	r19, 0x0A	; 10
    61f8:	a3 2e       	mov	r10, r19
    61fa:	39 e0       	ldi	r19, 0x09	; 9
    61fc:	b3 2e       	mov	r11, r19
    61fe:	f8 01       	movw	r30, r16
    6200:	3a 97       	sbiw	r30, 0x0a	; 10
	}
#endif

    for (uint8_t i=0; i<MAXSENSORS; i++)
    {  
      if (sensorValues[(i*SENSORSIZE)+FAMILY] != 0)
    6202:	20 81       	ld	r18, Z
    6204:	22 23       	and	r18, r18
    6206:	09 f4       	brne	.+2      	; 0x620a <fill_custom_client_data+0x12c>
    6208:	43 c0       	rjmp	.+134    	; 0x6290 <fill_custom_client_data+0x1b2>
    620a:	39 96       	adiw	r30, 0x09	; 9
      {
        int frac = sensorValues[(i*SENSORSIZE)+VALUE2]*DS18X20_FRACCONV;  //Ganger de sidste par bits, med det step DS18B20 bruger
    620c:	30 81       	ld	r19, Z
    620e:	38 9d       	mul	r19, r8
    6210:	c0 01       	movw	r24, r0
    6212:	39 9d       	mul	r19, r9
    6214:	90 0d       	add	r25, r0
    6216:	11 24       	eor	r1, r1
    
        sprintf_P(tempbuf, PSTR("&%02X%02X%02X%02X%02X%02X%02X%02X=%c%d.%04d"),
    6218:	9f 93       	push	r25
    621a:	8f 93       	push	r24
    621c:	31 97       	sbiw	r30, 0x01	; 1
    621e:	80 81       	ld	r24, Z
    6220:	1f 92       	push	r1
    6222:	8f 93       	push	r24
    6224:	d8 01       	movw	r26, r16
    6226:	8c 91       	ld	r24, X
    6228:	1f 92       	push	r1
    622a:	8f 93       	push	r24
    622c:	31 97       	sbiw	r30, 0x01	; 1
    622e:	80 81       	ld	r24, Z
    6230:	1f 92       	push	r1
    6232:	8f 93       	push	r24
    6234:	31 97       	sbiw	r30, 0x01	; 1
    6236:	80 81       	ld	r24, Z
    6238:	1f 92       	push	r1
    623a:	8f 93       	push	r24
    623c:	31 97       	sbiw	r30, 0x01	; 1
    623e:	80 81       	ld	r24, Z
    6240:	1f 92       	push	r1
    6242:	8f 93       	push	r24
    6244:	31 97       	sbiw	r30, 0x01	; 1
    6246:	80 81       	ld	r24, Z
    6248:	1f 92       	push	r1
    624a:	8f 93       	push	r24
    624c:	31 97       	sbiw	r30, 0x01	; 1
    624e:	80 81       	ld	r24, Z
    6250:	1f 92       	push	r1
    6252:	8f 93       	push	r24
    6254:	31 97       	sbiw	r30, 0x01	; 1
    6256:	80 81       	ld	r24, Z
    6258:	1f 92       	push	r1
    625a:	8f 93       	push	r24
    625c:	31 97       	sbiw	r30, 0x01	; 1
    625e:	80 81       	ld	r24, Z
    6260:	1f 92       	push	r1
    6262:	8f 93       	push	r24
    6264:	1f 92       	push	r1
    6266:	2f 93       	push	r18
    6268:	ff 92       	push	r15
    626a:	ef 92       	push	r14
    626c:	bf 92       	push	r11
    626e:	af 92       	push	r10
    6270:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
              sensorValues[(i*SENSORSIZE)+SIGN],
              sensorValues[(i*SENSORSIZE)+VALUE1],
              frac
            );      

            len = fill_tcp_data(bufptr,len,tempbuf);
    6274:	4a e0       	ldi	r20, 0x0A	; 10
    6276:	59 e0       	ldi	r21, 0x09	; 9
    6278:	6b 81       	ldd	r22, Y+3	; 0x03
    627a:	7c 81       	ldd	r23, Y+4	; 0x04
    627c:	c6 01       	movw	r24, r12
    627e:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    6282:	9c 83       	std	Y+4, r25	; 0x04
    6284:	8b 83       	std	Y+3, r24	; 0x03
    6286:	0f b6       	in	r0, 0x3f	; 63
    6288:	f8 94       	cli
    628a:	de bf       	out	0x3e, r29	; 62
    628c:	0f be       	out	0x3f, r0	; 63
    628e:	cd bf       	out	0x3d, r28	; 61
    6290:	05 5f       	subi	r16, 0xF5	; 245
    6292:	1f 4f       	sbci	r17, 0xFF	; 255
		sprintf_P(tempbuf, PSTR("&R%u=%u"), i, simpleSensorValues[i]);
		len = fill_tcp_data(bufptr,len,tempbuf);
	}
#endif

    for (uint8_t i=0; i<MAXSENSORS; i++)
    6294:	f8 e0       	ldi	r31, 0x08	; 8
    6296:	0e 3a       	cpi	r16, 0xAE	; 174
    6298:	1f 07       	cpc	r17, r31
    629a:	09 f0       	breq	.+2      	; 0x629e <fill_custom_client_data+0x1c0>
    629c:	b0 cf       	rjmp	.-160    	; 0x61fe <fill_custom_client_data+0x120>
    629e:	b4 eb       	ldi	r27, 0xB4	; 180
    62a0:	ab 2e       	mov	r10, r27
    62a2:	b5 e0       	ldi	r27, 0x05	; 5
    62a4:	bb 2e       	mov	r11, r27
    62a6:	0e e6       	ldi	r16, 0x6E	; 110
    62a8:	19 e1       	ldi	r17, 0x19	; 25
    62aa:	e1 2c       	mov	r14, r1
    62ac:	f1 2c       	mov	r15, r1
				temperature = (float)((simpleSensorValues[50+(i*2)] & 0x7FFF) / 10.0) * -1.0;
				} else {
				temperature = (float)(simpleSensorValues[50+(i*2)])/10.0;
			}
			humidity = (float)(simpleSensorValues[50+(i*2)+1])/10.0;
			sprintf_P(tempbuf, PSTR("&D%dT=%g&D%dH=%g"),i,temperature,i,humidity);
    62ae:	8a e0       	ldi	r24, 0x0A	; 10
    62b0:	28 2e       	mov	r2, r24
    62b2:	89 e0       	ldi	r24, 0x09	; 9
    62b4:	38 2e       	mov	r3, r24
	}


	for (uint8_t i=0; i<4; i++)
	{
		if (simpleSensorTypes[i+8] == TYPE_DHT22)
    62b6:	9e 2c       	mov	r9, r14
    62b8:	8f 2c       	mov	r8, r15
    62ba:	ba 82       	std	Y+2, r11	; 0x02
    62bc:	a9 82       	std	Y+1, r10	; 0x01
    62be:	d5 01       	movw	r26, r10
    62c0:	8c 91       	ld	r24, X
    62c2:	84 30       	cpi	r24, 0x04	; 4
    62c4:	09 f0       	breq	.+2      	; 0x62c8 <fill_custom_client_data+0x1ea>
    62c6:	5c c0       	rjmp	.+184    	; 0x6380 <fill_custom_client_data+0x2a2>
		{
			float temperature=0;
			float humidity=0;
			if(simpleSensorValues[50] & 0x8000) {
    62c8:	80 91 6e 19 	lds	r24, 0x196E
    62cc:	90 91 6f 19 	lds	r25, 0x196F
    62d0:	97 ff       	sbrs	r25, 7
    62d2:	16 c0       	rjmp	.+44     	; 0x6300 <fill_custom_client_data+0x222>
				temperature = (float)((simpleSensorValues[50+(i*2)] & 0x7FFF) / 10.0) * -1.0;
    62d4:	f8 01       	movw	r30, r16
    62d6:	80 81       	ld	r24, Z
    62d8:	91 81       	ldd	r25, Z+1	; 0x01
    62da:	9f 77       	andi	r25, 0x7F	; 127
    62dc:	bc 01       	movw	r22, r24
    62de:	80 e0       	ldi	r24, 0x00	; 0
    62e0:	90 e0       	ldi	r25, 0x00	; 0
    62e2:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
    62e6:	20 e0       	ldi	r18, 0x00	; 0
    62e8:	30 e0       	ldi	r19, 0x00	; 0
    62ea:	40 e2       	ldi	r20, 0x20	; 32
    62ec:	51 e4       	ldi	r21, 0x41	; 65
    62ee:	0e 94 ae 3b 	call	0x775c	; 0x775c <__divsf3>
    62f2:	2b 01       	movw	r4, r22
    62f4:	3c 01       	movw	r6, r24
    62f6:	77 fa       	bst	r7, 7
    62f8:	70 94       	com	r7
    62fa:	77 f8       	bld	r7, 7
    62fc:	70 94       	com	r7
    62fe:	10 c0       	rjmp	.+32     	; 0x6320 <fill_custom_client_data+0x242>
				} else {
				temperature = (float)(simpleSensorValues[50+(i*2)])/10.0;
    6300:	d8 01       	movw	r26, r16
    6302:	8d 91       	ld	r24, X+
    6304:	9c 91       	ld	r25, X
    6306:	bc 01       	movw	r22, r24
    6308:	80 e0       	ldi	r24, 0x00	; 0
    630a:	90 e0       	ldi	r25, 0x00	; 0
    630c:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
    6310:	20 e0       	ldi	r18, 0x00	; 0
    6312:	30 e0       	ldi	r19, 0x00	; 0
    6314:	40 e2       	ldi	r20, 0x20	; 32
    6316:	51 e4       	ldi	r21, 0x41	; 65
    6318:	0e 94 ae 3b 	call	0x775c	; 0x775c <__divsf3>
    631c:	2b 01       	movw	r4, r22
    631e:	3c 01       	movw	r6, r24
			}
			humidity = (float)(simpleSensorValues[50+(i*2)+1])/10.0;
    6320:	f8 01       	movw	r30, r16
    6322:	82 81       	ldd	r24, Z+2	; 0x02
    6324:	93 81       	ldd	r25, Z+3	; 0x03
    6326:	bc 01       	movw	r22, r24
    6328:	80 e0       	ldi	r24, 0x00	; 0
    632a:	90 e0       	ldi	r25, 0x00	; 0
    632c:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
    6330:	20 e0       	ldi	r18, 0x00	; 0
    6332:	30 e0       	ldi	r19, 0x00	; 0
    6334:	40 e2       	ldi	r20, 0x20	; 32
    6336:	51 e4       	ldi	r21, 0x41	; 65
    6338:	0e 94 ae 3b 	call	0x775c	; 0x775c <__divsf3>
			sprintf_P(tempbuf, PSTR("&D%dT=%g&D%dH=%g"),i,temperature,i,humidity);
    633c:	9f 93       	push	r25
    633e:	8f 93       	push	r24
    6340:	7f 93       	push	r23
    6342:	6f 93       	push	r22
    6344:	8f 92       	push	r8
    6346:	9f 92       	push	r9
    6348:	7f 92       	push	r7
    634a:	6f 92       	push	r6
    634c:	5f 92       	push	r5
    634e:	4f 92       	push	r4
    6350:	8f 92       	push	r8
    6352:	9f 92       	push	r9
    6354:	a6 e0       	ldi	r26, 0x06	; 6
    6356:	b5 e0       	ldi	r27, 0x05	; 5
    6358:	bf 93       	push	r27
    635a:	af 93       	push	r26
    635c:	3f 92       	push	r3
    635e:	2f 92       	push	r2
    6360:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			len = fill_tcp_data(bufptr,len,tempbuf);
    6364:	4a e0       	ldi	r20, 0x0A	; 10
    6366:	59 e0       	ldi	r21, 0x09	; 9
    6368:	6b 81       	ldd	r22, Y+3	; 0x03
    636a:	7c 81       	ldd	r23, Y+4	; 0x04
    636c:	c6 01       	movw	r24, r12
    636e:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    6372:	9c 83       	std	Y+4, r25	; 0x04
    6374:	8b 83       	std	Y+3, r24	; 0x03
    6376:	0f b6       	in	r0, 0x3f	; 63
    6378:	f8 94       	cli
    637a:	de bf       	out	0x3e, r29	; 62
    637c:	0f be       	out	0x3f, r0	; 63
    637e:	cd bf       	out	0x3d, r28	; 61
    6380:	9f ef       	ldi	r25, 0xFF	; 255
    6382:	a9 1a       	sub	r10, r25
    6384:	b9 0a       	sbc	r11, r25
		}
		if (simpleSensorTypes[i+8] == TYPE_DHT11)
    6386:	a9 81       	ldd	r26, Y+1	; 0x01
    6388:	ba 81       	ldd	r27, Y+2	; 0x02
    638a:	8c 91       	ld	r24, X
    638c:	85 30       	cpi	r24, 0x05	; 5
    638e:	81 f5       	brne	.+96     	; 0x63f0 <fill_custom_client_data+0x312>
		{
			float temperature=simpleSensorValues[50+(i*2)];
			float humidity=simpleSensorValues[50+(i*2)+1];
    6390:	f8 01       	movw	r30, r16
    6392:	62 81       	ldd	r22, Z+2	; 0x02
    6394:	73 81       	ldd	r23, Z+3	; 0x03
    6396:	80 e0       	ldi	r24, 0x00	; 0
    6398:	90 e0       	ldi	r25, 0x00	; 0
    639a:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
			sprintf_P(tempbuf, PSTR("&D%dT=%g&D%dH=%g"),i,temperature,i,humidity);
    639e:	9f 93       	push	r25
    63a0:	8f 93       	push	r24
    63a2:	7f 93       	push	r23
    63a4:	6f 93       	push	r22
    63a6:	8f 92       	push	r8
    63a8:	9f 92       	push	r9
			sprintf_P(tempbuf, PSTR("&D%dT=%g&D%dH=%g"),i,temperature,i,humidity);
			len = fill_tcp_data(bufptr,len,tempbuf);
		}
		if (simpleSensorTypes[i+8] == TYPE_DHT11)
		{
			float temperature=simpleSensorValues[50+(i*2)];
    63aa:	d8 01       	movw	r26, r16
    63ac:	6d 91       	ld	r22, X+
    63ae:	7c 91       	ld	r23, X
    63b0:	80 e0       	ldi	r24, 0x00	; 0
    63b2:	90 e0       	ldi	r25, 0x00	; 0
    63b4:	0e 94 16 3c 	call	0x782c	; 0x782c <__floatunsisf>
			float humidity=simpleSensorValues[50+(i*2)+1];
			sprintf_P(tempbuf, PSTR("&D%dT=%g&D%dH=%g"),i,temperature,i,humidity);
    63b8:	9f 93       	push	r25
    63ba:	8f 93       	push	r24
    63bc:	7f 93       	push	r23
    63be:	6f 93       	push	r22
    63c0:	8f 92       	push	r8
    63c2:	9f 92       	push	r9
    63c4:	a5 ef       	ldi	r26, 0xF5	; 245
    63c6:	b4 e0       	ldi	r27, 0x04	; 4
    63c8:	bf 93       	push	r27
    63ca:	af 93       	push	r26
    63cc:	3f 92       	push	r3
    63ce:	2f 92       	push	r2
    63d0:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
			len = fill_tcp_data(bufptr,len,tempbuf);
    63d4:	4a e0       	ldi	r20, 0x0A	; 10
    63d6:	59 e0       	ldi	r21, 0x09	; 9
    63d8:	6b 81       	ldd	r22, Y+3	; 0x03
    63da:	7c 81       	ldd	r23, Y+4	; 0x04
    63dc:	c6 01       	movw	r24, r12
    63de:	0e 94 51 12 	call	0x24a2	; 0x24a2 <fill_tcp_data>
    63e2:	9c 83       	std	Y+4, r25	; 0x04
    63e4:	8b 83       	std	Y+3, r24	; 0x03
    63e6:	0f b6       	in	r0, 0x3f	; 63
    63e8:	f8 94       	cli
    63ea:	de bf       	out	0x3e, r29	; 62
    63ec:	0f be       	out	0x3f, r0	; 63
    63ee:	cd bf       	out	0x3d, r28	; 61
    63f0:	9f ef       	ldi	r25, 0xFF	; 255
    63f2:	e9 1a       	sub	r14, r25
    63f4:	f9 0a       	sbc	r15, r25
    63f6:	0c 5f       	subi	r16, 0xFC	; 252
    63f8:	1f 4f       	sbci	r17, 0xFF	; 255
            len = fill_tcp_data(bufptr,len,tempbuf);
      }
	}


	for (uint8_t i=0; i<4; i++)
    63fa:	a4 e0       	ldi	r26, 0x04	; 4
    63fc:	ea 16       	cp	r14, r26
    63fe:	f1 04       	cpc	r15, r1
    6400:	09 f0       	breq	.+2      	; 0x6404 <fill_custom_client_data+0x326>
    6402:	59 cf       	rjmp	.-334    	; 0x62b6 <fill_custom_client_data+0x1d8>
		}		
	}
		

	return len;
}
    6404:	8b 81       	ldd	r24, Y+3	; 0x03
    6406:	9c 81       	ldd	r25, Y+4	; 0x04
    6408:	0f 90       	pop	r0
    640a:	0f 90       	pop	r0
    640c:	0f 90       	pop	r0
    640e:	0f 90       	pop	r0
    6410:	df 91       	pop	r29
    6412:	cf 91       	pop	r28
    6414:	1f 91       	pop	r17
    6416:	0f 91       	pop	r16
    6418:	ff 90       	pop	r15
    641a:	ef 90       	pop	r14
    641c:	df 90       	pop	r13
    641e:	cf 90       	pop	r12
    6420:	bf 90       	pop	r11
    6422:	af 90       	pop	r10
    6424:	9f 90       	pop	r9
    6426:	8f 90       	pop	r8
    6428:	7f 90       	pop	r7
    642a:	6f 90       	pop	r6
    642c:	5f 90       	pop	r5
    642e:	4f 90       	pop	r4
    6430:	3f 90       	pop	r3
    6432:	2f 90       	pop	r2
    6434:	08 95       	ret

00006436 <save_checkbox_cgivalue>:
	SENDTCP:
    www_server_reply(buf,dat_p); // send data
}

bool save_checkbox_cgivalue(char* buffer, char* name, uint16_t eeprom_location)
{
    6436:	ef 92       	push	r14
    6438:	ff 92       	push	r15
    643a:	0f 93       	push	r16
    643c:	1f 93       	push	r17
    643e:	cf 93       	push	r28
    6440:	df 93       	push	r29
    6442:	cd b7       	in	r28, 0x3d	; 61
    6444:	de b7       	in	r29, 0x3e	; 62
    6446:	2b 97       	sbiw	r28, 0x0b	; 11
    6448:	0f b6       	in	r0, 0x3f	; 63
    644a:	f8 94       	cli
    644c:	de bf       	out	0x3e, r29	; 62
    644e:	0f be       	out	0x3f, r0	; 63
    6450:	cd bf       	out	0x3d, r28	; 61
    6452:	9b 01       	movw	r18, r22
    6454:	7a 01       	movw	r14, r20
	char cgival[11];
	uint8_t length = 0;
	length = find_key_val(buffer,cgival, 10,name);
    6456:	4a e0       	ldi	r20, 0x0A	; 10
    6458:	be 01       	movw	r22, r28
    645a:	6f 5f       	subi	r22, 0xFF	; 255
    645c:	7f 4f       	sbci	r23, 0xFF	; 255
    645e:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <find_key_val>
	uint8_t value = 0;

	if (length > 0)
    6462:	88 23       	and	r24, r24
    6464:	01 f1       	breq	.+64     	; 0x64a6 <save_checkbox_cgivalue+0x70>
	{
		cgival[length+1] = '\0';
    6466:	fe 01       	movw	r30, r28
    6468:	e8 0f       	add	r30, r24
    646a:	f1 1d       	adc	r31, r1
    646c:	12 82       	std	Z+2, r1	; 0x02
		value = atoi(cgival);
    646e:	ce 01       	movw	r24, r28
    6470:	01 96       	adiw	r24, 0x01	; 1
    6472:	0e 94 a4 3c 	call	0x7948	; 0x7948 <atoi>
    6476:	8c 01       	movw	r16, r24
		eepromWriteByte(eeprom_location, value);
    6478:	68 2f       	mov	r22, r24
    647a:	c7 01       	movw	r24, r14
    647c:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		printf("Write %u at %u \r\n", value, eeprom_location);
    6480:	ff 92       	push	r15
    6482:	ef 92       	push	r14
    6484:	11 27       	eor	r17, r17
    6486:	1f 93       	push	r17
    6488:	0f 93       	push	r16
    648a:	8c e9       	ldi	r24, 0x9C	; 156
    648c:	94 e0       	ldi	r25, 0x04	; 4
    648e:	9f 93       	push	r25
    6490:	8f 93       	push	r24
    6492:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
		return true;
    6496:	0f 90       	pop	r0
    6498:	0f 90       	pop	r0
    649a:	0f 90       	pop	r0
    649c:	0f 90       	pop	r0
    649e:	0f 90       	pop	r0
    64a0:	0f 90       	pop	r0
    64a2:	81 e0       	ldi	r24, 0x01	; 1
    64a4:	11 c0       	rjmp	.+34     	; 0x64c8 <save_checkbox_cgivalue+0x92>
	} else { 
		printf("Write 0 at %u \r\n", eeprom_location);
    64a6:	ff 92       	push	r15
    64a8:	ef 92       	push	r14
    64aa:	2e ea       	ldi	r18, 0xAE	; 174
    64ac:	34 e0       	ldi	r19, 0x04	; 4
    64ae:	3f 93       	push	r19
    64b0:	2f 93       	push	r18
    64b2:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
		eepromWriteByte(eeprom_location, 0);
    64b6:	60 e0       	ldi	r22, 0x00	; 0
    64b8:	c7 01       	movw	r24, r14
    64ba:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
    64be:	0f 90       	pop	r0
    64c0:	0f 90       	pop	r0
    64c2:	0f 90       	pop	r0
    64c4:	0f 90       	pop	r0
    64c6:	80 e0       	ldi	r24, 0x00	; 0
		return false;
	}
}
    64c8:	2b 96       	adiw	r28, 0x0b	; 11
    64ca:	0f b6       	in	r0, 0x3f	; 63
    64cc:	f8 94       	cli
    64ce:	de bf       	out	0x3e, r29	; 62
    64d0:	0f be       	out	0x3f, r0	; 63
    64d2:	cd bf       	out	0x3d, r28	; 61
    64d4:	df 91       	pop	r29
    64d6:	cf 91       	pop	r28
    64d8:	1f 91       	pop	r17
    64da:	0f 91       	pop	r16
    64dc:	ff 90       	pop	r15
    64de:	ef 90       	pop	r14
    64e0:	08 95       	ret

000064e2 <save_cgivalue_if_found>:

bool save_cgivalue_if_found(char* buffer, char* name, uint16_t eeprom_location)
{
    64e2:	0f 93       	push	r16
    64e4:	1f 93       	push	r17
    64e6:	cf 93       	push	r28
    64e8:	df 93       	push	r29
    64ea:	cd b7       	in	r28, 0x3d	; 61
    64ec:	de b7       	in	r29, 0x3e	; 62
    64ee:	2b 97       	sbiw	r28, 0x0b	; 11
    64f0:	0f b6       	in	r0, 0x3f	; 63
    64f2:	f8 94       	cli
    64f4:	de bf       	out	0x3e, r29	; 62
    64f6:	0f be       	out	0x3f, r0	; 63
    64f8:	cd bf       	out	0x3d, r28	; 61
    64fa:	9b 01       	movw	r18, r22
    64fc:	8a 01       	movw	r16, r20
	char cgival[11];
	uint8_t length = 0;
	length = find_key_val(buffer,cgival, 10,name);
    64fe:	4a e0       	ldi	r20, 0x0A	; 10
    6500:	be 01       	movw	r22, r28
    6502:	6f 5f       	subi	r22, 0xFF	; 255
    6504:	7f 4f       	sbci	r23, 0xFF	; 255
    6506:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <find_key_val>
	uint8_t value = 0;

	if (length > 0)
    650a:	88 23       	and	r24, r24
    650c:	71 f0       	breq	.+28     	; 0x652a <save_cgivalue_if_found+0x48>
	{
		cgival[length+1] = '\0';
    650e:	fe 01       	movw	r30, r28
    6510:	e8 0f       	add	r30, r24
    6512:	f1 1d       	adc	r31, r1
    6514:	12 82       	std	Z+2, r1	; 0x02
		value = atoi(cgival);
    6516:	ce 01       	movw	r24, r28
    6518:	01 96       	adiw	r24, 0x01	; 1
    651a:	0e 94 a4 3c 	call	0x7948	; 0x7948 <atoi>
		eepromWriteByte(eeprom_location, value);
    651e:	68 2f       	mov	r22, r24
    6520:	c8 01       	movw	r24, r16
    6522:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		return true;
    6526:	81 e0       	ldi	r24, 0x01	; 1
    6528:	01 c0       	rjmp	.+2      	; 0x652c <save_cgivalue_if_found+0x4a>
	}

	return false;
    652a:	80 e0       	ldi	r24, 0x00	; 0
}
    652c:	2b 96       	adiw	r28, 0x0b	; 11
    652e:	0f b6       	in	r0, 0x3f	; 63
    6530:	f8 94       	cli
    6532:	de bf       	out	0x3e, r29	; 62
    6534:	0f be       	out	0x3f, r0	; 63
    6536:	cd bf       	out	0x3d, r28	; 61
    6538:	df 91       	pop	r29
    653a:	cf 91       	pop	r28
    653c:	1f 91       	pop	r17
    653e:	0f 91       	pop	r16
    6540:	08 95       	ret

00006542 <signed_save_cgivalue_if_found>:

bool signed_save_cgivalue_if_found(char* buffer, char* name, uint16_t eeprom_location)
{
    6542:	0f 93       	push	r16
    6544:	1f 93       	push	r17
    6546:	cf 93       	push	r28
    6548:	df 93       	push	r29
    654a:	cd b7       	in	r28, 0x3d	; 61
    654c:	de b7       	in	r29, 0x3e	; 62
    654e:	2b 97       	sbiw	r28, 0x0b	; 11
    6550:	0f b6       	in	r0, 0x3f	; 63
    6552:	f8 94       	cli
    6554:	de bf       	out	0x3e, r29	; 62
    6556:	0f be       	out	0x3f, r0	; 63
    6558:	cd bf       	out	0x3d, r28	; 61
    655a:	9b 01       	movw	r18, r22
    655c:	8a 01       	movw	r16, r20
	char cgival[11];
	uint8_t length = 0;
	length = find_key_val(buffer,cgival, 10,name);
    655e:	4a e0       	ldi	r20, 0x0A	; 10
    6560:	be 01       	movw	r22, r28
    6562:	6f 5f       	subi	r22, 0xFF	; 255
    6564:	7f 4f       	sbci	r23, 0xFF	; 255
    6566:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <find_key_val>
	int8_t value = 0;

	if (length > 0)
    656a:	88 23       	and	r24, r24
    656c:	71 f0       	breq	.+28     	; 0x658a <signed_save_cgivalue_if_found+0x48>
	{
		cgival[length+1] = '\0';
    656e:	fe 01       	movw	r30, r28
    6570:	e8 0f       	add	r30, r24
    6572:	f1 1d       	adc	r31, r1
    6574:	12 82       	std	Z+2, r1	; 0x02
		value = atoi(cgival);
    6576:	ce 01       	movw	r24, r28
    6578:	01 96       	adiw	r24, 0x01	; 1
    657a:	0e 94 a4 3c 	call	0x7948	; 0x7948 <atoi>
		eepromWriteByte(eeprom_location, value);
    657e:	68 2f       	mov	r22, r24
    6580:	c8 01       	movw	r24, r16
    6582:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
		return true;
    6586:	81 e0       	ldi	r24, 0x01	; 1
    6588:	01 c0       	rjmp	.+2      	; 0x658c <signed_save_cgivalue_if_found+0x4a>
	}

	return false;
    658a:	80 e0       	ldi	r24, 0x00	; 0
}
    658c:	2b 96       	adiw	r28, 0x0b	; 11
    658e:	0f b6       	in	r0, 0x3f	; 63
    6590:	f8 94       	cli
    6592:	de bf       	out	0x3e, r29	; 62
    6594:	0f be       	out	0x3f, r0	; 63
    6596:	cd bf       	out	0x3d, r28	; 61
    6598:	df 91       	pop	r29
    659a:	cf 91       	pop	r28
    659c:	1f 91       	pop	r17
    659e:	0f 91       	pop	r16
    65a0:	08 95       	ret

000065a2 <handle_net>:

	return len;
}

void handle_net(void)
{
    65a2:	2f 92       	push	r2
    65a4:	3f 92       	push	r3
    65a6:	4f 92       	push	r4
    65a8:	5f 92       	push	r5
    65aa:	6f 92       	push	r6
    65ac:	7f 92       	push	r7
    65ae:	8f 92       	push	r8
    65b0:	9f 92       	push	r9
    65b2:	af 92       	push	r10
    65b4:	bf 92       	push	r11
    65b6:	cf 92       	push	r12
    65b8:	df 92       	push	r13
    65ba:	ef 92       	push	r14
    65bc:	ff 92       	push	r15
    65be:	0f 93       	push	r16
    65c0:	1f 93       	push	r17
    65c2:	cf 93       	push	r28
    65c4:	df 93       	push	r29
    65c6:	cd b7       	in	r28, 0x3d	; 61
    65c8:	de b7       	in	r29, 0x3e	; 62
    65ca:	2e 97       	sbiw	r28, 0x0e	; 14
    65cc:	0f b6       	in	r0, 0x3f	; 63
    65ce:	f8 94       	cli
    65d0:	de bf       	out	0x3e, r29	; 62
    65d2:	0f be       	out	0x3f, r0	; 63
    65d4:	cd bf       	out	0x3d, r28	; 61
	uint16_t dat_p,plen;

    // handle ping and wait for a tcp packet
    plen=enc28j60PacketReceive(BUFFER_SIZE, buf);
    65d6:	6b ed       	ldi	r22, 0xDB	; 219
    65d8:	79 e1       	ldi	r23, 0x19	; 25
    65da:	80 e4       	ldi	r24, 0x40	; 64
    65dc:	96 e0       	ldi	r25, 0x06	; 6
    65de:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <enc28j60PacketReceive>
    65e2:	7c 01       	movw	r14, r24
    dat_p=packetloop_icmp_tcp(buf,plen);
    65e4:	bc 01       	movw	r22, r24
    65e6:	8b ed       	ldi	r24, 0xDB	; 219
    65e8:	99 e1       	ldi	r25, 0x19	; 25
    65ea:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <packetloop_icmp_tcp>
    65ee:	8c 01       	movw	r16, r24

    if(plen==0){
    65f0:	e1 14       	cp	r14, r1
    65f2:	f1 04       	cpc	r15, r1
    65f4:	09 f0       	breq	.+2      	; 0x65f8 <handle_net+0x56>
    65f6:	44 c1       	rjmp	.+648    	; 0x6880 <handle_net+0x2de>
            //Hvis der ikke er nogle indgende pakker, kres en tur i web client state machine, hvor dns lookup mv. hndteres
            if (client_waiting_gw() ){
    65f8:	0e 94 93 14 	call	0x2926	; 0x2926 <client_waiting_gw>
    65fc:	81 11       	cpse	r24, r1
    65fe:	2b c4       	rjmp	.+2134   	; 0x6e56 <handle_net+0x8b4>
                return;
            }

            if (dns_state==0){
    6600:	80 91 a3 05 	lds	r24, 0x05A3
    6604:	81 11       	cpse	r24, r1
    6606:	28 c0       	rjmp	.+80     	; 0x6658 <handle_net+0xb6>
					if (web_client_monitor >= 60)
    6608:	80 91 99 05 	lds	r24, 0x0599
    660c:	8c 33       	cpi	r24, 0x3C	; 60
    660e:	48 f0       	brcs	.+18     	; 0x6622 <handle_net+0x80>
					{
						printf("Reset due to missing webclient");
    6610:	8f eb       	ldi	r24, 0xBF	; 191
    6612:	94 e0       	ldi	r25, 0x04	; 4
    6614:	9f 93       	push	r25
    6616:	8f 93       	push	r24
    6618:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    661c:	0f 90       	pop	r0
    661e:	0f 90       	pop	r0
    6620:	ff cf       	rjmp	.-2      	; 0x6620 <handle_net+0x7e>
						while(true);
					}

					web_client_monitor++;
    6622:	8f 5f       	subi	r24, 0xFF	; 255
    6624:	80 93 99 05 	sts	0x0599, r24
					printf_P(PSTR("Request DNS lookup\r\n"));
    6628:	80 ee       	ldi	r24, 0xE0	; 224
    662a:	94 e0       	ldi	r25, 0x04	; 4
    662c:	9f 93       	push	r25
    662e:	8f 93       	push	r24
    6630:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
                    dnsTimer=tickS;
    6634:	80 91 2d 01 	lds	r24, 0x012D
    6638:	90 91 2e 01 	lds	r25, 0x012E
    663c:	90 93 8e 20 	sts	0x208E, r25
    6640:	80 93 8d 20 	sts	0x208D, r24
                    dns_state=1;
    6644:	81 e0       	ldi	r24, 0x01	; 1
    6646:	80 93 a3 05 	sts	0x05A3, r24
                    dnslkup_request(buf,PSTR(WEBSERVER_VHOST));
    664a:	63 ed       	ldi	r22, 0xD3	; 211
    664c:	74 e0       	ldi	r23, 0x04	; 4
    664e:	8b ed       	ldi	r24, 0xDB	; 219
    6650:	99 e1       	ldi	r25, 0x19	; 25
    6652:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <dnslkup_request>
    6656:	47 c0       	rjmp	.+142    	; 0x66e6 <handle_net+0x144>
                    return;
            }

            if (dns_state==1 && dnslkup_haveanswer()){
    6658:	81 30       	cpi	r24, 0x01	; 1
    665a:	81 f5       	brne	.+96     	; 0x66bc <handle_net+0x11a>
    665c:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <dnslkup_haveanswer>
    6660:	88 23       	and	r24, r24
    6662:	61 f1       	breq	.+88     	; 0x66bc <handle_net+0x11a>
					printf_P(PSTR("Got dns reply : %d.%d.%d.%d \r\n"),dnslkup_getip()[0],dnslkup_getip()[1],dnslkup_getip()[2],dnslkup_getip()[3]);
    6664:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <dnslkup_getip>
    6668:	dc 01       	movw	r26, r24
    666a:	13 96       	adiw	r26, 0x03	; 3
    666c:	fc 90       	ld	r15, X
    666e:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <dnslkup_getip>
    6672:	fc 01       	movw	r30, r24
    6674:	02 81       	ldd	r16, Z+2	; 0x02
    6676:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <dnslkup_getip>
    667a:	dc 01       	movw	r26, r24
    667c:	11 96       	adiw	r26, 0x01	; 1
    667e:	1c 91       	ld	r17, X
    6680:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <dnslkup_getip>
    6684:	1f 92       	push	r1
    6686:	ff 92       	push	r15
    6688:	1f 92       	push	r1
    668a:	0f 93       	push	r16
    668c:	1f 92       	push	r1
    668e:	1f 93       	push	r17
    6690:	fc 01       	movw	r30, r24
    6692:	80 81       	ld	r24, Z
    6694:	1f 92       	push	r1
    6696:	8f 93       	push	r24
    6698:	84 eb       	ldi	r24, 0xB4	; 180
    669a:	94 e0       	ldi	r25, 0x04	; 4
    669c:	9f 93       	push	r25
    669e:	8f 93       	push	r24
    66a0:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
                    dns_state=2;
    66a4:	82 e0       	ldi	r24, 0x02	; 2
    66a6:	80 93 a3 05 	sts	0x05A3, r24
			        client_set_wwwip(dnslkup_getip());
    66aa:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <dnslkup_getip>
    66ae:	0e 94 c3 14 	call	0x2986	; 0x2986 <client_tcp_set_serverip>
    66b2:	0f b6       	in	r0, 0x3f	; 63
    66b4:	f8 94       	cli
    66b6:	de bf       	out	0x3e, r29	; 62
    66b8:	0f be       	out	0x3f, r0	; 63
    66ba:	cd bf       	out	0x3d, r28	; 61
            }

            if (dns_state!=2){
    66bc:	10 91 a3 05 	lds	r17, 0x05A3
    66c0:	12 30       	cpi	r17, 0x02	; 2
    66c2:	a1 f0       	breq	.+40     	; 0x66ec <handle_net+0x14a>
                    // retry every minute if dns-lookup failed:
                    if (tickDiffS(dnsTimer) > 20){
    66c4:	80 91 8d 20 	lds	r24, 0x208D
    66c8:	90 91 8e 20 	lds	r25, 0x208E
    66cc:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    66d0:	45 97       	sbiw	r24, 0x15	; 21
    66d2:	08 f4       	brcc	.+2      	; 0x66d6 <handle_net+0x134>
    66d4:	c0 c3       	rjmp	.+1920   	; 0x6e56 <handle_net+0x8b4>
						printf_P(PSTR("Retry dns lookup ... \r\n"));
    66d6:	8c e9       	ldi	r24, 0x9C	; 156
    66d8:	94 e0       	ldi	r25, 0x04	; 4
    66da:	9f 93       	push	r25
    66dc:	8f 93       	push	r24
    66de:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
                            dns_state=0;
    66e2:	10 92 a3 05 	sts	0x05A3, r1
    66e6:	0f 90       	pop	r0
    66e8:	0f 90       	pop	r0
    66ea:	b5 c3       	rjmp	.+1898   	; 0x6e56 <handle_net+0x8b4>
                    // we have a result of dns-lookup
                    return;
            }

            //----------
            if (start_web_client==1){
    66ec:	80 91 a2 05 	lds	r24, 0x05A2
    66f0:	81 30       	cpi	r24, 0x01	; 1
    66f2:	09 f0       	breq	.+2      	; 0x66f6 <handle_net+0x154>
    66f4:	68 c0       	rjmp	.+208    	; 0x67c6 <handle_net+0x224>
				printf_P(PSTR("Starting webclient request \r\n"));
    66f6:	8e e7       	ldi	r24, 0x7E	; 126
    66f8:	94 e0       	ldi	r25, 0x04	; 4
    66fa:	9f 93       	push	r25
    66fc:	8f 93       	push	r24
    66fe:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
                    dnsTimer=tickS;
    6702:	80 91 2d 01 	lds	r24, 0x012D
    6706:	90 91 2e 01 	lds	r25, 0x012E
    670a:	90 93 8e 20 	sts	0x208E, r25
    670e:	80 93 8d 20 	sts	0x208D, r24
                    start_web_client=2;
    6712:	10 93 a2 05 	sts	0x05A2, r17
                    web_client_attempts++;
    6716:	80 91 9e 05 	lds	r24, 0x059E
    671a:	90 91 9f 05 	lds	r25, 0x059F
    671e:	a0 91 a0 05 	lds	r26, 0x05A0
    6722:	b0 91 a1 05 	lds	r27, 0x05A1
    6726:	01 96       	adiw	r24, 0x01	; 1
    6728:	a1 1d       	adc	r26, r1
    672a:	b1 1d       	adc	r27, r1
    672c:	80 93 9e 05 	sts	0x059E, r24
    6730:	90 93 9f 05 	sts	0x059F, r25
    6734:	a0 93 a0 05 	sts	0x05A0, r26
    6738:	b0 93 a1 05 	sts	0x05A1, r27
					web_client_monitor++;
    673c:	80 91 99 05 	lds	r24, 0x0599
    6740:	8f 5f       	subi	r24, 0xFF	; 255
    6742:	80 93 99 05 	sts	0x0599, r24
					if (web_client_monitor >= 5)
    6746:	0f 90       	pop	r0
    6748:	0f 90       	pop	r0
    674a:	85 30       	cpi	r24, 0x05	; 5
    674c:	48 f0       	brcs	.+18     	; 0x6760 <handle_net+0x1be>
					{
						printf("Reset due to missing webclient");
    674e:	8f eb       	ldi	r24, 0xBF	; 191
    6750:	94 e0       	ldi	r25, 0x04	; 4
    6752:	9f 93       	push	r25
    6754:	8f 93       	push	r24
    6756:	0e 94 89 3e 	call	0x7d12	; 0x7d12 <printf>
    675a:	0f 90       	pop	r0
    675c:	0f 90       	pop	r0
    675e:	ff cf       	rjmp	.-2      	; 0x675e <handle_net+0x1bc>
						while(true);
					}
					

	char *ptr = (char*)tempbuf;
	sprintf_P(ptr, PSTR("&id=%02X%02X%02X%02X%02X%02X%02X%02X"), systemID[0], systemID[1], systemID[2], systemID[3], systemID[4], systemID[5], systemID[6], systemID[7]);
    6760:	80 91 da 19 	lds	r24, 0x19DA
    6764:	1f 92       	push	r1
    6766:	8f 93       	push	r24
    6768:	80 91 d9 19 	lds	r24, 0x19D9
    676c:	1f 92       	push	r1
    676e:	8f 93       	push	r24
    6770:	80 91 d8 19 	lds	r24, 0x19D8
    6774:	1f 92       	push	r1
    6776:	8f 93       	push	r24
    6778:	80 91 d7 19 	lds	r24, 0x19D7
    677c:	1f 92       	push	r1
    677e:	8f 93       	push	r24
    6780:	80 91 d6 19 	lds	r24, 0x19D6
    6784:	1f 92       	push	r1
    6786:	8f 93       	push	r24
    6788:	80 91 d5 19 	lds	r24, 0x19D5
    678c:	1f 92       	push	r1
    678e:	8f 93       	push	r24
    6790:	80 91 d4 19 	lds	r24, 0x19D4
    6794:	1f 92       	push	r1
    6796:	8f 93       	push	r24
    6798:	80 91 d3 19 	lds	r24, 0x19D3
    679c:	1f 92       	push	r1
    679e:	8f 93       	push	r24
    67a0:	89 e5       	ldi	r24, 0x59	; 89
    67a2:	94 e0       	ldi	r25, 0x04	; 4
    67a4:	9f 93       	push	r25
    67a6:	8f 93       	push	r24
    67a8:	8a e0       	ldi	r24, 0x0A	; 10
    67aa:	99 e0       	ldi	r25, 0x09	; 9
    67ac:	9f 93       	push	r25
    67ae:	8f 93       	push	r24
    67b0:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
	ptr += strlen(ptr);

    client_browse_url((char*)PSTR("/incoming.php?v=1"),(char*)tempbuf,(char*)PSTR(WEBSERVER_VHOST),&browserresult_callback);
    67b4:	26 ef       	ldi	r18, 0xF6	; 246
    67b6:	37 e2       	ldi	r19, 0x27	; 39
    67b8:	4c e4       	ldi	r20, 0x4C	; 76
    67ba:	54 e0       	ldi	r21, 0x04	; 4
    67bc:	6a e0       	ldi	r22, 0x0A	; 10
    67be:	79 e0       	ldi	r23, 0x09	; 9
    67c0:	8a e3       	ldi	r24, 0x3A	; 58
    67c2:	94 e0       	ldi	r25, 0x04	; 4
    67c4:	45 c0       	rjmp	.+138    	; 0x6850 <handle_net+0x2ae>
	
	} else if (start_web_client == 10)
    67c6:	8a 30       	cpi	r24, 0x0A	; 10
    67c8:	09 f0       	breq	.+2      	; 0x67cc <handle_net+0x22a>
    67ca:	49 c0       	rjmp	.+146    	; 0x685e <handle_net+0x2bc>
	{
		dnsTimer=tickS;
    67cc:	80 91 2d 01 	lds	r24, 0x012D
    67d0:	90 91 2e 01 	lds	r25, 0x012E
    67d4:	90 93 8e 20 	sts	0x208E, r25
    67d8:	80 93 8d 20 	sts	0x208D, r24
        start_web_client=2;
    67dc:	10 93 a2 05 	sts	0x05A2, r17

		printf_P(PSTR("Starting lcd request \r\n"));
    67e0:	82 e2       	ldi	r24, 0x22	; 34
    67e2:	94 e0       	ldi	r25, 0x04	; 4
    67e4:	9f 93       	push	r25
    67e6:	8f 93       	push	r24
    67e8:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <printf_P>
		char *ptr = (char*)tempbuf;
		sprintf_P(ptr, PSTR("?id=%02X%02X%02X%02X%02X%02X%02X%02X"), systemID[0], systemID[1], systemID[2], systemID[3], systemID[4], systemID[5], systemID[6], systemID[7]);
    67ec:	80 91 da 19 	lds	r24, 0x19DA
    67f0:	1f 92       	push	r1
    67f2:	8f 93       	push	r24
    67f4:	80 91 d9 19 	lds	r24, 0x19D9
    67f8:	1f 92       	push	r1
    67fa:	8f 93       	push	r24
    67fc:	80 91 d8 19 	lds	r24, 0x19D8
    6800:	1f 92       	push	r1
    6802:	8f 93       	push	r24
    6804:	80 91 d7 19 	lds	r24, 0x19D7
    6808:	1f 92       	push	r1
    680a:	8f 93       	push	r24
    680c:	80 91 d6 19 	lds	r24, 0x19D6
    6810:	1f 92       	push	r1
    6812:	8f 93       	push	r24
    6814:	80 91 d5 19 	lds	r24, 0x19D5
    6818:	1f 92       	push	r1
    681a:	8f 93       	push	r24
    681c:	80 91 d4 19 	lds	r24, 0x19D4
    6820:	1f 92       	push	r1
    6822:	8f 93       	push	r24
    6824:	80 91 d3 19 	lds	r24, 0x19D3
    6828:	1f 92       	push	r1
    682a:	8f 93       	push	r24
    682c:	8d ef       	ldi	r24, 0xFD	; 253
    682e:	93 e0       	ldi	r25, 0x03	; 3
    6830:	9f 93       	push	r25
    6832:	8f 93       	push	r24
    6834:	8a e0       	ldi	r24, 0x0A	; 10
    6836:	99 e0       	ldi	r25, 0x09	; 9
    6838:	9f 93       	push	r25
    683a:	8f 93       	push	r24
    683c:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
		ptr += strlen(ptr);
		client_browse_url((char*)PSTR("/getLCD.php"), tempbuf,(char*)PSTR(WEBSERVER_VHOST),&lcd_callback);	
    6840:	21 ef       	ldi	r18, 0xF1	; 241
    6842:	34 e2       	ldi	r19, 0x24	; 36
    6844:	40 ef       	ldi	r20, 0xF0	; 240
    6846:	53 e0       	ldi	r21, 0x03	; 3
    6848:	6a e0       	ldi	r22, 0x0A	; 10
    684a:	79 e0       	ldi	r23, 0x09	; 9
    684c:	84 ee       	ldi	r24, 0xE4	; 228
    684e:	93 e0       	ldi	r25, 0x03	; 3
    6850:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <client_browse_url>
    6854:	0f b6       	in	r0, 0x3f	; 63
    6856:	f8 94       	cli
    6858:	de bf       	out	0x3e, r29	; 62
    685a:	0f be       	out	0x3f, r0	; 63
    685c:	cd bf       	out	0x3d, r28	; 61
	}

    	// reset after a delay to prevent permanent bouncing
        if (tickDiffS(dnsTimer)>10 && start_web_client==2){
    685e:	80 91 8d 20 	lds	r24, 0x208D
    6862:	90 91 8e 20 	lds	r25, 0x208E
    6866:	0e 94 72 24 	call	0x48e4	; 0x48e4 <tickDiffS>
    686a:	0b 97       	sbiw	r24, 0x0b	; 11
    686c:	08 f4       	brcc	.+2      	; 0x6870 <handle_net+0x2ce>
    686e:	f3 c2       	rjmp	.+1510   	; 0x6e56 <handle_net+0x8b4>
    6870:	80 91 a2 05 	lds	r24, 0x05A2
    6874:	82 30       	cpi	r24, 0x02	; 2
    6876:	09 f0       	breq	.+2      	; 0x687a <handle_net+0x2d8>
    6878:	ee c2       	rjmp	.+1500   	; 0x6e56 <handle_net+0x8b4>
        	start_web_client=0;
    687a:	10 92 a2 05 	sts	0x05A2, r1
    687e:	eb c2       	rjmp	.+1494   	; 0x6e56 <handle_net+0x8b4>
        }
        return;
    }
    if(dat_p==0){ // plen!=0
    6880:	00 97       	sbiw	r24, 0x00	; 0
    6882:	31 f4       	brne	.+12     	; 0x6890 <handle_net+0x2ee>
            // check for incomming messages not processed
            // as part of packetloop_icmp_tcp, e.g udp messages
            udp_client_check_for_dns_answer(buf,plen);
    6884:	b7 01       	movw	r22, r14
    6886:	8b ed       	ldi	r24, 0xDB	; 219
    6888:	99 e1       	ldi	r25, 0x19	; 25
    688a:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <udp_client_check_for_dns_answer>
            return;
    688e:	e3 c2       	rjmp	.+1478   	; 0x6e56 <handle_net+0x8b4>
    }
            
    if (strncmp("GET ",(char *)&(buf[dat_p]),4)!=0){
    6890:	44 e0       	ldi	r20, 0x04	; 4
    6892:	50 e0       	ldi	r21, 0x00	; 0
    6894:	bc 01       	movw	r22, r24
    6896:	65 52       	subi	r22, 0x25	; 37
    6898:	76 4e       	sbci	r23, 0xE6	; 230
    689a:	8e ed       	ldi	r24, 0xDE	; 222
    689c:	94 e0       	ldi	r25, 0x04	; 4
    689e:	0e 94 e8 3d 	call	0x7bd0	; 0x7bd0 <strncmp>
    68a2:	89 2b       	or	r24, r25
    68a4:	21 f0       	breq	.+8      	; 0x68ae <handle_net+0x30c>
            dat_p=fill_tcp_data_p(buf,dat_p,PSTR("<h1>200 OK</h1>"));
    68a6:	44 ed       	ldi	r20, 0xD4	; 212
    68a8:	53 e0       	ldi	r21, 0x03	; 3
    68aa:	b8 01       	movw	r22, r16
    68ac:	cb c2       	rjmp	.+1430   	; 0x6e44 <handle_net+0x8a2>
            goto SENDTCP;
    }

    if (strncmp("/ ",(char *)&(buf[dat_p+4]),2)==0){	
    68ae:	01 52       	subi	r16, 0x21	; 33
    68b0:	16 4e       	sbci	r17, 0xE6	; 230
    68b2:	42 e0       	ldi	r20, 0x02	; 2
    68b4:	50 e0       	ldi	r21, 0x00	; 0
    68b6:	b8 01       	movw	r22, r16
    68b8:	83 ee       	ldi	r24, 0xE3	; 227
    68ba:	94 e0       	ldi	r25, 0x04	; 4
    68bc:	0e 94 e8 3d 	call	0x7bd0	; 0x7bd0 <strncmp>
    68c0:	89 2b       	or	r24, r25
    68c2:	29 f4       	brne	.+10     	; 0x68ce <handle_net+0x32c>
            dat_p=print_webpage(buf);		
    68c4:	8b ed       	ldi	r24, 0xDB	; 219
    68c6:	99 e1       	ldi	r25, 0x19	; 25
    68c8:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <print_webpage>

            goto SENDTCP;
    68cc:	bf c2       	rjmp	.+1406   	; 0x6e4c <handle_net+0x8aa>
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/general"),17)==0){	
    68ce:	41 e1       	ldi	r20, 0x11	; 17
    68d0:	50 e0       	ldi	r21, 0x00	; 0
    68d2:	62 ec       	ldi	r22, 0xC2	; 194
    68d4:	73 e0       	ldi	r23, 0x03	; 3
    68d6:	c8 01       	movw	r24, r16
    68d8:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    68dc:	89 2b       	or	r24, r25
    68de:	39 f5       	brne	.+78     	; 0x692e <handle_net+0x38c>
			if (!user_is_auth((char *)&(buf[dat_p+4])))
    68e0:	c8 01       	movw	r24, r16
    68e2:	0e 94 0e 30 	call	0x601c	; 0x601c <user_is_auth>
    68e6:	88 23       	and	r24, r24
    68e8:	09 f4       	brne	.+2      	; 0x68ec <handle_net+0x34a>
    68ea:	5c c1       	rjmp	.+696    	; 0x6ba4 <handle_net+0x602>
          		goto SENDTCP;
			}

			char cgival[11];
			uint8_t length = 0;
			length = find_key_val((char *)&(buf[dat_p+4]),cgival, 10,"PASS");
    68ec:	26 ee       	ldi	r18, 0xE6	; 230
    68ee:	34 e0       	ldi	r19, 0x04	; 4
    68f0:	4a e0       	ldi	r20, 0x0A	; 10
    68f2:	be 01       	movw	r22, r28
    68f4:	6f 5f       	subi	r22, 0xFF	; 255
    68f6:	7f 4f       	sbci	r23, 0xFF	; 255
    68f8:	c8 01       	movw	r24, r16
    68fa:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <find_key_val>
			//Changed from a loop here i beta2, revert if it fails -JKN
			if (length > 0 && length <= 10)
    68fe:	9f ef       	ldi	r25, 0xFF	; 255
    6900:	98 0f       	add	r25, r24
    6902:	9a 30       	cpi	r25, 0x0A	; 10
    6904:	78 f4       	brcc	.+30     	; 0x6924 <handle_net+0x382>
			{
				eepromSaveStr(200, cgival, length);
    6906:	48 2f       	mov	r20, r24
    6908:	be 01       	movw	r22, r28
    690a:	6f 5f       	subi	r22, 0xFF	; 255
    690c:	7f 4f       	sbci	r23, 0xFF	; 255
    690e:	88 ec       	ldi	r24, 0xC8	; 200
    6910:	90 e0       	ldi	r25, 0x00	; 0
    6912:	0e 94 5f 21 	call	0x42be	; 0x42be <eepromSaveStr>
				save_checkbox_cgivalue((char*)&(buf[dat_p+4]), "LCD", 50);
    6916:	42 e3       	ldi	r20, 0x32	; 50
    6918:	50 e0       	ldi	r21, 0x00	; 0
    691a:	6b ee       	ldi	r22, 0xEB	; 235
    691c:	74 e0       	ldi	r23, 0x04	; 4
    691e:	c8 01       	movw	r24, r16
    6920:	0e 94 1b 32 	call	0x6436	; 0x6436 <save_checkbox_cgivalue>
			}

            dat_p=print_settings_general_webpage(buf);
    6924:	8b ed       	ldi	r24, 0xDB	; 219
    6926:	99 e1       	ldi	r25, 0x19	; 25
    6928:	0e 94 17 2e 	call	0x5c2e	; 0x5c2e <print_settings_general_webpage>

          	goto SENDTCP;
    692c:	8f c2       	rjmp	.+1310   	; 0x6e4c <handle_net+0x8aa>
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/io"),12)==0){			
    692e:	4c e0       	ldi	r20, 0x0C	; 12
    6930:	50 e0       	ldi	r21, 0x00	; 0
    6932:	65 eb       	ldi	r22, 0xB5	; 181
    6934:	73 e0       	ldi	r23, 0x03	; 3
    6936:	c8 01       	movw	r24, r16
    6938:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    693c:	89 2b       	or	r24, r25
    693e:	09 f0       	breq	.+2      	; 0x6942 <handle_net+0x3a0>
    6940:	8b c0       	rjmp	.+278    	; 0x6a58 <handle_net+0x4b6>
			if (!user_is_auth((char *)&(buf[dat_p+4])))
    6942:	c8 01       	movw	r24, r16
    6944:	0e 94 0e 30 	call	0x601c	; 0x601c <user_is_auth>
    6948:	88 23       	and	r24, r24
    694a:	09 f4       	brne	.+2      	; 0x694e <handle_net+0x3ac>
    694c:	2b c1       	rjmp	.+598    	; 0x6ba4 <handle_net+0x602>
			{
				dat_p=https401();
          		goto SENDTCP;
			}
			char cgival[3];
			if (find_key_val((char *)&(buf[dat_p+4]),cgival, 3,"io") > 0)
    694e:	2f ee       	ldi	r18, 0xEF	; 239
    6950:	34 e0       	ldi	r19, 0x04	; 4
    6952:	43 e0       	ldi	r20, 0x03	; 3
    6954:	be 01       	movw	r22, r28
    6956:	6f 5f       	subi	r22, 0xFF	; 255
    6958:	7f 4f       	sbci	r23, 0xFF	; 255
    695a:	c8 01       	movw	r24, r16
    695c:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <find_key_val>
    6960:	81 11       	cpse	r24, r1
    6962:	05 c0       	rjmp	.+10     	; 0x696e <handle_net+0x3cc>
				{
					simpleSensorTypes[i+8] = eepromReadByte(110+i);
				}
			}

            dat_p=print_settings_io_webpage(buf);
    6964:	8b ed       	ldi	r24, 0xDB	; 219
    6966:	99 e1       	ldi	r25, 0x19	; 25
    6968:	0e 94 37 2f 	call	0x5e6e	; 0x5e6e <print_settings_io_webpage>

          	goto SENDTCP;
    696c:	6f c2       	rjmp	.+1246   	; 0x6e4c <handle_net+0x8aa>
          		goto SENDTCP;
			}
			char cgival[3];
			if (find_key_val((char *)&(buf[dat_p+4]),cgival, 3,"io") > 0)
			{
				printf("IO SAVE\r\n");
    696e:	82 ef       	ldi	r24, 0xF2	; 242
    6970:	94 e0       	ldi	r25, 0x04	; 4
    6972:	0e 94 bf 3e 	call	0x7d7e	; 0x7d7e <puts>
    6976:	e1 2c       	mov	r14, r1
    6978:	f1 2c       	mov	r15, r1
				for (uint8_t i=0; i<8; i++)
				{
					sprintf_P(tempbuf, PSTR("ADC%u"), i);
    697a:	7f ea       	ldi	r23, 0xAF	; 175
    697c:	a7 2e       	mov	r10, r23
    697e:	73 e0       	ldi	r23, 0x03	; 3
    6980:	b7 2e       	mov	r11, r23
    6982:	ea e0       	ldi	r30, 0x0A	; 10
    6984:	ce 2e       	mov	r12, r30
    6986:	e9 e0       	ldi	r30, 0x09	; 9
    6988:	de 2e       	mov	r13, r30
    698a:	ff 92       	push	r15
    698c:	ef 92       	push	r14
    698e:	bf 92       	push	r11
    6990:	af 92       	push	r10
    6992:	df 92       	push	r13
    6994:	cf 92       	push	r12
    6996:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
    699a:	a7 01       	movw	r20, r14
    699c:	4c 59       	subi	r20, 0x9C	; 156
    699e:	5f 4f       	sbci	r21, 0xFF	; 255
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 100+i);
    69a0:	6a e0       	ldi	r22, 0x0A	; 10
    69a2:	79 e0       	ldi	r23, 0x09	; 9
    69a4:	c8 01       	movw	r24, r16
    69a6:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    69aa:	ff ef       	ldi	r31, 0xFF	; 255
    69ac:	ef 1a       	sub	r14, r31
    69ae:	ff 0a       	sbc	r15, r31
			}
			char cgival[3];
			if (find_key_val((char *)&(buf[dat_p+4]),cgival, 3,"io") > 0)
			{
				printf("IO SAVE\r\n");
				for (uint8_t i=0; i<8; i++)
    69b0:	0f 90       	pop	r0
    69b2:	0f 90       	pop	r0
    69b4:	0f 90       	pop	r0
    69b6:	0f 90       	pop	r0
    69b8:	0f 90       	pop	r0
    69ba:	0f 90       	pop	r0
    69bc:	88 e0       	ldi	r24, 0x08	; 8
    69be:	e8 16       	cp	r14, r24
    69c0:	f1 04       	cpc	r15, r1
    69c2:	19 f7       	brne	.-58     	; 0x698a <handle_net+0x3e8>
    69c4:	e1 2c       	mov	r14, r1
    69c6:	f1 2c       	mov	r15, r1
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 100+i);
				}

				for (uint8_t i=0; i<4; i++)
				{
					sprintf_P(tempbuf, PSTR("D%u"), i);
    69c8:	5b ea       	ldi	r21, 0xAB	; 171
    69ca:	a5 2e       	mov	r10, r21
    69cc:	53 e0       	ldi	r21, 0x03	; 3
    69ce:	b5 2e       	mov	r11, r21
    69d0:	6a e0       	ldi	r22, 0x0A	; 10
    69d2:	c6 2e       	mov	r12, r22
    69d4:	69 e0       	ldi	r22, 0x09	; 9
    69d6:	d6 2e       	mov	r13, r22
    69d8:	ff 92       	push	r15
    69da:	ef 92       	push	r14
    69dc:	bf 92       	push	r11
    69de:	af 92       	push	r10
    69e0:	df 92       	push	r13
    69e2:	cf 92       	push	r12
    69e4:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
    69e8:	a7 01       	movw	r20, r14
    69ea:	42 59       	subi	r20, 0x92	; 146
    69ec:	5f 4f       	sbci	r21, 0xFF	; 255
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 110+i);
    69ee:	6a e0       	ldi	r22, 0x0A	; 10
    69f0:	79 e0       	ldi	r23, 0x09	; 9
    69f2:	c8 01       	movw	r24, r16
    69f4:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    69f8:	9f ef       	ldi	r25, 0xFF	; 255
    69fa:	e9 1a       	sub	r14, r25
    69fc:	f9 0a       	sbc	r15, r25
				{
					sprintf_P(tempbuf, PSTR("ADC%u"), i);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 100+i);
				}

				for (uint8_t i=0; i<4; i++)
    69fe:	0f 90       	pop	r0
    6a00:	0f 90       	pop	r0
    6a02:	0f 90       	pop	r0
    6a04:	0f 90       	pop	r0
    6a06:	0f 90       	pop	r0
    6a08:	0f 90       	pop	r0
    6a0a:	a4 e0       	ldi	r26, 0x04	; 4
    6a0c:	ea 16       	cp	r14, r26
    6a0e:	f1 04       	cpc	r15, r1
    6a10:	19 f7       	brne	.-58     	; 0x69d8 <handle_net+0x436>
    6a12:	4c ea       	ldi	r20, 0xAC	; 172
    6a14:	e4 2e       	mov	r14, r20
    6a16:	45 e0       	ldi	r20, 0x05	; 5
    6a18:	f4 2e       	mov	r15, r20
    6a1a:	04 e6       	ldi	r16, 0x64	; 100
    6a1c:	10 e0       	ldi	r17, 0x00	; 0
				}

				//Reload from eeprom
				for (int i=0; i<=7; i++)
				{
					simpleSensorTypes[i] = eepromReadByte(100+i);
    6a1e:	c8 01       	movw	r24, r16
    6a20:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    6a24:	f7 01       	movw	r30, r14
    6a26:	81 93       	st	Z+, r24
    6a28:	7f 01       	movw	r14, r30
    6a2a:	0f 5f       	subi	r16, 0xFF	; 255
    6a2c:	1f 4f       	sbci	r17, 0xFF	; 255
					sprintf_P(tempbuf, PSTR("D%u"), i);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 110+i);
				}

				//Reload from eeprom
				for (int i=0; i<=7; i++)
    6a2e:	0c 36       	cpi	r16, 0x6C	; 108
    6a30:	11 05       	cpc	r17, r1
    6a32:	a9 f7       	brne	.-22     	; 0x6a1e <handle_net+0x47c>
    6a34:	34 eb       	ldi	r19, 0xB4	; 180
    6a36:	e3 2e       	mov	r14, r19
    6a38:	35 e0       	ldi	r19, 0x05	; 5
    6a3a:	f3 2e       	mov	r15, r19
    6a3c:	0e e6       	ldi	r16, 0x6E	; 110
    6a3e:	10 e0       	ldi	r17, 0x00	; 0
					simpleSensorTypes[i] = eepromReadByte(100+i);
				}

				for (int i=0; i<=3; i++)
				{
					simpleSensorTypes[i+8] = eepromReadByte(110+i);
    6a40:	c8 01       	movw	r24, r16
    6a42:	0e 94 5b 21 	call	0x42b6	; 0x42b6 <eepromReadByte>
    6a46:	d7 01       	movw	r26, r14
    6a48:	8d 93       	st	X+, r24
    6a4a:	7d 01       	movw	r14, r26
    6a4c:	0f 5f       	subi	r16, 0xFF	; 255
    6a4e:	1f 4f       	sbci	r17, 0xFF	; 255
				for (int i=0; i<=7; i++)
				{
					simpleSensorTypes[i] = eepromReadByte(100+i);
				}

				for (int i=0; i<=3; i++)
    6a50:	02 37       	cpi	r16, 0x72	; 114
    6a52:	11 05       	cpc	r17, r1
    6a54:	a9 f7       	brne	.-22     	; 0x6a40 <handle_net+0x49e>
    6a56:	86 cf       	rjmp	.-244    	; 0x6964 <handle_net+0x3c2>
			}

            dat_p=print_settings_io_webpage(buf);

          	goto SENDTCP;
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/net"),13)==0){	
    6a58:	4d e0       	ldi	r20, 0x0D	; 13
    6a5a:	50 e0       	ldi	r21, 0x00	; 0
    6a5c:	6d e9       	ldi	r22, 0x9D	; 157
    6a5e:	73 e0       	ldi	r23, 0x03	; 3
    6a60:	c8 01       	movw	r24, r16
    6a62:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6a66:	89 2b       	or	r24, r25
    6a68:	09 f0       	breq	.+2      	; 0x6a6c <handle_net+0x4ca>
    6a6a:	8d c0       	rjmp	.+282    	; 0x6b86 <handle_net+0x5e4>
			if (!user_is_auth((char *)&(buf[dat_p+4])))
    6a6c:	c8 01       	movw	r24, r16
    6a6e:	0e 94 0e 30 	call	0x601c	; 0x601c <user_is_auth>
    6a72:	88 23       	and	r24, r24
    6a74:	09 f4       	brne	.+2      	; 0x6a78 <handle_net+0x4d6>
    6a76:	96 c0       	rjmp	.+300    	; 0x6ba4 <handle_net+0x602>
          		goto SENDTCP;
			}

			uint8_t changed = 0;

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP0", 11);
    6a78:	4b e0       	ldi	r20, 0x0B	; 11
    6a7a:	50 e0       	ldi	r21, 0x00	; 0
    6a7c:	6b ef       	ldi	r22, 0xFB	; 251
    6a7e:	74 e0       	ldi	r23, 0x04	; 4
    6a80:	c8 01       	movw	r24, r16
    6a82:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6a86:	f8 2e       	mov	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP1", 12);
    6a88:	4c e0       	ldi	r20, 0x0C	; 12
    6a8a:	50 e0       	ldi	r21, 0x00	; 0
    6a8c:	6f ef       	ldi	r22, 0xFF	; 255
    6a8e:	74 e0       	ldi	r23, 0x04	; 4
    6a90:	c8 01       	movw	r24, r16
    6a92:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6a96:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP2", 13);
    6a98:	4d e0       	ldi	r20, 0x0D	; 13
    6a9a:	50 e0       	ldi	r21, 0x00	; 0
    6a9c:	63 e0       	ldi	r22, 0x03	; 3
    6a9e:	75 e0       	ldi	r23, 0x05	; 5
    6aa0:	c8 01       	movw	r24, r16
    6aa2:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6aa6:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "IP3", 14);
    6aa8:	4e e0       	ldi	r20, 0x0E	; 14
    6aaa:	50 e0       	ldi	r21, 0x00	; 0
    6aac:	67 e0       	ldi	r22, 0x07	; 7
    6aae:	75 e0       	ldi	r23, 0x05	; 5
    6ab0:	c8 01       	movw	r24, r16
    6ab2:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6ab6:	f8 0e       	add	r15, r24

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW0", 15);
    6ab8:	4f e0       	ldi	r20, 0x0F	; 15
    6aba:	50 e0       	ldi	r21, 0x00	; 0
    6abc:	6b e0       	ldi	r22, 0x0B	; 11
    6abe:	75 e0       	ldi	r23, 0x05	; 5
    6ac0:	c8 01       	movw	r24, r16
    6ac2:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6ac6:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW1", 16);
    6ac8:	40 e1       	ldi	r20, 0x10	; 16
    6aca:	50 e0       	ldi	r21, 0x00	; 0
    6acc:	6f e0       	ldi	r22, 0x0F	; 15
    6ace:	75 e0       	ldi	r23, 0x05	; 5
    6ad0:	c8 01       	movw	r24, r16
    6ad2:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6ad6:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW2", 17);
    6ad8:	41 e1       	ldi	r20, 0x11	; 17
    6ada:	50 e0       	ldi	r21, 0x00	; 0
    6adc:	63 e1       	ldi	r22, 0x13	; 19
    6ade:	75 e0       	ldi	r23, 0x05	; 5
    6ae0:	c8 01       	movw	r24, r16
    6ae2:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6ae6:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "GW3", 18);
    6ae8:	42 e1       	ldi	r20, 0x12	; 18
    6aea:	50 e0       	ldi	r21, 0x00	; 0
    6aec:	67 e1       	ldi	r22, 0x17	; 23
    6aee:	75 e0       	ldi	r23, 0x05	; 5
    6af0:	c8 01       	movw	r24, r16
    6af2:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6af6:	f8 0e       	add	r15, r24

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK0", 19);
    6af8:	43 e1       	ldi	r20, 0x13	; 19
    6afa:	50 e0       	ldi	r21, 0x00	; 0
    6afc:	6b e1       	ldi	r22, 0x1B	; 27
    6afe:	75 e0       	ldi	r23, 0x05	; 5
    6b00:	c8 01       	movw	r24, r16
    6b02:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b06:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK1", 20);
    6b08:	44 e1       	ldi	r20, 0x14	; 20
    6b0a:	50 e0       	ldi	r21, 0x00	; 0
    6b0c:	61 e2       	ldi	r22, 0x21	; 33
    6b0e:	75 e0       	ldi	r23, 0x05	; 5
    6b10:	c8 01       	movw	r24, r16
    6b12:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b16:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK2", 21);
    6b18:	45 e1       	ldi	r20, 0x15	; 21
    6b1a:	50 e0       	ldi	r21, 0x00	; 0
    6b1c:	67 e2       	ldi	r22, 0x27	; 39
    6b1e:	75 e0       	ldi	r23, 0x05	; 5
    6b20:	c8 01       	movw	r24, r16
    6b22:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b26:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "MASK3", 22);
    6b28:	46 e1       	ldi	r20, 0x16	; 22
    6b2a:	50 e0       	ldi	r21, 0x00	; 0
    6b2c:	6d e2       	ldi	r22, 0x2D	; 45
    6b2e:	75 e0       	ldi	r23, 0x05	; 5
    6b30:	c8 01       	movw	r24, r16
    6b32:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b36:	f8 0e       	add	r15, r24

			//23-28 MAC which is assigned dynamicly from DS2401... so not used
			//29-30 Web port, static in this firmware

			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS0", 31);
    6b38:	4f e1       	ldi	r20, 0x1F	; 31
    6b3a:	50 e0       	ldi	r21, 0x00	; 0
    6b3c:	63 e3       	ldi	r22, 0x33	; 51
    6b3e:	75 e0       	ldi	r23, 0x05	; 5
    6b40:	c8 01       	movw	r24, r16
    6b42:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b46:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS1", 32);
    6b48:	40 e2       	ldi	r20, 0x20	; 32
    6b4a:	50 e0       	ldi	r21, 0x00	; 0
    6b4c:	68 e3       	ldi	r22, 0x38	; 56
    6b4e:	75 e0       	ldi	r23, 0x05	; 5
    6b50:	c8 01       	movw	r24, r16
    6b52:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b56:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS2", 33);
    6b58:	41 e2       	ldi	r20, 0x21	; 33
    6b5a:	50 e0       	ldi	r21, 0x00	; 0
    6b5c:	6d e3       	ldi	r22, 0x3D	; 61
    6b5e:	75 e0       	ldi	r23, 0x05	; 5
    6b60:	c8 01       	movw	r24, r16
    6b62:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b66:	f8 0e       	add	r15, r24
			changed += save_cgivalue_if_found((char*)&(buf[dat_p+4]), "DNS3", 34);
    6b68:	42 e2       	ldi	r20, 0x22	; 34
    6b6a:	50 e0       	ldi	r21, 0x00	; 0
    6b6c:	62 e4       	ldi	r22, 0x42	; 66
    6b6e:	75 e0       	ldi	r23, 0x05	; 5
    6b70:	c8 01       	movw	r24, r16
    6b72:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
    6b76:	8f 0d       	add	r24, r15

			if (changed > 0) while(true);  //causes watchdog to reset the avr
    6b78:	09 f0       	breq	.+2      	; 0x6b7c <handle_net+0x5da>
    6b7a:	ff cf       	rjmp	.-2      	; 0x6b7a <handle_net+0x5d8>

            dat_p=print_settings_webpage(buf);
    6b7c:	8b ed       	ldi	r24, 0xDB	; 219
    6b7e:	99 e1       	ldi	r25, 0x19	; 25
    6b80:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <print_settings_webpage>

          	goto SENDTCP;
    6b84:	63 c1       	rjmp	.+710    	; 0x6e4c <handle_net+0x8aa>
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/alarm"),7)==0){	
    6b86:	47 e0       	ldi	r20, 0x07	; 7
    6b88:	50 e0       	ldi	r21, 0x00	; 0
    6b8a:	6d e8       	ldi	r22, 0x8D	; 141
    6b8c:	73 e0       	ldi	r23, 0x03	; 3
    6b8e:	c8 01       	movw	r24, r16
    6b90:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6b94:	89 2b       	or	r24, r25
    6b96:	09 f0       	breq	.+2      	; 0x6b9a <handle_net+0x5f8>
    6b98:	de c0       	rjmp	.+444    	; 0x6d56 <handle_net+0x7b4>
			if (!user_is_auth((char *)&(buf[dat_p+4])))
    6b9a:	c8 01       	movw	r24, r16
    6b9c:	0e 94 0e 30 	call	0x601c	; 0x601c <user_is_auth>
    6ba0:	81 11       	cpse	r24, r1
    6ba2:	03 c0       	rjmp	.+6      	; 0x6baa <handle_net+0x608>
			{
				dat_p=https401();
    6ba4:	0e 94 45 29 	call	0x528a	; 0x528a <https401>
          		goto SENDTCP;
    6ba8:	51 c1       	rjmp	.+674    	; 0x6e4c <handle_net+0x8aa>

            dat_p=print_settings_webpage(buf);

          	goto SENDTCP;
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/settings/alarm"),7)==0){	
			if (!user_is_auth((char *)&(buf[dat_p+4])))
    6baa:	a9 e9       	ldi	r26, 0x99	; 153
    6bac:	ca 2e       	mov	r12, r26
    6bae:	dd 24       	eor	r13, r13
    6bb0:	d3 94       	inc	r13
    6bb2:	aa 24       	eor	r10, r10
    6bb4:	a3 94       	inc	r10
    6bb6:	b1 2c       	mov	r11, r1
			for (uint8_t i=0; i<4; i++)
			{
				char cgival[3];

				//source = 401..408
				sprintf_P(tempbuf, PSTR("S%u"), i+1);
    6bb8:	8a e0       	ldi	r24, 0x0A	; 10
    6bba:	e8 2e       	mov	r14, r24
    6bbc:	89 e0       	ldi	r24, 0x09	; 9
    6bbe:	f8 2e       	mov	r15, r24
					signed_save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+10);
					sprintf_P(tempbuf, PSTR("D%u"), i+1);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+11);
					sprintf_P(tempbuf, PSTR("P%u"), i+1);
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+12);
					sprintf_P(tempbuf, PSTR("R%u"), i+1);
    6bc0:	95 e7       	ldi	r25, 0x75	; 117
    6bc2:	69 2e       	mov	r6, r25
    6bc4:	93 e0       	ldi	r25, 0x03	; 3
    6bc6:	79 2e       	mov	r7, r25
					save_checkbox_cgivalue((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+13);				
					sprintf_P(tempbuf, PSTR("E%u"), i+1);
    6bc8:	21 e7       	ldi	r18, 0x71	; 113
    6bca:	82 2e       	mov	r8, r18
    6bcc:	23 e0       	ldi	r18, 0x03	; 3
    6bce:	92 2e       	mov	r9, r18
			for (uint8_t i=0; i<4; i++)
			{
				char cgival[3];

				//source = 401..408
				sprintf_P(tempbuf, PSTR("S%u"), i+1);
    6bd0:	5a 2c       	mov	r5, r10
    6bd2:	4b 2c       	mov	r4, r11
    6bd4:	bf 92       	push	r11
    6bd6:	af 92       	push	r10
    6bd8:	a9 e8       	ldi	r26, 0x89	; 137
    6bda:	b3 e0       	ldi	r27, 0x03	; 3
    6bdc:	bf 93       	push	r27
    6bde:	af 93       	push	r26
    6be0:	ff 92       	push	r15
    6be2:	ef 92       	push	r14
    6be4:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
				uint8_t length = find_key_val((char *)&(buf[dat_p+4]),cgival, 3,tempbuf);
    6be8:	2a e0       	ldi	r18, 0x0A	; 10
    6bea:	39 e0       	ldi	r19, 0x09	; 9
    6bec:	43 e0       	ldi	r20, 0x03	; 3
    6bee:	be 01       	movw	r22, r28
    6bf0:	6f 5f       	subi	r22, 0xFF	; 255
    6bf2:	7f 4f       	sbci	r23, 0xFF	; 255
    6bf4:	c8 01       	movw	r24, r16
    6bf6:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <find_key_val>
    6bfa:	28 2e       	mov	r2, r24
				uint8_t sensorid = atoi(cgival);
    6bfc:	ce 01       	movw	r24, r28
    6bfe:	01 96       	adiw	r24, 0x01	; 1
    6c00:	0e 94 a4 3c 	call	0x7948	; 0x7948 <atoi>
				uint8_t loc = 0;

				if (length > 0 && sensorid < MAXSENSORS)
    6c04:	0f 90       	pop	r0
    6c06:	0f 90       	pop	r0
    6c08:	0f 90       	pop	r0
    6c0a:	0f 90       	pop	r0
    6c0c:	0f 90       	pop	r0
    6c0e:	0f 90       	pop	r0
    6c10:	22 20       	and	r2, r2
    6c12:	09 f4       	brne	.+2      	; 0x6c16 <handle_net+0x674>
    6c14:	90 c0       	rjmp	.+288    	; 0x6d36 <handle_net+0x794>
    6c16:	8c 33       	cpi	r24, 0x3C	; 60
    6c18:	08 f0       	brcs	.+2      	; 0x6c1c <handle_net+0x67a>
    6c1a:	8d c0       	rjmp	.+282    	; 0x6d36 <handle_net+0x794>
				{
					loc = (15*i)+1;

					for (uint8_t pos=0; pos<8; pos++)
					{
						eepromWriteByte(400+loc, sensorValues[(SENSORSIZE * sensorid) + pos]);
    6c1c:	fb e0       	ldi	r31, 0x0B	; 11
    6c1e:	8f 9f       	mul	r24, r31
    6c20:	a0 01       	movw	r20, r0
    6c22:	11 24       	eor	r1, r1
    6c24:	21 2c       	mov	r2, r1
    6c26:	31 2c       	mov	r3, r1
    6c28:	40 5f       	subi	r20, 0xF0	; 240
    6c2a:	59 4f       	sbci	r21, 0xF9	; 249
    6c2c:	28 e6       	ldi	r18, 0x68	; 104
    6c2e:	2c 0d       	add	r18, r12
    6c30:	fa 01       	movw	r30, r20
    6c32:	e2 0d       	add	r30, r2
    6c34:	f3 1d       	adc	r31, r3
    6c36:	82 2f       	mov	r24, r18
    6c38:	82 0d       	add	r24, r2
    6c3a:	90 e0       	ldi	r25, 0x00	; 0
    6c3c:	60 81       	ld	r22, Z
    6c3e:	80 57       	subi	r24, 0x70	; 112
    6c40:	9e 4f       	sbci	r25, 0xFE	; 254
    6c42:	2e 87       	std	Y+14, r18	; 0x0e
    6c44:	4c 87       	std	Y+12, r20	; 0x0c
    6c46:	5d 87       	std	Y+13, r21	; 0x0d
    6c48:	0e 94 1c 21 	call	0x4238	; 0x4238 <eepromSaveByte>
    6c4c:	8f ef       	ldi	r24, 0xFF	; 255
    6c4e:	28 1a       	sub	r2, r24
    6c50:	38 0a       	sbc	r3, r24

				if (length > 0 && sensorid < MAXSENSORS)
				{
					loc = (15*i)+1;

					for (uint8_t pos=0; pos<8; pos++)
    6c52:	2e 85       	ldd	r18, Y+14	; 0x0e
    6c54:	4c 85       	ldd	r20, Y+12	; 0x0c
    6c56:	5d 85       	ldd	r21, Y+13	; 0x0d
    6c58:	98 e0       	ldi	r25, 0x08	; 8
    6c5a:	29 16       	cp	r2, r25
    6c5c:	31 04       	cpc	r3, r1
    6c5e:	41 f7       	brne	.-48     	; 0x6c30 <handle_net+0x68e>
					}
				}

				if (loc > 0)
				{
					sprintf_P(tempbuf, PSTR("T%u"), i+1);
    6c60:	4f 92       	push	r4
    6c62:	5f 92       	push	r5
    6c64:	a5 e8       	ldi	r26, 0x85	; 133
    6c66:	b3 e0       	ldi	r27, 0x03	; 3
    6c68:	bf 93       	push	r27
    6c6a:	af 93       	push	r26
    6c6c:	ff 92       	push	r15
    6c6e:	ef 92       	push	r14
    6c70:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+9);
    6c74:	a6 01       	movw	r20, r12
    6c76:	6a e0       	ldi	r22, 0x0A	; 10
    6c78:	79 e0       	ldi	r23, 0x09	; 9
    6c7a:	c8 01       	movw	r24, r16
    6c7c:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
					sprintf_P(tempbuf, PSTR("V%u"), i+1);
    6c80:	4f 92       	push	r4
    6c82:	5f 92       	push	r5
    6c84:	a1 e8       	ldi	r26, 0x81	; 129
    6c86:	b3 e0       	ldi	r27, 0x03	; 3
    6c88:	bf 93       	push	r27
    6c8a:	af 93       	push	r26
    6c8c:	ff 92       	push	r15
    6c8e:	ef 92       	push	r14
    6c90:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
    6c94:	a6 01       	movw	r20, r12
    6c96:	4f 5f       	subi	r20, 0xFF	; 255
    6c98:	5f 4f       	sbci	r21, 0xFF	; 255
					signed_save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+10);
    6c9a:	6a e0       	ldi	r22, 0x0A	; 10
    6c9c:	79 e0       	ldi	r23, 0x09	; 9
    6c9e:	c8 01       	movw	r24, r16
    6ca0:	0e 94 a1 32 	call	0x6542	; 0x6542 <signed_save_cgivalue_if_found>
					sprintf_P(tempbuf, PSTR("D%u"), i+1);
    6ca4:	4f 92       	push	r4
    6ca6:	5f 92       	push	r5
    6ca8:	ad e7       	ldi	r26, 0x7D	; 125
    6caa:	b3 e0       	ldi	r27, 0x03	; 3
    6cac:	bf 93       	push	r27
    6cae:	af 93       	push	r26
    6cb0:	ff 92       	push	r15
    6cb2:	ef 92       	push	r14
    6cb4:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
    6cb8:	a6 01       	movw	r20, r12
    6cba:	4e 5f       	subi	r20, 0xFE	; 254
    6cbc:	5f 4f       	sbci	r21, 0xFF	; 255
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+11);
    6cbe:	6a e0       	ldi	r22, 0x0A	; 10
    6cc0:	79 e0       	ldi	r23, 0x09	; 9
    6cc2:	c8 01       	movw	r24, r16
    6cc4:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
					sprintf_P(tempbuf, PSTR("P%u"), i+1);
    6cc8:	4f 92       	push	r4
    6cca:	5f 92       	push	r5
    6ccc:	a9 e7       	ldi	r26, 0x79	; 121
    6cce:	b3 e0       	ldi	r27, 0x03	; 3
    6cd0:	bf 93       	push	r27
    6cd2:	af 93       	push	r26
    6cd4:	ff 92       	push	r15
    6cd6:	ef 92       	push	r14
    6cd8:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
    6cdc:	a6 01       	movw	r20, r12
    6cde:	4d 5f       	subi	r20, 0xFD	; 253
    6ce0:	5f 4f       	sbci	r21, 0xFF	; 255
					save_cgivalue_if_found((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+12);
    6ce2:	6a e0       	ldi	r22, 0x0A	; 10
    6ce4:	79 e0       	ldi	r23, 0x09	; 9
    6ce6:	c8 01       	movw	r24, r16
    6ce8:	0e 94 71 32 	call	0x64e2	; 0x64e2 <save_cgivalue_if_found>
					sprintf_P(tempbuf, PSTR("R%u"), i+1);
    6cec:	4f 92       	push	r4
    6cee:	5f 92       	push	r5
    6cf0:	7f 92       	push	r7
    6cf2:	6f 92       	push	r6
    6cf4:	ff 92       	push	r15
    6cf6:	ef 92       	push	r14
    6cf8:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
    6cfc:	a6 01       	movw	r20, r12
    6cfe:	4c 5f       	subi	r20, 0xFC	; 252
    6d00:	5f 4f       	sbci	r21, 0xFF	; 255
					save_checkbox_cgivalue((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+13);				
    6d02:	6a e0       	ldi	r22, 0x0A	; 10
    6d04:	79 e0       	ldi	r23, 0x09	; 9
    6d06:	c8 01       	movw	r24, r16
    6d08:	0e 94 1b 32 	call	0x6436	; 0x6436 <save_checkbox_cgivalue>
					sprintf_P(tempbuf, PSTR("E%u"), i+1);
    6d0c:	4f 92       	push	r4
    6d0e:	5f 92       	push	r5
    6d10:	9f 92       	push	r9
    6d12:	8f 92       	push	r8
    6d14:	ff 92       	push	r15
    6d16:	ef 92       	push	r14
    6d18:	0e 94 1b 3f 	call	0x7e36	; 0x7e36 <sprintf_P>
					save_checkbox_cgivalue((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+0);
    6d1c:	0f b6       	in	r0, 0x3f	; 63
    6d1e:	f8 94       	cli
    6d20:	de bf       	out	0x3e, r29	; 62
    6d22:	0f be       	out	0x3f, r0	; 63
    6d24:	cd bf       	out	0x3d, r28	; 61
    6d26:	a6 01       	movw	r20, r12
    6d28:	49 50       	subi	r20, 0x09	; 9
    6d2a:	51 09       	sbc	r21, r1
    6d2c:	6a e0       	ldi	r22, 0x0A	; 10
    6d2e:	79 e0       	ldi	r23, 0x09	; 9
    6d30:	c8 01       	movw	r24, r16
    6d32:	0e 94 1b 32 	call	0x6436	; 0x6436 <save_checkbox_cgivalue>
    6d36:	9f ef       	ldi	r25, 0xFF	; 255
    6d38:	a9 1a       	sub	r10, r25
    6d3a:	b9 0a       	sbc	r11, r25
    6d3c:	af e0       	ldi	r26, 0x0F	; 15
    6d3e:	ca 0e       	add	r12, r26
    6d40:	d1 1c       	adc	r13, r1
			{
				dat_p=https401();
          		goto SENDTCP;
			}

			for (uint8_t i=0; i<4; i++)
    6d42:	b5 e0       	ldi	r27, 0x05	; 5
    6d44:	ab 16       	cp	r10, r27
    6d46:	b1 04       	cpc	r11, r1
    6d48:	09 f0       	breq	.+2      	; 0x6d4c <handle_net+0x7aa>
    6d4a:	42 cf       	rjmp	.-380    	; 0x6bd0 <handle_net+0x62e>
					sprintf_P(tempbuf, PSTR("E%u"), i+1);
					save_checkbox_cgivalue((char*)&(buf[dat_p+4]), tempbuf, 400+(15*i)+0);
				}
			}

			dat_p=print_flash_webpage(true, alarms_htm, buf);
    6d4c:	4b ed       	ldi	r20, 0xDB	; 219
    6d4e:	59 e1       	ldi	r21, 0x19	; 25
    6d50:	64 e6       	ldi	r22, 0x64	; 100
    6d52:	75 e1       	ldi	r23, 0x15	; 21
    6d54:	61 c0       	rjmp	.+194    	; 0x6e18 <handle_net+0x876>

          	goto SENDTCP;
	} else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/fmu.js"), 7)==0){	
    6d56:	47 e0       	ldi	r20, 0x07	; 7
    6d58:	50 e0       	ldi	r21, 0x00	; 0
    6d5a:	69 e6       	ldi	r22, 0x69	; 105
    6d5c:	73 e0       	ldi	r23, 0x03	; 3
    6d5e:	c8 01       	movw	r24, r16
    6d60:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6d64:	89 2b       	or	r24, r25
    6d66:	29 f4       	brne	.+10     	; 0x6d72 <handle_net+0x7d0>
			dat_p=print_flash_webpage(true, fmu_js, buf);
    6d68:	4b ed       	ldi	r20, 0xDB	; 219
    6d6a:	59 e1       	ldi	r21, 0x19	; 25
    6d6c:	6e e9       	ldi	r22, 0x9E	; 158
    6d6e:	72 e1       	ldi	r23, 0x12	; 18
    6d70:	53 c0       	rjmp	.+166    	; 0x6e18 <handle_net+0x876>

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/fmu2.js"),8)==0){	
    6d72:	48 e0       	ldi	r20, 0x08	; 8
    6d74:	50 e0       	ldi	r21, 0x00	; 0
    6d76:	60 e6       	ldi	r22, 0x60	; 96
    6d78:	73 e0       	ldi	r23, 0x03	; 3
    6d7a:	c8 01       	movw	r24, r16
    6d7c:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6d80:	89 2b       	or	r24, r25
    6d82:	29 f4       	brne	.+10     	; 0x6d8e <handle_net+0x7ec>
            dat_p=print_flash_webpage(true, fmu2_js, buf);
    6d84:	4b ed       	ldi	r20, 0xDB	; 219
    6d86:	59 e1       	ldi	r21, 0x19	; 25
    6d88:	66 e6       	ldi	r22, 0x66	; 102
    6d8a:	71 e1       	ldi	r23, 0x11	; 17
    6d8c:	45 c0       	rjmp	.+138    	; 0x6e18 <handle_net+0x876>

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/alarms.js"),10)==0){	
    6d8e:	4a e0       	ldi	r20, 0x0A	; 10
    6d90:	50 e0       	ldi	r21, 0x00	; 0
    6d92:	65 e5       	ldi	r22, 0x55	; 85
    6d94:	73 e0       	ldi	r23, 0x03	; 3
    6d96:	c8 01       	movw	r24, r16
    6d98:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6d9c:	89 2b       	or	r24, r25
    6d9e:	29 f4       	brne	.+10     	; 0x6daa <handle_net+0x808>
            dat_p=print_flash_webpage(true, alarms_js, buf);
    6da0:	4b ed       	ldi	r20, 0xDB	; 219
    6da2:	59 e1       	ldi	r21, 0x19	; 25
    6da4:	65 e6       	ldi	r22, 0x65	; 101
    6da6:	74 e1       	ldi	r23, 0x14	; 20
    6da8:	37 c0       	rjmp	.+110    	; 0x6e18 <handle_net+0x876>

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/loader.js"),10)==0){	
    6daa:	4a e0       	ldi	r20, 0x0A	; 10
    6dac:	50 e0       	ldi	r21, 0x00	; 0
    6dae:	6a e4       	ldi	r22, 0x4A	; 74
    6db0:	73 e0       	ldi	r23, 0x03	; 3
    6db2:	c8 01       	movw	r24, r16
    6db4:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6db8:	89 2b       	or	r24, r25
    6dba:	29 f4       	brne	.+10     	; 0x6dc6 <handle_net+0x824>
            dat_p=print_flash_webpage(true, loader_js, buf);
    6dbc:	4b ed       	ldi	r20, 0xDB	; 219
    6dbe:	59 e1       	ldi	r21, 0x19	; 25
    6dc0:	64 eb       	ldi	r22, 0xB4	; 180
    6dc2:	70 e1       	ldi	r23, 0x10	; 16
    6dc4:	29 c0       	rjmp	.+82     	; 0x6e18 <handle_net+0x876>

          	goto SENDTCP;
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/slist.js"),9)==0){	
    6dc6:	49 e0       	ldi	r20, 0x09	; 9
    6dc8:	50 e0       	ldi	r21, 0x00	; 0
    6dca:	60 e4       	ldi	r22, 0x40	; 64
    6dcc:	73 e0       	ldi	r23, 0x03	; 3
    6dce:	c8 01       	movw	r24, r16
    6dd0:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6dd4:	89 2b       	or	r24, r25
    6dd6:	29 f4       	brne	.+10     	; 0x6de2 <handle_net+0x840>
            dat_p=print_sensorlist(buf);
    6dd8:	8b ed       	ldi	r24, 0xDB	; 219
    6dda:	99 e1       	ldi	r25, 0x19	; 25
    6ddc:	0e 94 6a 2c 	call	0x58d4	; 0x58d4 <print_sensorlist>

          	goto SENDTCP;
    6de0:	35 c0       	rjmp	.+106    	; 0x6e4c <handle_net+0x8aa>
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/alist.js"),9)==0){	
    6de2:	49 e0       	ldi	r20, 0x09	; 9
    6de4:	50 e0       	ldi	r21, 0x00	; 0
    6de6:	66 e3       	ldi	r22, 0x36	; 54
    6de8:	73 e0       	ldi	r23, 0x03	; 3
    6dea:	c8 01       	movw	r24, r16
    6dec:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6df0:	89 2b       	or	r24, r25
    6df2:	29 f4       	brne	.+10     	; 0x6dfe <handle_net+0x85c>
            dat_p=print_alarmlist(buf);
    6df4:	8b ed       	ldi	r24, 0xDB	; 219
    6df6:	99 e1       	ldi	r25, 0x19	; 25
    6df8:	0e 94 2f 2d 	call	0x5a5e	; 0x5a5e <print_alarmlist>

          	goto SENDTCP;
    6dfc:	27 c0       	rjmp	.+78     	; 0x6e4c <handle_net+0x8aa>
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/style.css"),10)==0){	
    6dfe:	4a e0       	ldi	r20, 0x0A	; 10
    6e00:	50 e0       	ldi	r21, 0x00	; 0
    6e02:	6b e2       	ldi	r22, 0x2B	; 43
    6e04:	73 e0       	ldi	r23, 0x03	; 3
    6e06:	c8 01       	movw	r24, r16
    6e08:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6e0c:	89 2b       	or	r24, r25
    6e0e:	41 f4       	brne	.+16     	; 0x6e20 <handle_net+0x87e>
            dat_p=print_flash_webpage(true, style_css, buf);
    6e10:	4b ed       	ldi	r20, 0xDB	; 219
    6e12:	59 e1       	ldi	r21, 0x19	; 25
    6e14:	61 ec       	ldi	r22, 0xC1	; 193
    6e16:	7c e0       	ldi	r23, 0x0C	; 12
    6e18:	81 e0       	ldi	r24, 0x01	; 1
    6e1a:	0e 94 d0 2f 	call	0x5fa0	; 0x5fa0 <print_flash_webpage>
          	goto SENDTCP;		
    6e1e:	16 c0       	rjmp	.+44     	; 0x6e4c <handle_net+0x8aa>
    } else if (strncmp_P((char *)&(buf[dat_p+4]),PSTR("/export.htm"),11)==0){	
    6e20:	4b e0       	ldi	r20, 0x0B	; 11
    6e22:	50 e0       	ldi	r21, 0x00	; 0
    6e24:	6f e1       	ldi	r22, 0x1F	; 31
    6e26:	73 e0       	ldi	r23, 0x03	; 3
    6e28:	c8 01       	movw	r24, r16
    6e2a:	0e 94 9a 3d 	call	0x7b34	; 0x7b34 <strncmp_P>
    6e2e:	89 2b       	or	r24, r25
    6e30:	29 f4       	brne	.+10     	; 0x6e3c <handle_net+0x89a>
            dat_p=print_export_htm(buf);
    6e32:	8b ed       	ldi	r24, 0xDB	; 219
    6e34:	99 e1       	ldi	r25, 0x19	; 25
    6e36:	0e 94 4d 29 	call	0x529a	; 0x529a <print_export_htm>

          	goto SENDTCP;
    6e3a:	08 c0       	rjmp	.+16     	; 0x6e4c <handle_net+0x8aa>
    } else{
            dat_p=fill_tcp_data_p(buf,0,PSTR("HTTP/1.0 401 Unauthorized\r\nContent-Type: text/html\r\n\r\n<h1>401 Unauthorized</h1>"));
    6e3c:	4f ec       	ldi	r20, 0xCF	; 207
    6e3e:	52 e0       	ldi	r21, 0x02	; 2
    6e40:	60 e0       	ldi	r22, 0x00	; 0
    6e42:	70 e0       	ldi	r23, 0x00	; 0
    6e44:	8b ed       	ldi	r24, 0xDB	; 219
    6e46:	99 e1       	ldi	r25, 0x19	; 25
    6e48:	0e 94 30 12 	call	0x2460	; 0x2460 <fill_tcp_data_p>
            goto SENDTCP;
    }
    //

	SENDTCP:
    www_server_reply(buf,dat_p); // send data
    6e4c:	bc 01       	movw	r22, r24
    6e4e:	8b ed       	ldi	r24, 0xDB	; 219
    6e50:	99 e1       	ldi	r25, 0x19	; 25
    6e52:	0e 94 80 13 	call	0x2700	; 0x2700 <www_server_reply>
}
    6e56:	2e 96       	adiw	r28, 0x0e	; 14
    6e58:	0f b6       	in	r0, 0x3f	; 63
    6e5a:	f8 94       	cli
    6e5c:	de bf       	out	0x3e, r29	; 62
    6e5e:	0f be       	out	0x3f, r0	; 63
    6e60:	cd bf       	out	0x3d, r28	; 61
    6e62:	df 91       	pop	r29
    6e64:	cf 91       	pop	r28
    6e66:	1f 91       	pop	r17
    6e68:	0f 91       	pop	r16
    6e6a:	ff 90       	pop	r15
    6e6c:	ef 90       	pop	r14
    6e6e:	df 90       	pop	r13
    6e70:	cf 90       	pop	r12
    6e72:	bf 90       	pop	r11
    6e74:	af 90       	pop	r10
    6e76:	9f 90       	pop	r9
    6e78:	8f 90       	pop	r8
    6e7a:	7f 90       	pop	r7
    6e7c:	6f 90       	pop	r6
    6e7e:	5f 90       	pop	r5
    6e80:	4f 90       	pop	r4
    6e82:	3f 90       	pop	r3
    6e84:	2f 90       	pop	r2
    6e86:	08 95       	ret

00006e88 <LCDclr>:
_delay_ms(5);
}

void LCDclr()
{
	dbg_putchar(CMD_ID);
    6e88:	81 e1       	ldi	r24, 0x11	; 17
    6e8a:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(CMD_CLR_SCRN);
    6e8e:	89 e6       	ldi	r24, 0x69	; 105
    6e90:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(0);
    6e94:	80 e0       	ldi	r24, 0x00	; 0
    6e96:	0c 94 ac 37 	jmp	0x6f58	; 0x6f58 <dbg_putchar>

00006e9a <spilcd_init>:
//software serial 9600baud for now
//portd.7

void spilcd_init()
{
    SETBIT(DDRD, 7); //output
    6e9a:	57 9a       	sbi	0x0a, 7	; 10
    LCDclr();
    6e9c:	0e 94 44 37 	call	0x6e88	; 0x6e88 <LCDclr>

	dbg_putchar(CMD_ID);
    6ea0:	81 e1       	ldi	r24, 0x11	; 17
    6ea2:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(CMD_NB_LINE);
    6ea6:	87 e6       	ldi	r24, 0x67	; 103
    6ea8:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(4);
    6eac:	84 e0       	ldi	r24, 0x04	; 4
    6eae:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    6eb2:	8f e0       	ldi	r24, 0x0F	; 15
    6eb4:	97 e2       	ldi	r25, 0x27	; 39
    6eb6:	01 97       	sbiw	r24, 0x01	; 1
    6eb8:	f1 f7       	brne	.-4      	; 0x6eb6 <spilcd_init+0x1c>
    6eba:	00 c0       	rjmp	.+0      	; 0x6ebc <spilcd_init+0x22>
    6ebc:	00 00       	nop
_delay_ms(5);
	dbg_putchar(CMD_ID);
    6ebe:	81 e1       	ldi	r24, 0x11	; 17
    6ec0:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(CMD_NB_COLUMN);
    6ec4:	88 e6       	ldi	r24, 0x68	; 104
    6ec6:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(20);
    6eca:	84 e1       	ldi	r24, 0x14	; 20
    6ecc:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
    6ed0:	8f e0       	ldi	r24, 0x0F	; 15
    6ed2:	97 e2       	ldi	r25, 0x27	; 39
    6ed4:	01 97       	sbiw	r24, 0x01	; 1
    6ed6:	f1 f7       	brne	.-4      	; 0x6ed4 <spilcd_init+0x3a>
    6ed8:	00 c0       	rjmp	.+0      	; 0x6eda <spilcd_init+0x40>
    6eda:	00 00       	nop
_delay_ms(5);
	dbg_putchar(CMD_ID);
    6edc:	81 e1       	ldi	r24, 0x11	; 17
    6ede:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(CMD_CONTRAST);
    6ee2:	86 e6       	ldi	r24, 0x66	; 102
    6ee4:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(255);
    6ee8:	8f ef       	ldi	r24, 0xFF	; 255
    6eea:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
    6eee:	8f e0       	ldi	r24, 0x0F	; 15
    6ef0:	97 e2       	ldi	r25, 0x27	; 39
    6ef2:	01 97       	sbiw	r24, 0x01	; 1
    6ef4:	f1 f7       	brne	.-4      	; 0x6ef2 <spilcd_init+0x58>
    6ef6:	00 c0       	rjmp	.+0      	; 0x6ef8 <spilcd_init+0x5e>
    6ef8:	00 00       	nop
_delay_ms(5);
	dbg_putchar(CMD_ID);
    6efa:	81 e1       	ldi	r24, 0x11	; 17
    6efc:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(CMD_BACKLIGHT);
    6f00:	85 e6       	ldi	r24, 0x65	; 101
    6f02:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(255);
    6f06:	8f ef       	ldi	r24, 0xFF	; 255
    6f08:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
    6f0c:	8f e0       	ldi	r24, 0x0F	; 15
    6f0e:	97 e2       	ldi	r25, 0x27	; 39
    6f10:	01 97       	sbiw	r24, 0x01	; 1
    6f12:	f1 f7       	brne	.-4      	; 0x6f10 <spilcd_init+0x76>
    6f14:	00 c0       	rjmp	.+0      	; 0x6f16 <spilcd_init+0x7c>
    6f16:	00 00       	nop
    6f18:	08 95       	ret

00006f1a <LCDsetCursor>:
	dbg_putchar(CMD_CLR_SCRN);
	dbg_putchar(0);
}

void LCDsetCursor(uint8_t x, uint8_t y)
{
    6f1a:	cf 93       	push	r28
    6f1c:	df 93       	push	r29
    6f1e:	c8 2f       	mov	r28, r24
    6f20:	d6 2f       	mov	r29, r22
	dbg_putchar(CMD_ID);
    6f22:	81 e1       	ldi	r24, 0x11	; 17
    6f24:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	if (x == 0) dbg_putchar(CMD_LINE_0);
    6f28:	c1 11       	cpse	r28, r1
    6f2a:	02 c0       	rjmp	.+4      	; 0x6f30 <LCDsetCursor+0x16>
    6f2c:	80 e0       	ldi	r24, 0x00	; 0
    6f2e:	0b c0       	rjmp	.+22     	; 0x6f46 <LCDsetCursor+0x2c>
	if (x == 1) dbg_putchar(CMD_LINE_1);
    6f30:	c1 30       	cpi	r28, 0x01	; 1
    6f32:	11 f4       	brne	.+4      	; 0x6f38 <LCDsetCursor+0x1e>
    6f34:	81 e0       	ldi	r24, 0x01	; 1
    6f36:	07 c0       	rjmp	.+14     	; 0x6f46 <LCDsetCursor+0x2c>
	if (x == 2) dbg_putchar(CMD_LINE_2);
    6f38:	c2 30       	cpi	r28, 0x02	; 2
    6f3a:	11 f4       	brne	.+4      	; 0x6f40 <LCDsetCursor+0x26>
    6f3c:	82 e0       	ldi	r24, 0x02	; 2
    6f3e:	03 c0       	rjmp	.+6      	; 0x6f46 <LCDsetCursor+0x2c>
	if (x == 3) dbg_putchar(CMD_LINE_3);
    6f40:	c3 30       	cpi	r28, 0x03	; 3
    6f42:	19 f4       	brne	.+6      	; 0x6f4a <LCDsetCursor+0x30>
    6f44:	83 e0       	ldi	r24, 0x03	; 3
    6f46:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
	dbg_putchar(y);
    6f4a:	8d 2f       	mov	r24, r29
}
    6f4c:	df 91       	pop	r29
    6f4e:	cf 91       	pop	r28
	dbg_putchar(CMD_ID);
	if (x == 0) dbg_putchar(CMD_LINE_0);
	if (x == 1) dbg_putchar(CMD_LINE_1);
	if (x == 2) dbg_putchar(CMD_LINE_2);
	if (x == 3) dbg_putchar(CMD_LINE_3);
	dbg_putchar(y);
    6f50:	0c 94 ac 37 	jmp	0x6f58	; 0x6f58 <dbg_putchar>

00006f54 <LCDwrite>:
}

void LCDwrite(char* str, uint8_t length)
{
	dbg_puts(str);
    6f54:	0c 94 c8 37 	jmp	0x6f90	; 0x6f90 <dbg_puts>

00006f58 <dbg_putchar>:
#define DBG_UART_TX_NUM_ADD_NOP		((F_CPU/DBG_UART_BAUDRATE-16)%4)
	uint8_t sreg;
	uint16_t tmp;
	uint8_t numiter = 10;

	sreg = SREG;
    6f58:	2f b7       	in	r18, 0x3f	; 63
	cli();
    6f5a:	f8 94       	cli

	asm volatile (
    6f5c:	9a e0       	ldi	r25, 0x0A	; 10
    6f5e:	eb b1       	in	r30, 0x0b	; 11
    6f60:	ef 77       	andi	r30, 0x7F	; 127
    6f62:	eb b9       	out	0x0b, r30	; 11
	...
    6f6c:	00 00       	nop
    6f6e:	ed ec       	ldi	r30, 0xCD	; 205
    6f70:	f0 e0       	ldi	r31, 0x00	; 0
    6f72:	31 97       	sbiw	r30, 0x01	; 1
    6f74:	f1 f7       	brne	.-4      	; 0x6f72 <dbg_putchar+0x1a>
    6f76:	00 00       	nop
    6f78:	eb b1       	in	r30, 0x0b	; 11
    6f7a:	80 fd       	sbrc	r24, 0
    6f7c:	e0 68       	ori	r30, 0x80	; 128
    6f7e:	80 ff       	sbrs	r24, 0
    6f80:	ef 77       	andi	r30, 0x7F	; 127
    6f82:	eb b9       	out	0x0b, r30	; 11
    6f84:	08 94       	sec
    6f86:	87 95       	ror	r24
    6f88:	9a 95       	dec	r25
    6f8a:	89 f7       	brne	.-30     	; 0x6f6e <dbg_putchar+0x16>
		  "M" (1<<DBG_UART_TX_PIN),
		  "i" (DBG_UART_TX_NUM_DELAY_CYCLES),
		  "1" (c),			/* data */
		  "2" (numiter)
	);
	SREG = sreg;
    6f8c:	2f bf       	out	0x3f, r18	; 63
    6f8e:	08 95       	ret

00006f90 <dbg_puts>:

#if DBG_UART_ENABLE


void dbg_puts(char *s)
{
    6f90:	cf 93       	push	r28
    6f92:	df 93       	push	r29
    6f94:	ec 01       	movw	r28, r24
        while(*s) dbg_putchar(*s++);
    6f96:	89 91       	ld	r24, Y+
    6f98:	88 23       	and	r24, r24
    6f9a:	19 f0       	breq	.+6      	; 0x6fa2 <dbg_puts+0x12>
    6f9c:	0e 94 ac 37 	call	0x6f58	; 0x6f58 <dbg_putchar>
    6fa0:	fa cf       	rjmp	.-12     	; 0x6f96 <dbg_puts+0x6>

} 
    6fa2:	df 91       	pop	r29
    6fa4:	cf 91       	pop	r28
    6fa6:	08 95       	ret

00006fa8 <vfprintf>:
    6fa8:	2f 92       	push	r2
    6faa:	3f 92       	push	r3
    6fac:	4f 92       	push	r4
    6fae:	5f 92       	push	r5
    6fb0:	6f 92       	push	r6
    6fb2:	7f 92       	push	r7
    6fb4:	8f 92       	push	r8
    6fb6:	9f 92       	push	r9
    6fb8:	af 92       	push	r10
    6fba:	bf 92       	push	r11
    6fbc:	cf 92       	push	r12
    6fbe:	df 92       	push	r13
    6fc0:	ef 92       	push	r14
    6fc2:	ff 92       	push	r15
    6fc4:	0f 93       	push	r16
    6fc6:	1f 93       	push	r17
    6fc8:	cf 93       	push	r28
    6fca:	df 93       	push	r29
    6fcc:	cd b7       	in	r28, 0x3d	; 61
    6fce:	de b7       	in	r29, 0x3e	; 62
    6fd0:	63 97       	sbiw	r28, 0x13	; 19
    6fd2:	0f b6       	in	r0, 0x3f	; 63
    6fd4:	f8 94       	cli
    6fd6:	de bf       	out	0x3e, r29	; 62
    6fd8:	0f be       	out	0x3f, r0	; 63
    6fda:	cd bf       	out	0x3d, r28	; 61
    6fdc:	7c 01       	movw	r14, r24
    6fde:	1b 01       	movw	r2, r22
    6fe0:	6a 01       	movw	r12, r20
    6fe2:	fc 01       	movw	r30, r24
    6fe4:	17 82       	std	Z+7, r1	; 0x07
    6fe6:	16 82       	std	Z+6, r1	; 0x06
    6fe8:	83 81       	ldd	r24, Z+3	; 0x03
    6fea:	81 ff       	sbrs	r24, 1
    6fec:	66 c3       	rjmp	.+1740   	; 0x76ba <vfprintf+0x712>
    6fee:	be 01       	movw	r22, r28
    6ff0:	6f 5f       	subi	r22, 0xFF	; 255
    6ff2:	7f 4f       	sbci	r23, 0xFF	; 255
    6ff4:	4b 01       	movw	r8, r22
    6ff6:	f7 01       	movw	r30, r14
    6ff8:	93 81       	ldd	r25, Z+3	; 0x03
    6ffa:	f1 01       	movw	r30, r2
    6ffc:	93 fd       	sbrc	r25, 3
    6ffe:	85 91       	lpm	r24, Z+
    7000:	93 ff       	sbrs	r25, 3
    7002:	81 91       	ld	r24, Z+
    7004:	1f 01       	movw	r2, r30
    7006:	88 23       	and	r24, r24
    7008:	09 f4       	brne	.+2      	; 0x700c <vfprintf+0x64>
    700a:	53 c3       	rjmp	.+1702   	; 0x76b2 <vfprintf+0x70a>
    700c:	85 32       	cpi	r24, 0x25	; 37
    700e:	39 f4       	brne	.+14     	; 0x701e <vfprintf+0x76>
    7010:	93 fd       	sbrc	r25, 3
    7012:	85 91       	lpm	r24, Z+
    7014:	93 ff       	sbrs	r25, 3
    7016:	81 91       	ld	r24, Z+
    7018:	1f 01       	movw	r2, r30
    701a:	85 32       	cpi	r24, 0x25	; 37
    701c:	39 f4       	brne	.+14     	; 0x702c <vfprintf+0x84>
    701e:	b7 01       	movw	r22, r14
    7020:	90 e0       	ldi	r25, 0x00	; 0
    7022:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7026:	56 01       	movw	r10, r12
    7028:	65 01       	movw	r12, r10
    702a:	e5 cf       	rjmp	.-54     	; 0x6ff6 <vfprintf+0x4e>
    702c:	10 e0       	ldi	r17, 0x00	; 0
    702e:	51 2c       	mov	r5, r1
    7030:	20 e0       	ldi	r18, 0x00	; 0
    7032:	20 32       	cpi	r18, 0x20	; 32
    7034:	a0 f4       	brcc	.+40     	; 0x705e <vfprintf+0xb6>
    7036:	8b 32       	cpi	r24, 0x2B	; 43
    7038:	69 f0       	breq	.+26     	; 0x7054 <vfprintf+0xac>
    703a:	30 f4       	brcc	.+12     	; 0x7048 <vfprintf+0xa0>
    703c:	80 32       	cpi	r24, 0x20	; 32
    703e:	59 f0       	breq	.+22     	; 0x7056 <vfprintf+0xae>
    7040:	83 32       	cpi	r24, 0x23	; 35
    7042:	69 f4       	brne	.+26     	; 0x705e <vfprintf+0xb6>
    7044:	20 61       	ori	r18, 0x10	; 16
    7046:	2c c0       	rjmp	.+88     	; 0x70a0 <vfprintf+0xf8>
    7048:	8d 32       	cpi	r24, 0x2D	; 45
    704a:	39 f0       	breq	.+14     	; 0x705a <vfprintf+0xb2>
    704c:	80 33       	cpi	r24, 0x30	; 48
    704e:	39 f4       	brne	.+14     	; 0x705e <vfprintf+0xb6>
    7050:	21 60       	ori	r18, 0x01	; 1
    7052:	26 c0       	rjmp	.+76     	; 0x70a0 <vfprintf+0xf8>
    7054:	22 60       	ori	r18, 0x02	; 2
    7056:	24 60       	ori	r18, 0x04	; 4
    7058:	23 c0       	rjmp	.+70     	; 0x70a0 <vfprintf+0xf8>
    705a:	28 60       	ori	r18, 0x08	; 8
    705c:	21 c0       	rjmp	.+66     	; 0x70a0 <vfprintf+0xf8>
    705e:	27 fd       	sbrc	r18, 7
    7060:	27 c0       	rjmp	.+78     	; 0x70b0 <vfprintf+0x108>
    7062:	30 ed       	ldi	r19, 0xD0	; 208
    7064:	38 0f       	add	r19, r24
    7066:	3a 30       	cpi	r19, 0x0A	; 10
    7068:	78 f4       	brcc	.+30     	; 0x7088 <vfprintf+0xe0>
    706a:	26 ff       	sbrs	r18, 6
    706c:	06 c0       	rjmp	.+12     	; 0x707a <vfprintf+0xd2>
    706e:	fa e0       	ldi	r31, 0x0A	; 10
    7070:	1f 9f       	mul	r17, r31
    7072:	30 0d       	add	r19, r0
    7074:	11 24       	eor	r1, r1
    7076:	13 2f       	mov	r17, r19
    7078:	13 c0       	rjmp	.+38     	; 0x70a0 <vfprintf+0xf8>
    707a:	6a e0       	ldi	r22, 0x0A	; 10
    707c:	56 9e       	mul	r5, r22
    707e:	30 0d       	add	r19, r0
    7080:	11 24       	eor	r1, r1
    7082:	53 2e       	mov	r5, r19
    7084:	20 62       	ori	r18, 0x20	; 32
    7086:	0c c0       	rjmp	.+24     	; 0x70a0 <vfprintf+0xf8>
    7088:	8e 32       	cpi	r24, 0x2E	; 46
    708a:	21 f4       	brne	.+8      	; 0x7094 <vfprintf+0xec>
    708c:	26 fd       	sbrc	r18, 6
    708e:	11 c3       	rjmp	.+1570   	; 0x76b2 <vfprintf+0x70a>
    7090:	20 64       	ori	r18, 0x40	; 64
    7092:	06 c0       	rjmp	.+12     	; 0x70a0 <vfprintf+0xf8>
    7094:	8c 36       	cpi	r24, 0x6C	; 108
    7096:	11 f4       	brne	.+4      	; 0x709c <vfprintf+0xf4>
    7098:	20 68       	ori	r18, 0x80	; 128
    709a:	02 c0       	rjmp	.+4      	; 0x70a0 <vfprintf+0xf8>
    709c:	88 36       	cpi	r24, 0x68	; 104
    709e:	41 f4       	brne	.+16     	; 0x70b0 <vfprintf+0x108>
    70a0:	f1 01       	movw	r30, r2
    70a2:	93 fd       	sbrc	r25, 3
    70a4:	85 91       	lpm	r24, Z+
    70a6:	93 ff       	sbrs	r25, 3
    70a8:	81 91       	ld	r24, Z+
    70aa:	1f 01       	movw	r2, r30
    70ac:	81 11       	cpse	r24, r1
    70ae:	c1 cf       	rjmp	.-126    	; 0x7032 <vfprintf+0x8a>
    70b0:	9b eb       	ldi	r25, 0xBB	; 187
    70b2:	98 0f       	add	r25, r24
    70b4:	93 30       	cpi	r25, 0x03	; 3
    70b6:	18 f4       	brcc	.+6      	; 0x70be <vfprintf+0x116>
    70b8:	20 61       	ori	r18, 0x10	; 16
    70ba:	80 5e       	subi	r24, 0xE0	; 224
    70bc:	06 c0       	rjmp	.+12     	; 0x70ca <vfprintf+0x122>
    70be:	9b e9       	ldi	r25, 0x9B	; 155
    70c0:	98 0f       	add	r25, r24
    70c2:	93 30       	cpi	r25, 0x03	; 3
    70c4:	08 f0       	brcs	.+2      	; 0x70c8 <vfprintf+0x120>
    70c6:	aa c1       	rjmp	.+852    	; 0x741c <vfprintf+0x474>
    70c8:	2f 7e       	andi	r18, 0xEF	; 239
    70ca:	26 ff       	sbrs	r18, 6
    70cc:	16 e0       	ldi	r17, 0x06	; 6
    70ce:	2f 73       	andi	r18, 0x3F	; 63
    70d0:	72 2e       	mov	r7, r18
    70d2:	85 36       	cpi	r24, 0x65	; 101
    70d4:	21 f4       	brne	.+8      	; 0x70de <vfprintf+0x136>
    70d6:	f2 2f       	mov	r31, r18
    70d8:	f0 64       	ori	r31, 0x40	; 64
    70da:	7f 2e       	mov	r7, r31
    70dc:	08 c0       	rjmp	.+16     	; 0x70ee <vfprintf+0x146>
    70de:	86 36       	cpi	r24, 0x66	; 102
    70e0:	21 f4       	brne	.+8      	; 0x70ea <vfprintf+0x142>
    70e2:	62 2f       	mov	r22, r18
    70e4:	60 68       	ori	r22, 0x80	; 128
    70e6:	76 2e       	mov	r7, r22
    70e8:	02 c0       	rjmp	.+4      	; 0x70ee <vfprintf+0x146>
    70ea:	11 11       	cpse	r17, r1
    70ec:	11 50       	subi	r17, 0x01	; 1
    70ee:	77 fe       	sbrs	r7, 7
    70f0:	07 c0       	rjmp	.+14     	; 0x7100 <vfprintf+0x158>
    70f2:	1c 33       	cpi	r17, 0x3C	; 60
    70f4:	48 f4       	brcc	.+18     	; 0x7108 <vfprintf+0x160>
    70f6:	44 24       	eor	r4, r4
    70f8:	43 94       	inc	r4
    70fa:	41 0e       	add	r4, r17
    70fc:	27 e0       	ldi	r18, 0x07	; 7
    70fe:	0b c0       	rjmp	.+22     	; 0x7116 <vfprintf+0x16e>
    7100:	18 30       	cpi	r17, 0x08	; 8
    7102:	30 f4       	brcc	.+12     	; 0x7110 <vfprintf+0x168>
    7104:	21 2f       	mov	r18, r17
    7106:	06 c0       	rjmp	.+12     	; 0x7114 <vfprintf+0x16c>
    7108:	27 e0       	ldi	r18, 0x07	; 7
    710a:	4c e3       	ldi	r20, 0x3C	; 60
    710c:	44 2e       	mov	r4, r20
    710e:	03 c0       	rjmp	.+6      	; 0x7116 <vfprintf+0x16e>
    7110:	27 e0       	ldi	r18, 0x07	; 7
    7112:	17 e0       	ldi	r17, 0x07	; 7
    7114:	41 2c       	mov	r4, r1
    7116:	56 01       	movw	r10, r12
    7118:	74 e0       	ldi	r23, 0x04	; 4
    711a:	a7 0e       	add	r10, r23
    711c:	b1 1c       	adc	r11, r1
    711e:	f6 01       	movw	r30, r12
    7120:	60 81       	ld	r22, Z
    7122:	71 81       	ldd	r23, Z+1	; 0x01
    7124:	82 81       	ldd	r24, Z+2	; 0x02
    7126:	93 81       	ldd	r25, Z+3	; 0x03
    7128:	04 2d       	mov	r16, r4
    712a:	a4 01       	movw	r20, r8
    712c:	0e 94 c2 3c 	call	0x7984	; 0x7984 <__ftoa_engine>
    7130:	6c 01       	movw	r12, r24
    7132:	09 81       	ldd	r16, Y+1	; 0x01
    7134:	00 ff       	sbrs	r16, 0
    7136:	02 c0       	rjmp	.+4      	; 0x713c <vfprintf+0x194>
    7138:	03 ff       	sbrs	r16, 3
    713a:	06 c0       	rjmp	.+12     	; 0x7148 <vfprintf+0x1a0>
    713c:	71 fc       	sbrc	r7, 1
    713e:	07 c0       	rjmp	.+14     	; 0x714e <vfprintf+0x1a6>
    7140:	72 fc       	sbrc	r7, 2
    7142:	08 c0       	rjmp	.+16     	; 0x7154 <vfprintf+0x1ac>
    7144:	61 2c       	mov	r6, r1
    7146:	08 c0       	rjmp	.+16     	; 0x7158 <vfprintf+0x1b0>
    7148:	3d e2       	ldi	r19, 0x2D	; 45
    714a:	63 2e       	mov	r6, r19
    714c:	05 c0       	rjmp	.+10     	; 0x7158 <vfprintf+0x1b0>
    714e:	2b e2       	ldi	r18, 0x2B	; 43
    7150:	62 2e       	mov	r6, r18
    7152:	02 c0       	rjmp	.+4      	; 0x7158 <vfprintf+0x1b0>
    7154:	90 e2       	ldi	r25, 0x20	; 32
    7156:	69 2e       	mov	r6, r25
    7158:	80 2f       	mov	r24, r16
    715a:	8c 70       	andi	r24, 0x0C	; 12
    715c:	99 f1       	breq	.+102    	; 0x71c4 <vfprintf+0x21c>
    715e:	66 20       	and	r6, r6
    7160:	11 f0       	breq	.+4      	; 0x7166 <vfprintf+0x1be>
    7162:	84 e0       	ldi	r24, 0x04	; 4
    7164:	01 c0       	rjmp	.+2      	; 0x7168 <vfprintf+0x1c0>
    7166:	83 e0       	ldi	r24, 0x03	; 3
    7168:	85 15       	cp	r24, r5
    716a:	10 f0       	brcs	.+4      	; 0x7170 <vfprintf+0x1c8>
    716c:	51 2c       	mov	r5, r1
    716e:	0b c0       	rjmp	.+22     	; 0x7186 <vfprintf+0x1de>
    7170:	58 1a       	sub	r5, r24
    7172:	73 fc       	sbrc	r7, 3
    7174:	08 c0       	rjmp	.+16     	; 0x7186 <vfprintf+0x1de>
    7176:	b7 01       	movw	r22, r14
    7178:	80 e2       	ldi	r24, 0x20	; 32
    717a:	90 e0       	ldi	r25, 0x00	; 0
    717c:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7180:	5a 94       	dec	r5
    7182:	c9 f7       	brne	.-14     	; 0x7176 <vfprintf+0x1ce>
    7184:	f3 cf       	rjmp	.-26     	; 0x716c <vfprintf+0x1c4>
    7186:	66 20       	and	r6, r6
    7188:	29 f0       	breq	.+10     	; 0x7194 <vfprintf+0x1ec>
    718a:	b7 01       	movw	r22, r14
    718c:	86 2d       	mov	r24, r6
    718e:	90 e0       	ldi	r25, 0x00	; 0
    7190:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7194:	03 fd       	sbrc	r16, 3
    7196:	03 c0       	rjmp	.+6      	; 0x719e <vfprintf+0x1f6>
    7198:	0a e3       	ldi	r16, 0x3A	; 58
    719a:	16 e1       	ldi	r17, 0x16	; 22
    719c:	02 c0       	rjmp	.+4      	; 0x71a2 <vfprintf+0x1fa>
    719e:	06 e3       	ldi	r16, 0x36	; 54
    71a0:	16 e1       	ldi	r17, 0x16	; 22
    71a2:	f7 2d       	mov	r31, r7
    71a4:	f0 71       	andi	r31, 0x10	; 16
    71a6:	7f 2e       	mov	r7, r31
    71a8:	f8 01       	movw	r30, r16
    71aa:	84 91       	lpm	r24, Z
    71ac:	88 23       	and	r24, r24
    71ae:	09 f4       	brne	.+2      	; 0x71b2 <vfprintf+0x20a>
    71b0:	76 c2       	rjmp	.+1260   	; 0x769e <vfprintf+0x6f6>
    71b2:	71 10       	cpse	r7, r1
    71b4:	80 52       	subi	r24, 0x20	; 32
    71b6:	b7 01       	movw	r22, r14
    71b8:	90 e0       	ldi	r25, 0x00	; 0
    71ba:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    71be:	0f 5f       	subi	r16, 0xFF	; 255
    71c0:	1f 4f       	sbci	r17, 0xFF	; 255
    71c2:	f2 cf       	rjmp	.-28     	; 0x71a8 <vfprintf+0x200>
    71c4:	77 fe       	sbrs	r7, 7
    71c6:	0f c0       	rjmp	.+30     	; 0x71e6 <vfprintf+0x23e>
    71c8:	4c 0c       	add	r4, r12
    71ca:	04 ff       	sbrs	r16, 4
    71cc:	04 c0       	rjmp	.+8      	; 0x71d6 <vfprintf+0x22e>
    71ce:	8a 81       	ldd	r24, Y+2	; 0x02
    71d0:	81 33       	cpi	r24, 0x31	; 49
    71d2:	09 f4       	brne	.+2      	; 0x71d6 <vfprintf+0x22e>
    71d4:	4a 94       	dec	r4
    71d6:	14 14       	cp	r1, r4
    71d8:	74 f5       	brge	.+92     	; 0x7236 <vfprintf+0x28e>
    71da:	f8 e0       	ldi	r31, 0x08	; 8
    71dc:	f4 15       	cp	r31, r4
    71de:	78 f5       	brcc	.+94     	; 0x723e <vfprintf+0x296>
    71e0:	88 e0       	ldi	r24, 0x08	; 8
    71e2:	48 2e       	mov	r4, r24
    71e4:	2c c0       	rjmp	.+88     	; 0x723e <vfprintf+0x296>
    71e6:	76 fc       	sbrc	r7, 6
    71e8:	2a c0       	rjmp	.+84     	; 0x723e <vfprintf+0x296>
    71ea:	81 2f       	mov	r24, r17
    71ec:	90 e0       	ldi	r25, 0x00	; 0
    71ee:	8c 15       	cp	r24, r12
    71f0:	9d 05       	cpc	r25, r13
    71f2:	9c f0       	brlt	.+38     	; 0x721a <vfprintf+0x272>
    71f4:	6c ef       	ldi	r22, 0xFC	; 252
    71f6:	c6 16       	cp	r12, r22
    71f8:	6f ef       	ldi	r22, 0xFF	; 255
    71fa:	d6 06       	cpc	r13, r22
    71fc:	74 f0       	brlt	.+28     	; 0x721a <vfprintf+0x272>
    71fe:	77 2d       	mov	r23, r7
    7200:	70 68       	ori	r23, 0x80	; 128
    7202:	77 2e       	mov	r7, r23
    7204:	0a c0       	rjmp	.+20     	; 0x721a <vfprintf+0x272>
    7206:	e2 e0       	ldi	r30, 0x02	; 2
    7208:	f0 e0       	ldi	r31, 0x00	; 0
    720a:	ec 0f       	add	r30, r28
    720c:	fd 1f       	adc	r31, r29
    720e:	e1 0f       	add	r30, r17
    7210:	f1 1d       	adc	r31, r1
    7212:	80 81       	ld	r24, Z
    7214:	80 33       	cpi	r24, 0x30	; 48
    7216:	19 f4       	brne	.+6      	; 0x721e <vfprintf+0x276>
    7218:	11 50       	subi	r17, 0x01	; 1
    721a:	11 11       	cpse	r17, r1
    721c:	f4 cf       	rjmp	.-24     	; 0x7206 <vfprintf+0x25e>
    721e:	77 fe       	sbrs	r7, 7
    7220:	0e c0       	rjmp	.+28     	; 0x723e <vfprintf+0x296>
    7222:	44 24       	eor	r4, r4
    7224:	43 94       	inc	r4
    7226:	41 0e       	add	r4, r17
    7228:	81 2f       	mov	r24, r17
    722a:	90 e0       	ldi	r25, 0x00	; 0
    722c:	c8 16       	cp	r12, r24
    722e:	d9 06       	cpc	r13, r25
    7230:	2c f4       	brge	.+10     	; 0x723c <vfprintf+0x294>
    7232:	1c 19       	sub	r17, r12
    7234:	04 c0       	rjmp	.+8      	; 0x723e <vfprintf+0x296>
    7236:	44 24       	eor	r4, r4
    7238:	43 94       	inc	r4
    723a:	01 c0       	rjmp	.+2      	; 0x723e <vfprintf+0x296>
    723c:	10 e0       	ldi	r17, 0x00	; 0
    723e:	77 fe       	sbrs	r7, 7
    7240:	07 c0       	rjmp	.+14     	; 0x7250 <vfprintf+0x2a8>
    7242:	1c 14       	cp	r1, r12
    7244:	1d 04       	cpc	r1, r13
    7246:	3c f4       	brge	.+14     	; 0x7256 <vfprintf+0x2ae>
    7248:	96 01       	movw	r18, r12
    724a:	2f 5f       	subi	r18, 0xFF	; 255
    724c:	3f 4f       	sbci	r19, 0xFF	; 255
    724e:	05 c0       	rjmp	.+10     	; 0x725a <vfprintf+0x2b2>
    7250:	25 e0       	ldi	r18, 0x05	; 5
    7252:	30 e0       	ldi	r19, 0x00	; 0
    7254:	02 c0       	rjmp	.+4      	; 0x725a <vfprintf+0x2b2>
    7256:	21 e0       	ldi	r18, 0x01	; 1
    7258:	30 e0       	ldi	r19, 0x00	; 0
    725a:	66 20       	and	r6, r6
    725c:	11 f0       	breq	.+4      	; 0x7262 <vfprintf+0x2ba>
    725e:	2f 5f       	subi	r18, 0xFF	; 255
    7260:	3f 4f       	sbci	r19, 0xFF	; 255
    7262:	11 23       	and	r17, r17
    7264:	31 f0       	breq	.+12     	; 0x7272 <vfprintf+0x2ca>
    7266:	41 2f       	mov	r20, r17
    7268:	50 e0       	ldi	r21, 0x00	; 0
    726a:	4f 5f       	subi	r20, 0xFF	; 255
    726c:	5f 4f       	sbci	r21, 0xFF	; 255
    726e:	24 0f       	add	r18, r20
    7270:	35 1f       	adc	r19, r21
    7272:	45 2d       	mov	r20, r5
    7274:	50 e0       	ldi	r21, 0x00	; 0
    7276:	24 17       	cp	r18, r20
    7278:	35 07       	cpc	r19, r21
    727a:	14 f4       	brge	.+4      	; 0x7280 <vfprintf+0x2d8>
    727c:	52 1a       	sub	r5, r18
    727e:	01 c0       	rjmp	.+2      	; 0x7282 <vfprintf+0x2da>
    7280:	51 2c       	mov	r5, r1
    7282:	87 2d       	mov	r24, r7
    7284:	89 70       	andi	r24, 0x09	; 9
    7286:	49 f4       	brne	.+18     	; 0x729a <vfprintf+0x2f2>
    7288:	55 20       	and	r5, r5
    728a:	39 f0       	breq	.+14     	; 0x729a <vfprintf+0x2f2>
    728c:	b7 01       	movw	r22, r14
    728e:	80 e2       	ldi	r24, 0x20	; 32
    7290:	90 e0       	ldi	r25, 0x00	; 0
    7292:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7296:	5a 94       	dec	r5
    7298:	f7 cf       	rjmp	.-18     	; 0x7288 <vfprintf+0x2e0>
    729a:	66 20       	and	r6, r6
    729c:	29 f0       	breq	.+10     	; 0x72a8 <vfprintf+0x300>
    729e:	b7 01       	movw	r22, r14
    72a0:	86 2d       	mov	r24, r6
    72a2:	90 e0       	ldi	r25, 0x00	; 0
    72a4:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    72a8:	73 fc       	sbrc	r7, 3
    72aa:	09 c0       	rjmp	.+18     	; 0x72be <vfprintf+0x316>
    72ac:	55 20       	and	r5, r5
    72ae:	39 f0       	breq	.+14     	; 0x72be <vfprintf+0x316>
    72b0:	b7 01       	movw	r22, r14
    72b2:	80 e3       	ldi	r24, 0x30	; 48
    72b4:	90 e0       	ldi	r25, 0x00	; 0
    72b6:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    72ba:	5a 94       	dec	r5
    72bc:	f7 cf       	rjmp	.-18     	; 0x72ac <vfprintf+0x304>
    72be:	77 fe       	sbrs	r7, 7
    72c0:	5f c0       	rjmp	.+190    	; 0x7380 <vfprintf+0x3d8>
    72c2:	9c 2d       	mov	r25, r12
    72c4:	8d 2d       	mov	r24, r13
    72c6:	d7 fe       	sbrs	r13, 7
    72c8:	02 c0       	rjmp	.+4      	; 0x72ce <vfprintf+0x326>
    72ca:	90 e0       	ldi	r25, 0x00	; 0
    72cc:	80 e0       	ldi	r24, 0x00	; 0
    72ce:	69 2e       	mov	r6, r25
    72d0:	78 2e       	mov	r7, r24
    72d2:	40 e0       	ldi	r20, 0x00	; 0
    72d4:	50 e0       	ldi	r21, 0x00	; 0
    72d6:	c6 01       	movw	r24, r12
    72d8:	84 19       	sub	r24, r4
    72da:	91 09       	sbc	r25, r1
    72dc:	9d 87       	std	Y+13, r25	; 0x0d
    72de:	8c 87       	std	Y+12, r24	; 0x0c
    72e0:	96 01       	movw	r18, r12
    72e2:	26 19       	sub	r18, r6
    72e4:	37 09       	sbc	r19, r7
    72e6:	28 0d       	add	r18, r8
    72e8:	39 1d       	adc	r19, r9
    72ea:	81 2f       	mov	r24, r17
    72ec:	90 e0       	ldi	r25, 0x00	; 0
    72ee:	ee 27       	eor	r30, r30
    72f0:	ff 27       	eor	r31, r31
    72f2:	e8 1b       	sub	r30, r24
    72f4:	f9 0b       	sbc	r31, r25
    72f6:	ff 87       	std	Y+15, r31	; 0x0f
    72f8:	ee 87       	std	Y+14, r30	; 0x0e
    72fa:	ff ef       	ldi	r31, 0xFF	; 255
    72fc:	6f 16       	cp	r6, r31
    72fe:	7f 06       	cpc	r7, r31
    7300:	69 f4       	brne	.+26     	; 0x731c <vfprintf+0x374>
    7302:	b7 01       	movw	r22, r14
    7304:	8e e2       	ldi	r24, 0x2E	; 46
    7306:	90 e0       	ldi	r25, 0x00	; 0
    7308:	2b 8b       	std	Y+19, r18	; 0x13
    730a:	3a 8b       	std	Y+18, r19	; 0x12
    730c:	48 8b       	std	Y+16, r20	; 0x10
    730e:	59 8b       	std	Y+17, r21	; 0x11
    7310:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7314:	59 89       	ldd	r21, Y+17	; 0x11
    7316:	48 89       	ldd	r20, Y+16	; 0x10
    7318:	3a 89       	ldd	r19, Y+18	; 0x12
    731a:	2b 89       	ldd	r18, Y+19	; 0x13
    731c:	c6 14       	cp	r12, r6
    731e:	d7 04       	cpc	r13, r7
    7320:	54 f0       	brlt	.+20     	; 0x7336 <vfprintf+0x38e>
    7322:	6c 85       	ldd	r22, Y+12	; 0x0c
    7324:	7d 85       	ldd	r23, Y+13	; 0x0d
    7326:	66 15       	cp	r22, r6
    7328:	77 05       	cpc	r23, r7
    732a:	2c f4       	brge	.+10     	; 0x7336 <vfprintf+0x38e>
    732c:	f9 01       	movw	r30, r18
    732e:	e4 0f       	add	r30, r20
    7330:	f5 1f       	adc	r31, r21
    7332:	81 81       	ldd	r24, Z+1	; 0x01
    7334:	01 c0       	rjmp	.+2      	; 0x7338 <vfprintf+0x390>
    7336:	80 e3       	ldi	r24, 0x30	; 48
    7338:	71 e0       	ldi	r23, 0x01	; 1
    733a:	67 1a       	sub	r6, r23
    733c:	71 08       	sbc	r7, r1
    733e:	4f 5f       	subi	r20, 0xFF	; 255
    7340:	5f 4f       	sbci	r21, 0xFF	; 255
    7342:	ee 85       	ldd	r30, Y+14	; 0x0e
    7344:	ff 85       	ldd	r31, Y+15	; 0x0f
    7346:	6e 16       	cp	r6, r30
    7348:	7f 06       	cpc	r7, r31
    734a:	6c f0       	brlt	.+26     	; 0x7366 <vfprintf+0x3be>
    734c:	b7 01       	movw	r22, r14
    734e:	90 e0       	ldi	r25, 0x00	; 0
    7350:	2b 8b       	std	Y+19, r18	; 0x13
    7352:	3a 8b       	std	Y+18, r19	; 0x12
    7354:	48 8b       	std	Y+16, r20	; 0x10
    7356:	59 8b       	std	Y+17, r21	; 0x11
    7358:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    735c:	2b 89       	ldd	r18, Y+19	; 0x13
    735e:	3a 89       	ldd	r19, Y+18	; 0x12
    7360:	48 89       	ldd	r20, Y+16	; 0x10
    7362:	59 89       	ldd	r21, Y+17	; 0x11
    7364:	ca cf       	rjmp	.-108    	; 0x72fa <vfprintf+0x352>
    7366:	6c 14       	cp	r6, r12
    7368:	7d 04       	cpc	r7, r13
    736a:	39 f4       	brne	.+14     	; 0x737a <vfprintf+0x3d2>
    736c:	9a 81       	ldd	r25, Y+2	; 0x02
    736e:	96 33       	cpi	r25, 0x36	; 54
    7370:	18 f4       	brcc	.+6      	; 0x7378 <vfprintf+0x3d0>
    7372:	95 33       	cpi	r25, 0x35	; 53
    7374:	11 f4       	brne	.+4      	; 0x737a <vfprintf+0x3d2>
    7376:	04 ff       	sbrs	r16, 4
    7378:	81 e3       	ldi	r24, 0x31	; 49
    737a:	b7 01       	movw	r22, r14
    737c:	90 e0       	ldi	r25, 0x00	; 0
    737e:	4b c0       	rjmp	.+150    	; 0x7416 <vfprintf+0x46e>
    7380:	8a 81       	ldd	r24, Y+2	; 0x02
    7382:	81 33       	cpi	r24, 0x31	; 49
    7384:	09 f0       	breq	.+2      	; 0x7388 <vfprintf+0x3e0>
    7386:	0f 7e       	andi	r16, 0xEF	; 239
    7388:	b7 01       	movw	r22, r14
    738a:	90 e0       	ldi	r25, 0x00	; 0
    738c:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7390:	11 11       	cpse	r17, r1
    7392:	05 c0       	rjmp	.+10     	; 0x739e <vfprintf+0x3f6>
    7394:	74 fe       	sbrs	r7, 4
    7396:	18 c0       	rjmp	.+48     	; 0x73c8 <vfprintf+0x420>
    7398:	85 e4       	ldi	r24, 0x45	; 69
    739a:	90 e0       	ldi	r25, 0x00	; 0
    739c:	17 c0       	rjmp	.+46     	; 0x73cc <vfprintf+0x424>
    739e:	b7 01       	movw	r22, r14
    73a0:	8e e2       	ldi	r24, 0x2E	; 46
    73a2:	90 e0       	ldi	r25, 0x00	; 0
    73a4:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    73a8:	82 e0       	ldi	r24, 0x02	; 2
    73aa:	66 24       	eor	r6, r6
    73ac:	63 94       	inc	r6
    73ae:	68 0e       	add	r6, r24
    73b0:	f4 01       	movw	r30, r8
    73b2:	e8 0f       	add	r30, r24
    73b4:	f1 1d       	adc	r31, r1
    73b6:	80 81       	ld	r24, Z
    73b8:	b7 01       	movw	r22, r14
    73ba:	90 e0       	ldi	r25, 0x00	; 0
    73bc:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    73c0:	11 50       	subi	r17, 0x01	; 1
    73c2:	41 f3       	breq	.-48     	; 0x7394 <vfprintf+0x3ec>
    73c4:	86 2d       	mov	r24, r6
    73c6:	f1 cf       	rjmp	.-30     	; 0x73aa <vfprintf+0x402>
    73c8:	85 e6       	ldi	r24, 0x65	; 101
    73ca:	90 e0       	ldi	r25, 0x00	; 0
    73cc:	b7 01       	movw	r22, r14
    73ce:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    73d2:	d7 fc       	sbrc	r13, 7
    73d4:	05 c0       	rjmp	.+10     	; 0x73e0 <vfprintf+0x438>
    73d6:	c1 14       	cp	r12, r1
    73d8:	d1 04       	cpc	r13, r1
    73da:	39 f4       	brne	.+14     	; 0x73ea <vfprintf+0x442>
    73dc:	04 ff       	sbrs	r16, 4
    73de:	05 c0       	rjmp	.+10     	; 0x73ea <vfprintf+0x442>
    73e0:	d1 94       	neg	r13
    73e2:	c1 94       	neg	r12
    73e4:	d1 08       	sbc	r13, r1
    73e6:	8d e2       	ldi	r24, 0x2D	; 45
    73e8:	01 c0       	rjmp	.+2      	; 0x73ec <vfprintf+0x444>
    73ea:	8b e2       	ldi	r24, 0x2B	; 43
    73ec:	b7 01       	movw	r22, r14
    73ee:	90 e0       	ldi	r25, 0x00	; 0
    73f0:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    73f4:	80 e3       	ldi	r24, 0x30	; 48
    73f6:	6a e0       	ldi	r22, 0x0A	; 10
    73f8:	c6 16       	cp	r12, r22
    73fa:	d1 04       	cpc	r13, r1
    73fc:	2c f0       	brlt	.+10     	; 0x7408 <vfprintf+0x460>
    73fe:	8f 5f       	subi	r24, 0xFF	; 255
    7400:	fa e0       	ldi	r31, 0x0A	; 10
    7402:	cf 1a       	sub	r12, r31
    7404:	d1 08       	sbc	r13, r1
    7406:	f7 cf       	rjmp	.-18     	; 0x73f6 <vfprintf+0x44e>
    7408:	b7 01       	movw	r22, r14
    740a:	90 e0       	ldi	r25, 0x00	; 0
    740c:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7410:	b7 01       	movw	r22, r14
    7412:	c6 01       	movw	r24, r12
    7414:	c0 96       	adiw	r24, 0x30	; 48
    7416:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    741a:	41 c1       	rjmp	.+642    	; 0x769e <vfprintf+0x6f6>
    741c:	83 36       	cpi	r24, 0x63	; 99
    741e:	31 f0       	breq	.+12     	; 0x742c <vfprintf+0x484>
    7420:	83 37       	cpi	r24, 0x73	; 115
    7422:	79 f0       	breq	.+30     	; 0x7442 <vfprintf+0x49a>
    7424:	83 35       	cpi	r24, 0x53	; 83
    7426:	09 f0       	breq	.+2      	; 0x742a <vfprintf+0x482>
    7428:	58 c0       	rjmp	.+176    	; 0x74da <vfprintf+0x532>
    742a:	21 c0       	rjmp	.+66     	; 0x746e <vfprintf+0x4c6>
    742c:	56 01       	movw	r10, r12
    742e:	72 e0       	ldi	r23, 0x02	; 2
    7430:	a7 0e       	add	r10, r23
    7432:	b1 1c       	adc	r11, r1
    7434:	f6 01       	movw	r30, r12
    7436:	80 81       	ld	r24, Z
    7438:	89 83       	std	Y+1, r24	; 0x01
    743a:	01 e0       	ldi	r16, 0x01	; 1
    743c:	10 e0       	ldi	r17, 0x00	; 0
    743e:	64 01       	movw	r12, r8
    7440:	14 c0       	rjmp	.+40     	; 0x746a <vfprintf+0x4c2>
    7442:	56 01       	movw	r10, r12
    7444:	f2 e0       	ldi	r31, 0x02	; 2
    7446:	af 0e       	add	r10, r31
    7448:	b1 1c       	adc	r11, r1
    744a:	f6 01       	movw	r30, r12
    744c:	c0 80       	ld	r12, Z
    744e:	d1 80       	ldd	r13, Z+1	; 0x01
    7450:	26 ff       	sbrs	r18, 6
    7452:	03 c0       	rjmp	.+6      	; 0x745a <vfprintf+0x4b2>
    7454:	61 2f       	mov	r22, r17
    7456:	70 e0       	ldi	r23, 0x00	; 0
    7458:	02 c0       	rjmp	.+4      	; 0x745e <vfprintf+0x4b6>
    745a:	6f ef       	ldi	r22, 0xFF	; 255
    745c:	7f ef       	ldi	r23, 0xFF	; 255
    745e:	c6 01       	movw	r24, r12
    7460:	2b 8b       	std	Y+19, r18	; 0x13
    7462:	0e 94 05 3e 	call	0x7c0a	; 0x7c0a <strnlen>
    7466:	8c 01       	movw	r16, r24
    7468:	2b 89       	ldd	r18, Y+19	; 0x13
    746a:	2f 77       	andi	r18, 0x7F	; 127
    746c:	15 c0       	rjmp	.+42     	; 0x7498 <vfprintf+0x4f0>
    746e:	56 01       	movw	r10, r12
    7470:	f2 e0       	ldi	r31, 0x02	; 2
    7472:	af 0e       	add	r10, r31
    7474:	b1 1c       	adc	r11, r1
    7476:	f6 01       	movw	r30, r12
    7478:	c0 80       	ld	r12, Z
    747a:	d1 80       	ldd	r13, Z+1	; 0x01
    747c:	26 ff       	sbrs	r18, 6
    747e:	03 c0       	rjmp	.+6      	; 0x7486 <vfprintf+0x4de>
    7480:	61 2f       	mov	r22, r17
    7482:	70 e0       	ldi	r23, 0x00	; 0
    7484:	02 c0       	rjmp	.+4      	; 0x748a <vfprintf+0x4e2>
    7486:	6f ef       	ldi	r22, 0xFF	; 255
    7488:	7f ef       	ldi	r23, 0xFF	; 255
    748a:	c6 01       	movw	r24, r12
    748c:	2b 8b       	std	Y+19, r18	; 0x13
    748e:	0e 94 a8 3d 	call	0x7b50	; 0x7b50 <strnlen_P>
    7492:	8c 01       	movw	r16, r24
    7494:	2b 89       	ldd	r18, Y+19	; 0x13
    7496:	20 68       	ori	r18, 0x80	; 128
    7498:	72 2e       	mov	r7, r18
    749a:	23 fd       	sbrc	r18, 3
    749c:	1a c0       	rjmp	.+52     	; 0x74d2 <vfprintf+0x52a>
    749e:	85 2d       	mov	r24, r5
    74a0:	90 e0       	ldi	r25, 0x00	; 0
    74a2:	08 17       	cp	r16, r24
    74a4:	19 07       	cpc	r17, r25
    74a6:	a8 f4       	brcc	.+42     	; 0x74d2 <vfprintf+0x52a>
    74a8:	b7 01       	movw	r22, r14
    74aa:	80 e2       	ldi	r24, 0x20	; 32
    74ac:	90 e0       	ldi	r25, 0x00	; 0
    74ae:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    74b2:	5a 94       	dec	r5
    74b4:	f4 cf       	rjmp	.-24     	; 0x749e <vfprintf+0x4f6>
    74b6:	f6 01       	movw	r30, r12
    74b8:	77 fc       	sbrc	r7, 7
    74ba:	85 91       	lpm	r24, Z+
    74bc:	77 fe       	sbrs	r7, 7
    74be:	81 91       	ld	r24, Z+
    74c0:	6f 01       	movw	r12, r30
    74c2:	b7 01       	movw	r22, r14
    74c4:	90 e0       	ldi	r25, 0x00	; 0
    74c6:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    74ca:	51 10       	cpse	r5, r1
    74cc:	5a 94       	dec	r5
    74ce:	01 50       	subi	r16, 0x01	; 1
    74d0:	11 09       	sbc	r17, r1
    74d2:	01 15       	cp	r16, r1
    74d4:	11 05       	cpc	r17, r1
    74d6:	79 f7       	brne	.-34     	; 0x74b6 <vfprintf+0x50e>
    74d8:	e2 c0       	rjmp	.+452    	; 0x769e <vfprintf+0x6f6>
    74da:	84 36       	cpi	r24, 0x64	; 100
    74dc:	11 f0       	breq	.+4      	; 0x74e2 <vfprintf+0x53a>
    74de:	89 36       	cpi	r24, 0x69	; 105
    74e0:	51 f5       	brne	.+84     	; 0x7536 <vfprintf+0x58e>
    74e2:	56 01       	movw	r10, r12
    74e4:	27 ff       	sbrs	r18, 7
    74e6:	09 c0       	rjmp	.+18     	; 0x74fa <vfprintf+0x552>
    74e8:	f4 e0       	ldi	r31, 0x04	; 4
    74ea:	af 0e       	add	r10, r31
    74ec:	b1 1c       	adc	r11, r1
    74ee:	f6 01       	movw	r30, r12
    74f0:	60 81       	ld	r22, Z
    74f2:	71 81       	ldd	r23, Z+1	; 0x01
    74f4:	82 81       	ldd	r24, Z+2	; 0x02
    74f6:	93 81       	ldd	r25, Z+3	; 0x03
    74f8:	0a c0       	rjmp	.+20     	; 0x750e <vfprintf+0x566>
    74fa:	f2 e0       	ldi	r31, 0x02	; 2
    74fc:	af 0e       	add	r10, r31
    74fe:	b1 1c       	adc	r11, r1
    7500:	f6 01       	movw	r30, r12
    7502:	60 81       	ld	r22, Z
    7504:	71 81       	ldd	r23, Z+1	; 0x01
    7506:	88 27       	eor	r24, r24
    7508:	77 fd       	sbrc	r23, 7
    750a:	80 95       	com	r24
    750c:	98 2f       	mov	r25, r24
    750e:	02 2f       	mov	r16, r18
    7510:	0f 76       	andi	r16, 0x6F	; 111
    7512:	97 ff       	sbrs	r25, 7
    7514:	08 c0       	rjmp	.+16     	; 0x7526 <vfprintf+0x57e>
    7516:	90 95       	com	r25
    7518:	80 95       	com	r24
    751a:	70 95       	com	r23
    751c:	61 95       	neg	r22
    751e:	7f 4f       	sbci	r23, 0xFF	; 255
    7520:	8f 4f       	sbci	r24, 0xFF	; 255
    7522:	9f 4f       	sbci	r25, 0xFF	; 255
    7524:	00 68       	ori	r16, 0x80	; 128
    7526:	2a e0       	ldi	r18, 0x0A	; 10
    7528:	30 e0       	ldi	r19, 0x00	; 0
    752a:	a4 01       	movw	r20, r8
    752c:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__ultoa_invert>
    7530:	c8 2e       	mov	r12, r24
    7532:	c8 18       	sub	r12, r8
    7534:	3e c0       	rjmp	.+124    	; 0x75b2 <vfprintf+0x60a>
    7536:	02 2f       	mov	r16, r18
    7538:	85 37       	cpi	r24, 0x75	; 117
    753a:	21 f4       	brne	.+8      	; 0x7544 <vfprintf+0x59c>
    753c:	0f 7e       	andi	r16, 0xEF	; 239
    753e:	2a e0       	ldi	r18, 0x0A	; 10
    7540:	30 e0       	ldi	r19, 0x00	; 0
    7542:	1d c0       	rjmp	.+58     	; 0x757e <vfprintf+0x5d6>
    7544:	09 7f       	andi	r16, 0xF9	; 249
    7546:	8f 36       	cpi	r24, 0x6F	; 111
    7548:	91 f0       	breq	.+36     	; 0x756e <vfprintf+0x5c6>
    754a:	18 f4       	brcc	.+6      	; 0x7552 <vfprintf+0x5aa>
    754c:	88 35       	cpi	r24, 0x58	; 88
    754e:	59 f0       	breq	.+22     	; 0x7566 <vfprintf+0x5be>
    7550:	b0 c0       	rjmp	.+352    	; 0x76b2 <vfprintf+0x70a>
    7552:	80 37       	cpi	r24, 0x70	; 112
    7554:	19 f0       	breq	.+6      	; 0x755c <vfprintf+0x5b4>
    7556:	88 37       	cpi	r24, 0x78	; 120
    7558:	11 f0       	breq	.+4      	; 0x755e <vfprintf+0x5b6>
    755a:	ab c0       	rjmp	.+342    	; 0x76b2 <vfprintf+0x70a>
    755c:	00 61       	ori	r16, 0x10	; 16
    755e:	04 ff       	sbrs	r16, 4
    7560:	09 c0       	rjmp	.+18     	; 0x7574 <vfprintf+0x5cc>
    7562:	04 60       	ori	r16, 0x04	; 4
    7564:	07 c0       	rjmp	.+14     	; 0x7574 <vfprintf+0x5cc>
    7566:	24 ff       	sbrs	r18, 4
    7568:	08 c0       	rjmp	.+16     	; 0x757a <vfprintf+0x5d2>
    756a:	06 60       	ori	r16, 0x06	; 6
    756c:	06 c0       	rjmp	.+12     	; 0x757a <vfprintf+0x5d2>
    756e:	28 e0       	ldi	r18, 0x08	; 8
    7570:	30 e0       	ldi	r19, 0x00	; 0
    7572:	05 c0       	rjmp	.+10     	; 0x757e <vfprintf+0x5d6>
    7574:	20 e1       	ldi	r18, 0x10	; 16
    7576:	30 e0       	ldi	r19, 0x00	; 0
    7578:	02 c0       	rjmp	.+4      	; 0x757e <vfprintf+0x5d6>
    757a:	20 e1       	ldi	r18, 0x10	; 16
    757c:	32 e0       	ldi	r19, 0x02	; 2
    757e:	56 01       	movw	r10, r12
    7580:	07 ff       	sbrs	r16, 7
    7582:	09 c0       	rjmp	.+18     	; 0x7596 <vfprintf+0x5ee>
    7584:	f4 e0       	ldi	r31, 0x04	; 4
    7586:	af 0e       	add	r10, r31
    7588:	b1 1c       	adc	r11, r1
    758a:	f6 01       	movw	r30, r12
    758c:	60 81       	ld	r22, Z
    758e:	71 81       	ldd	r23, Z+1	; 0x01
    7590:	82 81       	ldd	r24, Z+2	; 0x02
    7592:	93 81       	ldd	r25, Z+3	; 0x03
    7594:	08 c0       	rjmp	.+16     	; 0x75a6 <vfprintf+0x5fe>
    7596:	f2 e0       	ldi	r31, 0x02	; 2
    7598:	af 0e       	add	r10, r31
    759a:	b1 1c       	adc	r11, r1
    759c:	f6 01       	movw	r30, r12
    759e:	60 81       	ld	r22, Z
    75a0:	71 81       	ldd	r23, Z+1	; 0x01
    75a2:	80 e0       	ldi	r24, 0x00	; 0
    75a4:	90 e0       	ldi	r25, 0x00	; 0
    75a6:	a4 01       	movw	r20, r8
    75a8:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__ultoa_invert>
    75ac:	c8 2e       	mov	r12, r24
    75ae:	c8 18       	sub	r12, r8
    75b0:	0f 77       	andi	r16, 0x7F	; 127
    75b2:	06 ff       	sbrs	r16, 6
    75b4:	0b c0       	rjmp	.+22     	; 0x75cc <vfprintf+0x624>
    75b6:	20 2f       	mov	r18, r16
    75b8:	2e 7f       	andi	r18, 0xFE	; 254
    75ba:	c1 16       	cp	r12, r17
    75bc:	50 f4       	brcc	.+20     	; 0x75d2 <vfprintf+0x62a>
    75be:	04 ff       	sbrs	r16, 4
    75c0:	0a c0       	rjmp	.+20     	; 0x75d6 <vfprintf+0x62e>
    75c2:	02 fd       	sbrc	r16, 2
    75c4:	08 c0       	rjmp	.+16     	; 0x75d6 <vfprintf+0x62e>
    75c6:	20 2f       	mov	r18, r16
    75c8:	2e 7e       	andi	r18, 0xEE	; 238
    75ca:	05 c0       	rjmp	.+10     	; 0x75d6 <vfprintf+0x62e>
    75cc:	dc 2c       	mov	r13, r12
    75ce:	20 2f       	mov	r18, r16
    75d0:	03 c0       	rjmp	.+6      	; 0x75d8 <vfprintf+0x630>
    75d2:	dc 2c       	mov	r13, r12
    75d4:	01 c0       	rjmp	.+2      	; 0x75d8 <vfprintf+0x630>
    75d6:	d1 2e       	mov	r13, r17
    75d8:	24 ff       	sbrs	r18, 4
    75da:	0d c0       	rjmp	.+26     	; 0x75f6 <vfprintf+0x64e>
    75dc:	fe 01       	movw	r30, r28
    75de:	ec 0d       	add	r30, r12
    75e0:	f1 1d       	adc	r31, r1
    75e2:	80 81       	ld	r24, Z
    75e4:	80 33       	cpi	r24, 0x30	; 48
    75e6:	11 f4       	brne	.+4      	; 0x75ec <vfprintf+0x644>
    75e8:	29 7e       	andi	r18, 0xE9	; 233
    75ea:	09 c0       	rjmp	.+18     	; 0x75fe <vfprintf+0x656>
    75ec:	22 ff       	sbrs	r18, 2
    75ee:	06 c0       	rjmp	.+12     	; 0x75fc <vfprintf+0x654>
    75f0:	d3 94       	inc	r13
    75f2:	d3 94       	inc	r13
    75f4:	04 c0       	rjmp	.+8      	; 0x75fe <vfprintf+0x656>
    75f6:	82 2f       	mov	r24, r18
    75f8:	86 78       	andi	r24, 0x86	; 134
    75fa:	09 f0       	breq	.+2      	; 0x75fe <vfprintf+0x656>
    75fc:	d3 94       	inc	r13
    75fe:	23 fd       	sbrc	r18, 3
    7600:	13 c0       	rjmp	.+38     	; 0x7628 <vfprintf+0x680>
    7602:	20 ff       	sbrs	r18, 0
    7604:	06 c0       	rjmp	.+12     	; 0x7612 <vfprintf+0x66a>
    7606:	1c 2d       	mov	r17, r12
    7608:	d5 14       	cp	r13, r5
    760a:	18 f4       	brcc	.+6      	; 0x7612 <vfprintf+0x66a>
    760c:	15 0d       	add	r17, r5
    760e:	1d 19       	sub	r17, r13
    7610:	d5 2c       	mov	r13, r5
    7612:	d5 14       	cp	r13, r5
    7614:	68 f4       	brcc	.+26     	; 0x7630 <vfprintf+0x688>
    7616:	b7 01       	movw	r22, r14
    7618:	80 e2       	ldi	r24, 0x20	; 32
    761a:	90 e0       	ldi	r25, 0x00	; 0
    761c:	2b 8b       	std	Y+19, r18	; 0x13
    761e:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7622:	d3 94       	inc	r13
    7624:	2b 89       	ldd	r18, Y+19	; 0x13
    7626:	f5 cf       	rjmp	.-22     	; 0x7612 <vfprintf+0x66a>
    7628:	d5 14       	cp	r13, r5
    762a:	10 f4       	brcc	.+4      	; 0x7630 <vfprintf+0x688>
    762c:	5d 18       	sub	r5, r13
    762e:	01 c0       	rjmp	.+2      	; 0x7632 <vfprintf+0x68a>
    7630:	51 2c       	mov	r5, r1
    7632:	24 ff       	sbrs	r18, 4
    7634:	12 c0       	rjmp	.+36     	; 0x765a <vfprintf+0x6b2>
    7636:	b7 01       	movw	r22, r14
    7638:	80 e3       	ldi	r24, 0x30	; 48
    763a:	90 e0       	ldi	r25, 0x00	; 0
    763c:	2b 8b       	std	Y+19, r18	; 0x13
    763e:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7642:	2b 89       	ldd	r18, Y+19	; 0x13
    7644:	22 ff       	sbrs	r18, 2
    7646:	17 c0       	rjmp	.+46     	; 0x7676 <vfprintf+0x6ce>
    7648:	21 ff       	sbrs	r18, 1
    764a:	03 c0       	rjmp	.+6      	; 0x7652 <vfprintf+0x6aa>
    764c:	88 e5       	ldi	r24, 0x58	; 88
    764e:	90 e0       	ldi	r25, 0x00	; 0
    7650:	02 c0       	rjmp	.+4      	; 0x7656 <vfprintf+0x6ae>
    7652:	88 e7       	ldi	r24, 0x78	; 120
    7654:	90 e0       	ldi	r25, 0x00	; 0
    7656:	b7 01       	movw	r22, r14
    7658:	0c c0       	rjmp	.+24     	; 0x7672 <vfprintf+0x6ca>
    765a:	82 2f       	mov	r24, r18
    765c:	86 78       	andi	r24, 0x86	; 134
    765e:	59 f0       	breq	.+22     	; 0x7676 <vfprintf+0x6ce>
    7660:	21 fd       	sbrc	r18, 1
    7662:	02 c0       	rjmp	.+4      	; 0x7668 <vfprintf+0x6c0>
    7664:	80 e2       	ldi	r24, 0x20	; 32
    7666:	01 c0       	rjmp	.+2      	; 0x766a <vfprintf+0x6c2>
    7668:	8b e2       	ldi	r24, 0x2B	; 43
    766a:	27 fd       	sbrc	r18, 7
    766c:	8d e2       	ldi	r24, 0x2D	; 45
    766e:	b7 01       	movw	r22, r14
    7670:	90 e0       	ldi	r25, 0x00	; 0
    7672:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7676:	c1 16       	cp	r12, r17
    7678:	38 f4       	brcc	.+14     	; 0x7688 <vfprintf+0x6e0>
    767a:	b7 01       	movw	r22, r14
    767c:	80 e3       	ldi	r24, 0x30	; 48
    767e:	90 e0       	ldi	r25, 0x00	; 0
    7680:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    7684:	11 50       	subi	r17, 0x01	; 1
    7686:	f7 cf       	rjmp	.-18     	; 0x7676 <vfprintf+0x6ce>
    7688:	ca 94       	dec	r12
    768a:	f4 01       	movw	r30, r8
    768c:	ec 0d       	add	r30, r12
    768e:	f1 1d       	adc	r31, r1
    7690:	80 81       	ld	r24, Z
    7692:	b7 01       	movw	r22, r14
    7694:	90 e0       	ldi	r25, 0x00	; 0
    7696:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    769a:	c1 10       	cpse	r12, r1
    769c:	f5 cf       	rjmp	.-22     	; 0x7688 <vfprintf+0x6e0>
    769e:	55 20       	and	r5, r5
    76a0:	09 f4       	brne	.+2      	; 0x76a4 <vfprintf+0x6fc>
    76a2:	c2 cc       	rjmp	.-1660   	; 0x7028 <vfprintf+0x80>
    76a4:	b7 01       	movw	r22, r14
    76a6:	80 e2       	ldi	r24, 0x20	; 32
    76a8:	90 e0       	ldi	r25, 0x00	; 0
    76aa:	0e 94 57 3e 	call	0x7cae	; 0x7cae <fputc>
    76ae:	5a 94       	dec	r5
    76b0:	f6 cf       	rjmp	.-20     	; 0x769e <vfprintf+0x6f6>
    76b2:	f7 01       	movw	r30, r14
    76b4:	86 81       	ldd	r24, Z+6	; 0x06
    76b6:	97 81       	ldd	r25, Z+7	; 0x07
    76b8:	02 c0       	rjmp	.+4      	; 0x76be <vfprintf+0x716>
    76ba:	8f ef       	ldi	r24, 0xFF	; 255
    76bc:	9f ef       	ldi	r25, 0xFF	; 255
    76be:	63 96       	adiw	r28, 0x13	; 19
    76c0:	0f b6       	in	r0, 0x3f	; 63
    76c2:	f8 94       	cli
    76c4:	de bf       	out	0x3e, r29	; 62
    76c6:	0f be       	out	0x3f, r0	; 63
    76c8:	cd bf       	out	0x3d, r28	; 61
    76ca:	df 91       	pop	r29
    76cc:	cf 91       	pop	r28
    76ce:	1f 91       	pop	r17
    76d0:	0f 91       	pop	r16
    76d2:	ff 90       	pop	r15
    76d4:	ef 90       	pop	r14
    76d6:	df 90       	pop	r13
    76d8:	cf 90       	pop	r12
    76da:	bf 90       	pop	r11
    76dc:	af 90       	pop	r10
    76de:	9f 90       	pop	r9
    76e0:	8f 90       	pop	r8
    76e2:	7f 90       	pop	r7
    76e4:	6f 90       	pop	r6
    76e6:	5f 90       	pop	r5
    76e8:	4f 90       	pop	r4
    76ea:	3f 90       	pop	r3
    76ec:	2f 90       	pop	r2
    76ee:	08 95       	ret

000076f0 <__udivmodhi4>:
    76f0:	aa 1b       	sub	r26, r26
    76f2:	bb 1b       	sub	r27, r27
    76f4:	51 e1       	ldi	r21, 0x11	; 17
    76f6:	07 c0       	rjmp	.+14     	; 0x7706 <__udivmodhi4_ep>

000076f8 <__udivmodhi4_loop>:
    76f8:	aa 1f       	adc	r26, r26
    76fa:	bb 1f       	adc	r27, r27
    76fc:	a6 17       	cp	r26, r22
    76fe:	b7 07       	cpc	r27, r23
    7700:	10 f0       	brcs	.+4      	; 0x7706 <__udivmodhi4_ep>
    7702:	a6 1b       	sub	r26, r22
    7704:	b7 0b       	sbc	r27, r23

00007706 <__udivmodhi4_ep>:
    7706:	88 1f       	adc	r24, r24
    7708:	99 1f       	adc	r25, r25
    770a:	5a 95       	dec	r21
    770c:	a9 f7       	brne	.-22     	; 0x76f8 <__udivmodhi4_loop>
    770e:	80 95       	com	r24
    7710:	90 95       	com	r25
    7712:	bc 01       	movw	r22, r24
    7714:	cd 01       	movw	r24, r26
    7716:	08 95       	ret

00007718 <__udivmodsi4>:
    7718:	a1 e2       	ldi	r26, 0x21	; 33
    771a:	1a 2e       	mov	r1, r26
    771c:	aa 1b       	sub	r26, r26
    771e:	bb 1b       	sub	r27, r27
    7720:	fd 01       	movw	r30, r26
    7722:	0d c0       	rjmp	.+26     	; 0x773e <__udivmodsi4_ep>

00007724 <__udivmodsi4_loop>:
    7724:	aa 1f       	adc	r26, r26
    7726:	bb 1f       	adc	r27, r27
    7728:	ee 1f       	adc	r30, r30
    772a:	ff 1f       	adc	r31, r31
    772c:	a2 17       	cp	r26, r18
    772e:	b3 07       	cpc	r27, r19
    7730:	e4 07       	cpc	r30, r20
    7732:	f5 07       	cpc	r31, r21
    7734:	20 f0       	brcs	.+8      	; 0x773e <__udivmodsi4_ep>
    7736:	a2 1b       	sub	r26, r18
    7738:	b3 0b       	sbc	r27, r19
    773a:	e4 0b       	sbc	r30, r20
    773c:	f5 0b       	sbc	r31, r21

0000773e <__udivmodsi4_ep>:
    773e:	66 1f       	adc	r22, r22
    7740:	77 1f       	adc	r23, r23
    7742:	88 1f       	adc	r24, r24
    7744:	99 1f       	adc	r25, r25
    7746:	1a 94       	dec	r1
    7748:	69 f7       	brne	.-38     	; 0x7724 <__udivmodsi4_loop>
    774a:	60 95       	com	r22
    774c:	70 95       	com	r23
    774e:	80 95       	com	r24
    7750:	90 95       	com	r25
    7752:	9b 01       	movw	r18, r22
    7754:	ac 01       	movw	r20, r24
    7756:	bd 01       	movw	r22, r26
    7758:	cf 01       	movw	r24, r30
    775a:	08 95       	ret

0000775c <__divsf3>:
    775c:	0c d0       	rcall	.+24     	; 0x7776 <__divsf3x>
    775e:	ba c0       	rjmp	.+372    	; 0x78d4 <__fp_round>
    7760:	b2 d0       	rcall	.+356    	; 0x78c6 <__fp_pscB>
    7762:	40 f0       	brcs	.+16     	; 0x7774 <__divsf3+0x18>
    7764:	a9 d0       	rcall	.+338    	; 0x78b8 <__fp_pscA>
    7766:	30 f0       	brcs	.+12     	; 0x7774 <__divsf3+0x18>
    7768:	21 f4       	brne	.+8      	; 0x7772 <__divsf3+0x16>
    776a:	5f 3f       	cpi	r21, 0xFF	; 255
    776c:	19 f0       	breq	.+6      	; 0x7774 <__divsf3+0x18>
    776e:	9b c0       	rjmp	.+310    	; 0x78a6 <__fp_inf>
    7770:	51 11       	cpse	r21, r1
    7772:	e4 c0       	rjmp	.+456    	; 0x793c <__fp_szero>
    7774:	9e c0       	rjmp	.+316    	; 0x78b2 <__fp_nan>

00007776 <__divsf3x>:
    7776:	bf d0       	rcall	.+382    	; 0x78f6 <__fp_split3>
    7778:	98 f3       	brcs	.-26     	; 0x7760 <__divsf3+0x4>

0000777a <__divsf3_pse>:
    777a:	99 23       	and	r25, r25
    777c:	c9 f3       	breq	.-14     	; 0x7770 <__divsf3+0x14>
    777e:	55 23       	and	r21, r21
    7780:	b1 f3       	breq	.-20     	; 0x776e <__divsf3+0x12>
    7782:	95 1b       	sub	r25, r21
    7784:	55 0b       	sbc	r21, r21
    7786:	bb 27       	eor	r27, r27
    7788:	aa 27       	eor	r26, r26
    778a:	62 17       	cp	r22, r18
    778c:	73 07       	cpc	r23, r19
    778e:	84 07       	cpc	r24, r20
    7790:	38 f0       	brcs	.+14     	; 0x77a0 <__divsf3_pse+0x26>
    7792:	9f 5f       	subi	r25, 0xFF	; 255
    7794:	5f 4f       	sbci	r21, 0xFF	; 255
    7796:	22 0f       	add	r18, r18
    7798:	33 1f       	adc	r19, r19
    779a:	44 1f       	adc	r20, r20
    779c:	aa 1f       	adc	r26, r26
    779e:	a9 f3       	breq	.-22     	; 0x778a <__divsf3_pse+0x10>
    77a0:	33 d0       	rcall	.+102    	; 0x7808 <__divsf3_pse+0x8e>
    77a2:	0e 2e       	mov	r0, r30
    77a4:	3a f0       	brmi	.+14     	; 0x77b4 <__divsf3_pse+0x3a>
    77a6:	e0 e8       	ldi	r30, 0x80	; 128
    77a8:	30 d0       	rcall	.+96     	; 0x780a <__divsf3_pse+0x90>
    77aa:	91 50       	subi	r25, 0x01	; 1
    77ac:	50 40       	sbci	r21, 0x00	; 0
    77ae:	e6 95       	lsr	r30
    77b0:	00 1c       	adc	r0, r0
    77b2:	ca f7       	brpl	.-14     	; 0x77a6 <__divsf3_pse+0x2c>
    77b4:	29 d0       	rcall	.+82     	; 0x7808 <__divsf3_pse+0x8e>
    77b6:	fe 2f       	mov	r31, r30
    77b8:	27 d0       	rcall	.+78     	; 0x7808 <__divsf3_pse+0x8e>
    77ba:	66 0f       	add	r22, r22
    77bc:	77 1f       	adc	r23, r23
    77be:	88 1f       	adc	r24, r24
    77c0:	bb 1f       	adc	r27, r27
    77c2:	26 17       	cp	r18, r22
    77c4:	37 07       	cpc	r19, r23
    77c6:	48 07       	cpc	r20, r24
    77c8:	ab 07       	cpc	r26, r27
    77ca:	b0 e8       	ldi	r27, 0x80	; 128
    77cc:	09 f0       	breq	.+2      	; 0x77d0 <__divsf3_pse+0x56>
    77ce:	bb 0b       	sbc	r27, r27
    77d0:	80 2d       	mov	r24, r0
    77d2:	bf 01       	movw	r22, r30
    77d4:	ff 27       	eor	r31, r31
    77d6:	93 58       	subi	r25, 0x83	; 131
    77d8:	5f 4f       	sbci	r21, 0xFF	; 255
    77da:	2a f0       	brmi	.+10     	; 0x77e6 <__divsf3_pse+0x6c>
    77dc:	9e 3f       	cpi	r25, 0xFE	; 254
    77de:	51 05       	cpc	r21, r1
    77e0:	68 f0       	brcs	.+26     	; 0x77fc <__divsf3_pse+0x82>
    77e2:	61 c0       	rjmp	.+194    	; 0x78a6 <__fp_inf>
    77e4:	ab c0       	rjmp	.+342    	; 0x793c <__fp_szero>
    77e6:	5f 3f       	cpi	r21, 0xFF	; 255
    77e8:	ec f3       	brlt	.-6      	; 0x77e4 <__divsf3_pse+0x6a>
    77ea:	98 3e       	cpi	r25, 0xE8	; 232
    77ec:	dc f3       	brlt	.-10     	; 0x77e4 <__divsf3_pse+0x6a>
    77ee:	86 95       	lsr	r24
    77f0:	77 95       	ror	r23
    77f2:	67 95       	ror	r22
    77f4:	b7 95       	ror	r27
    77f6:	f7 95       	ror	r31
    77f8:	9f 5f       	subi	r25, 0xFF	; 255
    77fa:	c9 f7       	brne	.-14     	; 0x77ee <__divsf3_pse+0x74>
    77fc:	88 0f       	add	r24, r24
    77fe:	91 1d       	adc	r25, r1
    7800:	96 95       	lsr	r25
    7802:	87 95       	ror	r24
    7804:	97 f9       	bld	r25, 7
    7806:	08 95       	ret
    7808:	e1 e0       	ldi	r30, 0x01	; 1
    780a:	66 0f       	add	r22, r22
    780c:	77 1f       	adc	r23, r23
    780e:	88 1f       	adc	r24, r24
    7810:	bb 1f       	adc	r27, r27
    7812:	62 17       	cp	r22, r18
    7814:	73 07       	cpc	r23, r19
    7816:	84 07       	cpc	r24, r20
    7818:	ba 07       	cpc	r27, r26
    781a:	20 f0       	brcs	.+8      	; 0x7824 <__divsf3_pse+0xaa>
    781c:	62 1b       	sub	r22, r18
    781e:	73 0b       	sbc	r23, r19
    7820:	84 0b       	sbc	r24, r20
    7822:	ba 0b       	sbc	r27, r26
    7824:	ee 1f       	adc	r30, r30
    7826:	88 f7       	brcc	.-30     	; 0x780a <__divsf3_pse+0x90>
    7828:	e0 95       	com	r30
    782a:	08 95       	ret

0000782c <__floatunsisf>:
    782c:	e8 94       	clt
    782e:	09 c0       	rjmp	.+18     	; 0x7842 <__floatsisf+0x12>

00007830 <__floatsisf>:
    7830:	97 fb       	bst	r25, 7
    7832:	3e f4       	brtc	.+14     	; 0x7842 <__floatsisf+0x12>
    7834:	90 95       	com	r25
    7836:	80 95       	com	r24
    7838:	70 95       	com	r23
    783a:	61 95       	neg	r22
    783c:	7f 4f       	sbci	r23, 0xFF	; 255
    783e:	8f 4f       	sbci	r24, 0xFF	; 255
    7840:	9f 4f       	sbci	r25, 0xFF	; 255
    7842:	99 23       	and	r25, r25
    7844:	a9 f0       	breq	.+42     	; 0x7870 <__floatsisf+0x40>
    7846:	f9 2f       	mov	r31, r25
    7848:	96 e9       	ldi	r25, 0x96	; 150
    784a:	bb 27       	eor	r27, r27
    784c:	93 95       	inc	r25
    784e:	f6 95       	lsr	r31
    7850:	87 95       	ror	r24
    7852:	77 95       	ror	r23
    7854:	67 95       	ror	r22
    7856:	b7 95       	ror	r27
    7858:	f1 11       	cpse	r31, r1
    785a:	f8 cf       	rjmp	.-16     	; 0x784c <__floatsisf+0x1c>
    785c:	fa f4       	brpl	.+62     	; 0x789c <__floatsisf+0x6c>
    785e:	bb 0f       	add	r27, r27
    7860:	11 f4       	brne	.+4      	; 0x7866 <__floatsisf+0x36>
    7862:	60 ff       	sbrs	r22, 0
    7864:	1b c0       	rjmp	.+54     	; 0x789c <__floatsisf+0x6c>
    7866:	6f 5f       	subi	r22, 0xFF	; 255
    7868:	7f 4f       	sbci	r23, 0xFF	; 255
    786a:	8f 4f       	sbci	r24, 0xFF	; 255
    786c:	9f 4f       	sbci	r25, 0xFF	; 255
    786e:	16 c0       	rjmp	.+44     	; 0x789c <__floatsisf+0x6c>
    7870:	88 23       	and	r24, r24
    7872:	11 f0       	breq	.+4      	; 0x7878 <__floatsisf+0x48>
    7874:	96 e9       	ldi	r25, 0x96	; 150
    7876:	11 c0       	rjmp	.+34     	; 0x789a <__floatsisf+0x6a>
    7878:	77 23       	and	r23, r23
    787a:	21 f0       	breq	.+8      	; 0x7884 <__floatsisf+0x54>
    787c:	9e e8       	ldi	r25, 0x8E	; 142
    787e:	87 2f       	mov	r24, r23
    7880:	76 2f       	mov	r23, r22
    7882:	05 c0       	rjmp	.+10     	; 0x788e <__floatsisf+0x5e>
    7884:	66 23       	and	r22, r22
    7886:	71 f0       	breq	.+28     	; 0x78a4 <__floatsisf+0x74>
    7888:	96 e8       	ldi	r25, 0x86	; 134
    788a:	86 2f       	mov	r24, r22
    788c:	70 e0       	ldi	r23, 0x00	; 0
    788e:	60 e0       	ldi	r22, 0x00	; 0
    7890:	2a f0       	brmi	.+10     	; 0x789c <__floatsisf+0x6c>
    7892:	9a 95       	dec	r25
    7894:	66 0f       	add	r22, r22
    7896:	77 1f       	adc	r23, r23
    7898:	88 1f       	adc	r24, r24
    789a:	da f7       	brpl	.-10     	; 0x7892 <__floatsisf+0x62>
    789c:	88 0f       	add	r24, r24
    789e:	96 95       	lsr	r25
    78a0:	87 95       	ror	r24
    78a2:	97 f9       	bld	r25, 7
    78a4:	08 95       	ret

000078a6 <__fp_inf>:
    78a6:	97 f9       	bld	r25, 7
    78a8:	9f 67       	ori	r25, 0x7F	; 127
    78aa:	80 e8       	ldi	r24, 0x80	; 128
    78ac:	70 e0       	ldi	r23, 0x00	; 0
    78ae:	60 e0       	ldi	r22, 0x00	; 0
    78b0:	08 95       	ret

000078b2 <__fp_nan>:
    78b2:	9f ef       	ldi	r25, 0xFF	; 255
    78b4:	80 ec       	ldi	r24, 0xC0	; 192
    78b6:	08 95       	ret

000078b8 <__fp_pscA>:
    78b8:	00 24       	eor	r0, r0
    78ba:	0a 94       	dec	r0
    78bc:	16 16       	cp	r1, r22
    78be:	17 06       	cpc	r1, r23
    78c0:	18 06       	cpc	r1, r24
    78c2:	09 06       	cpc	r0, r25
    78c4:	08 95       	ret

000078c6 <__fp_pscB>:
    78c6:	00 24       	eor	r0, r0
    78c8:	0a 94       	dec	r0
    78ca:	12 16       	cp	r1, r18
    78cc:	13 06       	cpc	r1, r19
    78ce:	14 06       	cpc	r1, r20
    78d0:	05 06       	cpc	r0, r21
    78d2:	08 95       	ret

000078d4 <__fp_round>:
    78d4:	09 2e       	mov	r0, r25
    78d6:	03 94       	inc	r0
    78d8:	00 0c       	add	r0, r0
    78da:	11 f4       	brne	.+4      	; 0x78e0 <__fp_round+0xc>
    78dc:	88 23       	and	r24, r24
    78de:	52 f0       	brmi	.+20     	; 0x78f4 <__fp_round+0x20>
    78e0:	bb 0f       	add	r27, r27
    78e2:	40 f4       	brcc	.+16     	; 0x78f4 <__fp_round+0x20>
    78e4:	bf 2b       	or	r27, r31
    78e6:	11 f4       	brne	.+4      	; 0x78ec <__fp_round+0x18>
    78e8:	60 ff       	sbrs	r22, 0
    78ea:	04 c0       	rjmp	.+8      	; 0x78f4 <__fp_round+0x20>
    78ec:	6f 5f       	subi	r22, 0xFF	; 255
    78ee:	7f 4f       	sbci	r23, 0xFF	; 255
    78f0:	8f 4f       	sbci	r24, 0xFF	; 255
    78f2:	9f 4f       	sbci	r25, 0xFF	; 255
    78f4:	08 95       	ret

000078f6 <__fp_split3>:
    78f6:	57 fd       	sbrc	r21, 7
    78f8:	90 58       	subi	r25, 0x80	; 128
    78fa:	44 0f       	add	r20, r20
    78fc:	55 1f       	adc	r21, r21
    78fe:	59 f0       	breq	.+22     	; 0x7916 <__fp_splitA+0x10>
    7900:	5f 3f       	cpi	r21, 0xFF	; 255
    7902:	71 f0       	breq	.+28     	; 0x7920 <__fp_splitA+0x1a>
    7904:	47 95       	ror	r20

00007906 <__fp_splitA>:
    7906:	88 0f       	add	r24, r24
    7908:	97 fb       	bst	r25, 7
    790a:	99 1f       	adc	r25, r25
    790c:	61 f0       	breq	.+24     	; 0x7926 <__fp_splitA+0x20>
    790e:	9f 3f       	cpi	r25, 0xFF	; 255
    7910:	79 f0       	breq	.+30     	; 0x7930 <__fp_splitA+0x2a>
    7912:	87 95       	ror	r24
    7914:	08 95       	ret
    7916:	12 16       	cp	r1, r18
    7918:	13 06       	cpc	r1, r19
    791a:	14 06       	cpc	r1, r20
    791c:	55 1f       	adc	r21, r21
    791e:	f2 cf       	rjmp	.-28     	; 0x7904 <__fp_split3+0xe>
    7920:	46 95       	lsr	r20
    7922:	f1 df       	rcall	.-30     	; 0x7906 <__fp_splitA>
    7924:	08 c0       	rjmp	.+16     	; 0x7936 <__fp_splitA+0x30>
    7926:	16 16       	cp	r1, r22
    7928:	17 06       	cpc	r1, r23
    792a:	18 06       	cpc	r1, r24
    792c:	99 1f       	adc	r25, r25
    792e:	f1 cf       	rjmp	.-30     	; 0x7912 <__fp_splitA+0xc>
    7930:	86 95       	lsr	r24
    7932:	71 05       	cpc	r23, r1
    7934:	61 05       	cpc	r22, r1
    7936:	08 94       	sec
    7938:	08 95       	ret

0000793a <__fp_zero>:
    793a:	e8 94       	clt

0000793c <__fp_szero>:
    793c:	bb 27       	eor	r27, r27
    793e:	66 27       	eor	r22, r22
    7940:	77 27       	eor	r23, r23
    7942:	cb 01       	movw	r24, r22
    7944:	97 f9       	bld	r25, 7
    7946:	08 95       	ret

00007948 <atoi>:
    7948:	fc 01       	movw	r30, r24
    794a:	88 27       	eor	r24, r24
    794c:	99 27       	eor	r25, r25
    794e:	e8 94       	clt
    7950:	21 91       	ld	r18, Z+
    7952:	20 32       	cpi	r18, 0x20	; 32
    7954:	e9 f3       	breq	.-6      	; 0x7950 <atoi+0x8>
    7956:	29 30       	cpi	r18, 0x09	; 9
    7958:	10 f0       	brcs	.+4      	; 0x795e <atoi+0x16>
    795a:	2e 30       	cpi	r18, 0x0E	; 14
    795c:	c8 f3       	brcs	.-14     	; 0x7950 <atoi+0x8>
    795e:	2b 32       	cpi	r18, 0x2B	; 43
    7960:	41 f0       	breq	.+16     	; 0x7972 <atoi+0x2a>
    7962:	2d 32       	cpi	r18, 0x2D	; 45
    7964:	39 f4       	brne	.+14     	; 0x7974 <atoi+0x2c>
    7966:	68 94       	set
    7968:	04 c0       	rjmp	.+8      	; 0x7972 <atoi+0x2a>
    796a:	0e 94 35 3e 	call	0x7c6a	; 0x7c6a <__mulhi_const_10>
    796e:	82 0f       	add	r24, r18
    7970:	91 1d       	adc	r25, r1
    7972:	21 91       	ld	r18, Z+
    7974:	20 53       	subi	r18, 0x30	; 48
    7976:	2a 30       	cpi	r18, 0x0A	; 10
    7978:	c0 f3       	brcs	.-16     	; 0x796a <atoi+0x22>
    797a:	1e f4       	brtc	.+6      	; 0x7982 <atoi+0x3a>
    797c:	90 95       	com	r25
    797e:	81 95       	neg	r24
    7980:	9f 4f       	sbci	r25, 0xFF	; 255
    7982:	08 95       	ret

00007984 <__ftoa_engine>:
    7984:	28 30       	cpi	r18, 0x08	; 8
    7986:	08 f0       	brcs	.+2      	; 0x798a <__ftoa_engine+0x6>
    7988:	27 e0       	ldi	r18, 0x07	; 7
    798a:	33 27       	eor	r19, r19
    798c:	da 01       	movw	r26, r20
    798e:	99 0f       	add	r25, r25
    7990:	31 1d       	adc	r19, r1
    7992:	87 fd       	sbrc	r24, 7
    7994:	91 60       	ori	r25, 0x01	; 1
    7996:	00 96       	adiw	r24, 0x00	; 0
    7998:	61 05       	cpc	r22, r1
    799a:	71 05       	cpc	r23, r1
    799c:	39 f4       	brne	.+14     	; 0x79ac <__ftoa_engine+0x28>
    799e:	32 60       	ori	r19, 0x02	; 2
    79a0:	2e 5f       	subi	r18, 0xFE	; 254
    79a2:	3d 93       	st	X+, r19
    79a4:	30 e3       	ldi	r19, 0x30	; 48
    79a6:	2a 95       	dec	r18
    79a8:	e1 f7       	brne	.-8      	; 0x79a2 <__ftoa_engine+0x1e>
    79aa:	08 95       	ret
    79ac:	9f 3f       	cpi	r25, 0xFF	; 255
    79ae:	30 f0       	brcs	.+12     	; 0x79bc <__ftoa_engine+0x38>
    79b0:	80 38       	cpi	r24, 0x80	; 128
    79b2:	71 05       	cpc	r23, r1
    79b4:	61 05       	cpc	r22, r1
    79b6:	09 f0       	breq	.+2      	; 0x79ba <__ftoa_engine+0x36>
    79b8:	3c 5f       	subi	r19, 0xFC	; 252
    79ba:	3c 5f       	subi	r19, 0xFC	; 252
    79bc:	3d 93       	st	X+, r19
    79be:	91 30       	cpi	r25, 0x01	; 1
    79c0:	08 f0       	brcs	.+2      	; 0x79c4 <__ftoa_engine+0x40>
    79c2:	80 68       	ori	r24, 0x80	; 128
    79c4:	91 1d       	adc	r25, r1
    79c6:	df 93       	push	r29
    79c8:	cf 93       	push	r28
    79ca:	1f 93       	push	r17
    79cc:	0f 93       	push	r16
    79ce:	ff 92       	push	r15
    79d0:	ef 92       	push	r14
    79d2:	19 2f       	mov	r17, r25
    79d4:	98 7f       	andi	r25, 0xF8	; 248
    79d6:	96 95       	lsr	r25
    79d8:	e9 2f       	mov	r30, r25
    79da:	96 95       	lsr	r25
    79dc:	96 95       	lsr	r25
    79de:	e9 0f       	add	r30, r25
    79e0:	ff 27       	eor	r31, r31
    79e2:	e8 56       	subi	r30, 0x68	; 104
    79e4:	f9 4e       	sbci	r31, 0xE9	; 233
    79e6:	99 27       	eor	r25, r25
    79e8:	33 27       	eor	r19, r19
    79ea:	ee 24       	eor	r14, r14
    79ec:	ff 24       	eor	r15, r15
    79ee:	a7 01       	movw	r20, r14
    79f0:	e7 01       	movw	r28, r14
    79f2:	05 90       	lpm	r0, Z+
    79f4:	08 94       	sec
    79f6:	07 94       	ror	r0
    79f8:	28 f4       	brcc	.+10     	; 0x7a04 <__ftoa_engine+0x80>
    79fa:	36 0f       	add	r19, r22
    79fc:	e7 1e       	adc	r14, r23
    79fe:	f8 1e       	adc	r15, r24
    7a00:	49 1f       	adc	r20, r25
    7a02:	51 1d       	adc	r21, r1
    7a04:	66 0f       	add	r22, r22
    7a06:	77 1f       	adc	r23, r23
    7a08:	88 1f       	adc	r24, r24
    7a0a:	99 1f       	adc	r25, r25
    7a0c:	06 94       	lsr	r0
    7a0e:	a1 f7       	brne	.-24     	; 0x79f8 <__ftoa_engine+0x74>
    7a10:	05 90       	lpm	r0, Z+
    7a12:	07 94       	ror	r0
    7a14:	28 f4       	brcc	.+10     	; 0x7a20 <__ftoa_engine+0x9c>
    7a16:	e7 0e       	add	r14, r23
    7a18:	f8 1e       	adc	r15, r24
    7a1a:	49 1f       	adc	r20, r25
    7a1c:	56 1f       	adc	r21, r22
    7a1e:	c1 1d       	adc	r28, r1
    7a20:	77 0f       	add	r23, r23
    7a22:	88 1f       	adc	r24, r24
    7a24:	99 1f       	adc	r25, r25
    7a26:	66 1f       	adc	r22, r22
    7a28:	06 94       	lsr	r0
    7a2a:	a1 f7       	brne	.-24     	; 0x7a14 <__ftoa_engine+0x90>
    7a2c:	05 90       	lpm	r0, Z+
    7a2e:	07 94       	ror	r0
    7a30:	28 f4       	brcc	.+10     	; 0x7a3c <__ftoa_engine+0xb8>
    7a32:	f8 0e       	add	r15, r24
    7a34:	49 1f       	adc	r20, r25
    7a36:	56 1f       	adc	r21, r22
    7a38:	c7 1f       	adc	r28, r23
    7a3a:	d1 1d       	adc	r29, r1
    7a3c:	88 0f       	add	r24, r24
    7a3e:	99 1f       	adc	r25, r25
    7a40:	66 1f       	adc	r22, r22
    7a42:	77 1f       	adc	r23, r23
    7a44:	06 94       	lsr	r0
    7a46:	a1 f7       	brne	.-24     	; 0x7a30 <__ftoa_engine+0xac>
    7a48:	05 90       	lpm	r0, Z+
    7a4a:	07 94       	ror	r0
    7a4c:	20 f4       	brcc	.+8      	; 0x7a56 <__ftoa_engine+0xd2>
    7a4e:	49 0f       	add	r20, r25
    7a50:	56 1f       	adc	r21, r22
    7a52:	c7 1f       	adc	r28, r23
    7a54:	d8 1f       	adc	r29, r24
    7a56:	99 0f       	add	r25, r25
    7a58:	66 1f       	adc	r22, r22
    7a5a:	77 1f       	adc	r23, r23
    7a5c:	88 1f       	adc	r24, r24
    7a5e:	06 94       	lsr	r0
    7a60:	a9 f7       	brne	.-22     	; 0x7a4c <__ftoa_engine+0xc8>
    7a62:	84 91       	lpm	r24, Z
    7a64:	10 95       	com	r17
    7a66:	17 70       	andi	r17, 0x07	; 7
    7a68:	41 f0       	breq	.+16     	; 0x7a7a <__ftoa_engine+0xf6>
    7a6a:	d6 95       	lsr	r29
    7a6c:	c7 95       	ror	r28
    7a6e:	57 95       	ror	r21
    7a70:	47 95       	ror	r20
    7a72:	f7 94       	ror	r15
    7a74:	e7 94       	ror	r14
    7a76:	1a 95       	dec	r17
    7a78:	c1 f7       	brne	.-16     	; 0x7a6a <__ftoa_engine+0xe6>
    7a7a:	ee e3       	ldi	r30, 0x3E	; 62
    7a7c:	f6 e1       	ldi	r31, 0x16	; 22
    7a7e:	68 94       	set
    7a80:	15 90       	lpm	r1, Z+
    7a82:	15 91       	lpm	r17, Z+
    7a84:	35 91       	lpm	r19, Z+
    7a86:	65 91       	lpm	r22, Z+
    7a88:	95 91       	lpm	r25, Z+
    7a8a:	05 90       	lpm	r0, Z+
    7a8c:	7f e2       	ldi	r23, 0x2F	; 47
    7a8e:	73 95       	inc	r23
    7a90:	e1 18       	sub	r14, r1
    7a92:	f1 0a       	sbc	r15, r17
    7a94:	43 0b       	sbc	r20, r19
    7a96:	56 0b       	sbc	r21, r22
    7a98:	c9 0b       	sbc	r28, r25
    7a9a:	d0 09       	sbc	r29, r0
    7a9c:	c0 f7       	brcc	.-16     	; 0x7a8e <__ftoa_engine+0x10a>
    7a9e:	e1 0c       	add	r14, r1
    7aa0:	f1 1e       	adc	r15, r17
    7aa2:	43 1f       	adc	r20, r19
    7aa4:	56 1f       	adc	r21, r22
    7aa6:	c9 1f       	adc	r28, r25
    7aa8:	d0 1d       	adc	r29, r0
    7aaa:	7e f4       	brtc	.+30     	; 0x7aca <__ftoa_engine+0x146>
    7aac:	70 33       	cpi	r23, 0x30	; 48
    7aae:	11 f4       	brne	.+4      	; 0x7ab4 <__ftoa_engine+0x130>
    7ab0:	8a 95       	dec	r24
    7ab2:	e6 cf       	rjmp	.-52     	; 0x7a80 <__ftoa_engine+0xfc>
    7ab4:	e8 94       	clt
    7ab6:	01 50       	subi	r16, 0x01	; 1
    7ab8:	30 f0       	brcs	.+12     	; 0x7ac6 <__ftoa_engine+0x142>
    7aba:	08 0f       	add	r16, r24
    7abc:	0a f4       	brpl	.+2      	; 0x7ac0 <__ftoa_engine+0x13c>
    7abe:	00 27       	eor	r16, r16
    7ac0:	02 17       	cp	r16, r18
    7ac2:	08 f4       	brcc	.+2      	; 0x7ac6 <__ftoa_engine+0x142>
    7ac4:	20 2f       	mov	r18, r16
    7ac6:	23 95       	inc	r18
    7ac8:	02 2f       	mov	r16, r18
    7aca:	7a 33       	cpi	r23, 0x3A	; 58
    7acc:	28 f0       	brcs	.+10     	; 0x7ad8 <__ftoa_engine+0x154>
    7ace:	79 e3       	ldi	r23, 0x39	; 57
    7ad0:	7d 93       	st	X+, r23
    7ad2:	2a 95       	dec	r18
    7ad4:	e9 f7       	brne	.-6      	; 0x7ad0 <__ftoa_engine+0x14c>
    7ad6:	10 c0       	rjmp	.+32     	; 0x7af8 <__ftoa_engine+0x174>
    7ad8:	7d 93       	st	X+, r23
    7ada:	2a 95       	dec	r18
    7adc:	89 f6       	brne	.-94     	; 0x7a80 <__ftoa_engine+0xfc>
    7ade:	06 94       	lsr	r0
    7ae0:	97 95       	ror	r25
    7ae2:	67 95       	ror	r22
    7ae4:	37 95       	ror	r19
    7ae6:	17 95       	ror	r17
    7ae8:	17 94       	ror	r1
    7aea:	e1 18       	sub	r14, r1
    7aec:	f1 0a       	sbc	r15, r17
    7aee:	43 0b       	sbc	r20, r19
    7af0:	56 0b       	sbc	r21, r22
    7af2:	c9 0b       	sbc	r28, r25
    7af4:	d0 09       	sbc	r29, r0
    7af6:	98 f0       	brcs	.+38     	; 0x7b1e <__ftoa_engine+0x19a>
    7af8:	23 95       	inc	r18
    7afa:	7e 91       	ld	r23, -X
    7afc:	73 95       	inc	r23
    7afe:	7a 33       	cpi	r23, 0x3A	; 58
    7b00:	08 f0       	brcs	.+2      	; 0x7b04 <__ftoa_engine+0x180>
    7b02:	70 e3       	ldi	r23, 0x30	; 48
    7b04:	7c 93       	st	X, r23
    7b06:	20 13       	cpse	r18, r16
    7b08:	b8 f7       	brcc	.-18     	; 0x7af8 <__ftoa_engine+0x174>
    7b0a:	7e 91       	ld	r23, -X
    7b0c:	70 61       	ori	r23, 0x10	; 16
    7b0e:	7d 93       	st	X+, r23
    7b10:	30 f0       	brcs	.+12     	; 0x7b1e <__ftoa_engine+0x19a>
    7b12:	83 95       	inc	r24
    7b14:	71 e3       	ldi	r23, 0x31	; 49
    7b16:	7d 93       	st	X+, r23
    7b18:	70 e3       	ldi	r23, 0x30	; 48
    7b1a:	2a 95       	dec	r18
    7b1c:	e1 f7       	brne	.-8      	; 0x7b16 <__ftoa_engine+0x192>
    7b1e:	11 24       	eor	r1, r1
    7b20:	ef 90       	pop	r14
    7b22:	ff 90       	pop	r15
    7b24:	0f 91       	pop	r16
    7b26:	1f 91       	pop	r17
    7b28:	cf 91       	pop	r28
    7b2a:	df 91       	pop	r29
    7b2c:	99 27       	eor	r25, r25
    7b2e:	87 fd       	sbrc	r24, 7
    7b30:	90 95       	com	r25
    7b32:	08 95       	ret

00007b34 <strncmp_P>:
    7b34:	fb 01       	movw	r30, r22
    7b36:	dc 01       	movw	r26, r24
    7b38:	41 50       	subi	r20, 0x01	; 1
    7b3a:	50 40       	sbci	r21, 0x00	; 0
    7b3c:	30 f0       	brcs	.+12     	; 0x7b4a <strncmp_P+0x16>
    7b3e:	8d 91       	ld	r24, X+
    7b40:	05 90       	lpm	r0, Z+
    7b42:	80 19       	sub	r24, r0
    7b44:	19 f4       	brne	.+6      	; 0x7b4c <strncmp_P+0x18>
    7b46:	00 20       	and	r0, r0
    7b48:	b9 f7       	brne	.-18     	; 0x7b38 <strncmp_P+0x4>
    7b4a:	88 1b       	sub	r24, r24
    7b4c:	99 0b       	sbc	r25, r25
    7b4e:	08 95       	ret

00007b50 <strnlen_P>:
    7b50:	fc 01       	movw	r30, r24
    7b52:	05 90       	lpm	r0, Z+
    7b54:	61 50       	subi	r22, 0x01	; 1
    7b56:	70 40       	sbci	r23, 0x00	; 0
    7b58:	01 10       	cpse	r0, r1
    7b5a:	d8 f7       	brcc	.-10     	; 0x7b52 <strnlen_P+0x2>
    7b5c:	80 95       	com	r24
    7b5e:	90 95       	com	r25
    7b60:	8e 0f       	add	r24, r30
    7b62:	9f 1f       	adc	r25, r31
    7b64:	08 95       	ret

00007b66 <strstr_P>:
    7b66:	fb 01       	movw	r30, r22
    7b68:	55 91       	lpm	r21, Z+
    7b6a:	55 23       	and	r21, r21
    7b6c:	a9 f0       	breq	.+42     	; 0x7b98 <strstr_P+0x32>
    7b6e:	bf 01       	movw	r22, r30
    7b70:	dc 01       	movw	r26, r24
    7b72:	4d 91       	ld	r20, X+
    7b74:	45 17       	cp	r20, r21
    7b76:	41 11       	cpse	r20, r1
    7b78:	e1 f7       	brne	.-8      	; 0x7b72 <strstr_P+0xc>
    7b7a:	59 f4       	brne	.+22     	; 0x7b92 <strstr_P+0x2c>
    7b7c:	cd 01       	movw	r24, r26
    7b7e:	05 90       	lpm	r0, Z+
    7b80:	00 20       	and	r0, r0
    7b82:	49 f0       	breq	.+18     	; 0x7b96 <strstr_P+0x30>
    7b84:	4d 91       	ld	r20, X+
    7b86:	40 15       	cp	r20, r0
    7b88:	41 11       	cpse	r20, r1
    7b8a:	c9 f3       	breq	.-14     	; 0x7b7e <strstr_P+0x18>
    7b8c:	fb 01       	movw	r30, r22
    7b8e:	41 11       	cpse	r20, r1
    7b90:	ef cf       	rjmp	.-34     	; 0x7b70 <strstr_P+0xa>
    7b92:	81 e0       	ldi	r24, 0x01	; 1
    7b94:	90 e0       	ldi	r25, 0x00	; 0
    7b96:	01 97       	sbiw	r24, 0x01	; 1
    7b98:	08 95       	ret

00007b9a <memset>:
    7b9a:	dc 01       	movw	r26, r24
    7b9c:	01 c0       	rjmp	.+2      	; 0x7ba0 <memset+0x6>
    7b9e:	6d 93       	st	X+, r22
    7ba0:	41 50       	subi	r20, 0x01	; 1
    7ba2:	50 40       	sbci	r21, 0x00	; 0
    7ba4:	e0 f7       	brcc	.-8      	; 0x7b9e <memset+0x4>
    7ba6:	08 95       	ret

00007ba8 <strchr>:
    7ba8:	fc 01       	movw	r30, r24
    7baa:	81 91       	ld	r24, Z+
    7bac:	86 17       	cp	r24, r22
    7bae:	21 f0       	breq	.+8      	; 0x7bb8 <strchr+0x10>
    7bb0:	88 23       	and	r24, r24
    7bb2:	d9 f7       	brne	.-10     	; 0x7baa <strchr+0x2>
    7bb4:	99 27       	eor	r25, r25
    7bb6:	08 95       	ret
    7bb8:	31 97       	sbiw	r30, 0x01	; 1
    7bba:	cf 01       	movw	r24, r30
    7bbc:	08 95       	ret

00007bbe <strcmp>:
    7bbe:	fb 01       	movw	r30, r22
    7bc0:	dc 01       	movw	r26, r24
    7bc2:	8d 91       	ld	r24, X+
    7bc4:	01 90       	ld	r0, Z+
    7bc6:	80 19       	sub	r24, r0
    7bc8:	01 10       	cpse	r0, r1
    7bca:	d9 f3       	breq	.-10     	; 0x7bc2 <strcmp+0x4>
    7bcc:	99 0b       	sbc	r25, r25
    7bce:	08 95       	ret

00007bd0 <strncmp>:
    7bd0:	fb 01       	movw	r30, r22
    7bd2:	dc 01       	movw	r26, r24
    7bd4:	41 50       	subi	r20, 0x01	; 1
    7bd6:	50 40       	sbci	r21, 0x00	; 0
    7bd8:	30 f0       	brcs	.+12     	; 0x7be6 <strncmp+0x16>
    7bda:	8d 91       	ld	r24, X+
    7bdc:	01 90       	ld	r0, Z+
    7bde:	80 19       	sub	r24, r0
    7be0:	19 f4       	brne	.+6      	; 0x7be8 <strncmp+0x18>
    7be2:	00 20       	and	r0, r0
    7be4:	b9 f7       	brne	.-18     	; 0x7bd4 <strncmp+0x4>
    7be6:	88 1b       	sub	r24, r24
    7be8:	99 0b       	sbc	r25, r25
    7bea:	08 95       	ret

00007bec <strncpy>:
    7bec:	fb 01       	movw	r30, r22
    7bee:	dc 01       	movw	r26, r24
    7bf0:	41 50       	subi	r20, 0x01	; 1
    7bf2:	50 40       	sbci	r21, 0x00	; 0
    7bf4:	48 f0       	brcs	.+18     	; 0x7c08 <strncpy+0x1c>
    7bf6:	01 90       	ld	r0, Z+
    7bf8:	0d 92       	st	X+, r0
    7bfa:	00 20       	and	r0, r0
    7bfc:	c9 f7       	brne	.-14     	; 0x7bf0 <strncpy+0x4>
    7bfe:	01 c0       	rjmp	.+2      	; 0x7c02 <strncpy+0x16>
    7c00:	1d 92       	st	X+, r1
    7c02:	41 50       	subi	r20, 0x01	; 1
    7c04:	50 40       	sbci	r21, 0x00	; 0
    7c06:	e0 f7       	brcc	.-8      	; 0x7c00 <strncpy+0x14>
    7c08:	08 95       	ret

00007c0a <strnlen>:
    7c0a:	fc 01       	movw	r30, r24
    7c0c:	61 50       	subi	r22, 0x01	; 1
    7c0e:	70 40       	sbci	r23, 0x00	; 0
    7c10:	01 90       	ld	r0, Z+
    7c12:	01 10       	cpse	r0, r1
    7c14:	d8 f7       	brcc	.-10     	; 0x7c0c <strnlen+0x2>
    7c16:	80 95       	com	r24
    7c18:	90 95       	com	r25
    7c1a:	8e 0f       	add	r24, r30
    7c1c:	9f 1f       	adc	r25, r31
    7c1e:	08 95       	ret

00007c20 <strstr>:
    7c20:	fb 01       	movw	r30, r22
    7c22:	51 91       	ld	r21, Z+
    7c24:	55 23       	and	r21, r21
    7c26:	a9 f0       	breq	.+42     	; 0x7c52 <strstr+0x32>
    7c28:	bf 01       	movw	r22, r30
    7c2a:	dc 01       	movw	r26, r24
    7c2c:	4d 91       	ld	r20, X+
    7c2e:	45 17       	cp	r20, r21
    7c30:	41 11       	cpse	r20, r1
    7c32:	e1 f7       	brne	.-8      	; 0x7c2c <strstr+0xc>
    7c34:	59 f4       	brne	.+22     	; 0x7c4c <strstr+0x2c>
    7c36:	cd 01       	movw	r24, r26
    7c38:	01 90       	ld	r0, Z+
    7c3a:	00 20       	and	r0, r0
    7c3c:	49 f0       	breq	.+18     	; 0x7c50 <strstr+0x30>
    7c3e:	4d 91       	ld	r20, X+
    7c40:	40 15       	cp	r20, r0
    7c42:	41 11       	cpse	r20, r1
    7c44:	c9 f3       	breq	.-14     	; 0x7c38 <strstr+0x18>
    7c46:	fb 01       	movw	r30, r22
    7c48:	41 11       	cpse	r20, r1
    7c4a:	ef cf       	rjmp	.-34     	; 0x7c2a <strstr+0xa>
    7c4c:	81 e0       	ldi	r24, 0x01	; 1
    7c4e:	90 e0       	ldi	r25, 0x00	; 0
    7c50:	01 97       	sbiw	r24, 0x01	; 1
    7c52:	08 95       	ret

00007c54 <__itoa_ncheck>:
    7c54:	bb 27       	eor	r27, r27
    7c56:	4a 30       	cpi	r20, 0x0A	; 10
    7c58:	31 f4       	brne	.+12     	; 0x7c66 <__itoa_ncheck+0x12>
    7c5a:	99 23       	and	r25, r25
    7c5c:	22 f4       	brpl	.+8      	; 0x7c66 <__itoa_ncheck+0x12>
    7c5e:	bd e2       	ldi	r27, 0x2D	; 45
    7c60:	90 95       	com	r25
    7c62:	81 95       	neg	r24
    7c64:	9f 4f       	sbci	r25, 0xFF	; 255
    7c66:	0c 94 3e 3e 	jmp	0x7c7c	; 0x7c7c <__utoa_common>

00007c6a <__mulhi_const_10>:
    7c6a:	7a e0       	ldi	r23, 0x0A	; 10
    7c6c:	97 9f       	mul	r25, r23
    7c6e:	90 2d       	mov	r25, r0
    7c70:	87 9f       	mul	r24, r23
    7c72:	80 2d       	mov	r24, r0
    7c74:	91 0d       	add	r25, r1
    7c76:	11 24       	eor	r1, r1
    7c78:	08 95       	ret

00007c7a <__utoa_ncheck>:
    7c7a:	bb 27       	eor	r27, r27

00007c7c <__utoa_common>:
    7c7c:	fb 01       	movw	r30, r22
    7c7e:	55 27       	eor	r21, r21
    7c80:	aa 27       	eor	r26, r26
    7c82:	88 0f       	add	r24, r24
    7c84:	99 1f       	adc	r25, r25
    7c86:	aa 1f       	adc	r26, r26
    7c88:	a4 17       	cp	r26, r20
    7c8a:	10 f0       	brcs	.+4      	; 0x7c90 <__utoa_common+0x14>
    7c8c:	a4 1b       	sub	r26, r20
    7c8e:	83 95       	inc	r24
    7c90:	50 51       	subi	r21, 0x10	; 16
    7c92:	b9 f7       	brne	.-18     	; 0x7c82 <__utoa_common+0x6>
    7c94:	a0 5d       	subi	r26, 0xD0	; 208
    7c96:	aa 33       	cpi	r26, 0x3A	; 58
    7c98:	08 f0       	brcs	.+2      	; 0x7c9c <__utoa_common+0x20>
    7c9a:	a9 5d       	subi	r26, 0xD9	; 217
    7c9c:	a1 93       	st	Z+, r26
    7c9e:	00 97       	sbiw	r24, 0x00	; 0
    7ca0:	79 f7       	brne	.-34     	; 0x7c80 <__utoa_common+0x4>
    7ca2:	b1 11       	cpse	r27, r1
    7ca4:	b1 93       	st	Z+, r27
    7ca6:	11 92       	st	Z+, r1
    7ca8:	cb 01       	movw	r24, r22
    7caa:	0c 94 d2 42 	jmp	0x85a4	; 0x85a4 <strrev>

00007cae <fputc>:
    7cae:	0f 93       	push	r16
    7cb0:	1f 93       	push	r17
    7cb2:	cf 93       	push	r28
    7cb4:	df 93       	push	r29
    7cb6:	18 2f       	mov	r17, r24
    7cb8:	09 2f       	mov	r16, r25
    7cba:	eb 01       	movw	r28, r22
    7cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    7cbe:	81 fd       	sbrc	r24, 1
    7cc0:	03 c0       	rjmp	.+6      	; 0x7cc8 <fputc+0x1a>
    7cc2:	8f ef       	ldi	r24, 0xFF	; 255
    7cc4:	9f ef       	ldi	r25, 0xFF	; 255
    7cc6:	20 c0       	rjmp	.+64     	; 0x7d08 <fputc+0x5a>
    7cc8:	82 ff       	sbrs	r24, 2
    7cca:	10 c0       	rjmp	.+32     	; 0x7cec <fputc+0x3e>
    7ccc:	4e 81       	ldd	r20, Y+6	; 0x06
    7cce:	5f 81       	ldd	r21, Y+7	; 0x07
    7cd0:	2c 81       	ldd	r18, Y+4	; 0x04
    7cd2:	3d 81       	ldd	r19, Y+5	; 0x05
    7cd4:	42 17       	cp	r20, r18
    7cd6:	53 07       	cpc	r21, r19
    7cd8:	7c f4       	brge	.+30     	; 0x7cf8 <fputc+0x4a>
    7cda:	e8 81       	ld	r30, Y
    7cdc:	f9 81       	ldd	r31, Y+1	; 0x01
    7cde:	9f 01       	movw	r18, r30
    7ce0:	2f 5f       	subi	r18, 0xFF	; 255
    7ce2:	3f 4f       	sbci	r19, 0xFF	; 255
    7ce4:	39 83       	std	Y+1, r19	; 0x01
    7ce6:	28 83       	st	Y, r18
    7ce8:	10 83       	st	Z, r17
    7cea:	06 c0       	rjmp	.+12     	; 0x7cf8 <fputc+0x4a>
    7cec:	e8 85       	ldd	r30, Y+8	; 0x08
    7cee:	f9 85       	ldd	r31, Y+9	; 0x09
    7cf0:	81 2f       	mov	r24, r17
    7cf2:	09 95       	icall
    7cf4:	89 2b       	or	r24, r25
    7cf6:	29 f7       	brne	.-54     	; 0x7cc2 <fputc+0x14>
    7cf8:	2e 81       	ldd	r18, Y+6	; 0x06
    7cfa:	3f 81       	ldd	r19, Y+7	; 0x07
    7cfc:	2f 5f       	subi	r18, 0xFF	; 255
    7cfe:	3f 4f       	sbci	r19, 0xFF	; 255
    7d00:	3f 83       	std	Y+7, r19	; 0x07
    7d02:	2e 83       	std	Y+6, r18	; 0x06
    7d04:	81 2f       	mov	r24, r17
    7d06:	90 2f       	mov	r25, r16
    7d08:	df 91       	pop	r29
    7d0a:	cf 91       	pop	r28
    7d0c:	1f 91       	pop	r17
    7d0e:	0f 91       	pop	r16
    7d10:	08 95       	ret

00007d12 <printf>:
    7d12:	cf 93       	push	r28
    7d14:	df 93       	push	r29
    7d16:	cd b7       	in	r28, 0x3d	; 61
    7d18:	de b7       	in	r29, 0x3e	; 62
    7d1a:	fe 01       	movw	r30, r28
    7d1c:	35 96       	adiw	r30, 0x05	; 5
    7d1e:	61 91       	ld	r22, Z+
    7d20:	71 91       	ld	r23, Z+
    7d22:	af 01       	movw	r20, r30
    7d24:	80 91 ef 22 	lds	r24, 0x22EF
    7d28:	90 91 f0 22 	lds	r25, 0x22F0
    7d2c:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <vfprintf>
    7d30:	df 91       	pop	r29
    7d32:	cf 91       	pop	r28
    7d34:	08 95       	ret

00007d36 <printf_P>:
    7d36:	0f 93       	push	r16
    7d38:	1f 93       	push	r17
    7d3a:	cf 93       	push	r28
    7d3c:	df 93       	push	r29
    7d3e:	cd b7       	in	r28, 0x3d	; 61
    7d40:	de b7       	in	r29, 0x3e	; 62
    7d42:	fe 01       	movw	r30, r28
    7d44:	37 96       	adiw	r30, 0x07	; 7
    7d46:	61 91       	ld	r22, Z+
    7d48:	71 91       	ld	r23, Z+
    7d4a:	0f ee       	ldi	r16, 0xEF	; 239
    7d4c:	12 e2       	ldi	r17, 0x22	; 34
    7d4e:	d8 01       	movw	r26, r16
    7d50:	8d 91       	ld	r24, X+
    7d52:	9c 91       	ld	r25, X
    7d54:	dc 01       	movw	r26, r24
    7d56:	13 96       	adiw	r26, 0x03	; 3
    7d58:	2c 91       	ld	r18, X
    7d5a:	13 97       	sbiw	r26, 0x03	; 3
    7d5c:	28 60       	ori	r18, 0x08	; 8
    7d5e:	13 96       	adiw	r26, 0x03	; 3
    7d60:	2c 93       	st	X, r18
    7d62:	af 01       	movw	r20, r30
    7d64:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <vfprintf>
    7d68:	d8 01       	movw	r26, r16
    7d6a:	ed 91       	ld	r30, X+
    7d6c:	fc 91       	ld	r31, X
    7d6e:	23 81       	ldd	r18, Z+3	; 0x03
    7d70:	27 7f       	andi	r18, 0xF7	; 247
    7d72:	23 83       	std	Z+3, r18	; 0x03
    7d74:	df 91       	pop	r29
    7d76:	cf 91       	pop	r28
    7d78:	1f 91       	pop	r17
    7d7a:	0f 91       	pop	r16
    7d7c:	08 95       	ret

00007d7e <puts>:
    7d7e:	0f 93       	push	r16
    7d80:	1f 93       	push	r17
    7d82:	cf 93       	push	r28
    7d84:	df 93       	push	r29
    7d86:	e0 91 ef 22 	lds	r30, 0x22EF
    7d8a:	f0 91 f0 22 	lds	r31, 0x22F0
    7d8e:	23 81       	ldd	r18, Z+3	; 0x03
    7d90:	21 ff       	sbrs	r18, 1
    7d92:	1b c0       	rjmp	.+54     	; 0x7dca <puts+0x4c>
    7d94:	ec 01       	movw	r28, r24
    7d96:	00 e0       	ldi	r16, 0x00	; 0
    7d98:	10 e0       	ldi	r17, 0x00	; 0
    7d9a:	89 91       	ld	r24, Y+
    7d9c:	60 91 ef 22 	lds	r22, 0x22EF
    7da0:	70 91 f0 22 	lds	r23, 0x22F0
    7da4:	db 01       	movw	r26, r22
    7da6:	18 96       	adiw	r26, 0x08	; 8
    7da8:	ed 91       	ld	r30, X+
    7daa:	fc 91       	ld	r31, X
    7dac:	19 97       	sbiw	r26, 0x09	; 9
    7dae:	88 23       	and	r24, r24
    7db0:	31 f0       	breq	.+12     	; 0x7dbe <puts+0x40>
    7db2:	09 95       	icall
    7db4:	89 2b       	or	r24, r25
    7db6:	89 f3       	breq	.-30     	; 0x7d9a <puts+0x1c>
    7db8:	0f ef       	ldi	r16, 0xFF	; 255
    7dba:	1f ef       	ldi	r17, 0xFF	; 255
    7dbc:	ee cf       	rjmp	.-36     	; 0x7d9a <puts+0x1c>
    7dbe:	8a e0       	ldi	r24, 0x0A	; 10
    7dc0:	09 95       	icall
    7dc2:	89 2b       	or	r24, r25
    7dc4:	11 f4       	brne	.+4      	; 0x7dca <puts+0x4c>
    7dc6:	c8 01       	movw	r24, r16
    7dc8:	02 c0       	rjmp	.+4      	; 0x7dce <puts+0x50>
    7dca:	8f ef       	ldi	r24, 0xFF	; 255
    7dcc:	9f ef       	ldi	r25, 0xFF	; 255
    7dce:	df 91       	pop	r29
    7dd0:	cf 91       	pop	r28
    7dd2:	1f 91       	pop	r17
    7dd4:	0f 91       	pop	r16
    7dd6:	08 95       	ret

00007dd8 <sprintf>:
    7dd8:	0f 93       	push	r16
    7dda:	1f 93       	push	r17
    7ddc:	cf 93       	push	r28
    7dde:	df 93       	push	r29
    7de0:	cd b7       	in	r28, 0x3d	; 61
    7de2:	de b7       	in	r29, 0x3e	; 62
    7de4:	2e 97       	sbiw	r28, 0x0e	; 14
    7de6:	0f b6       	in	r0, 0x3f	; 63
    7de8:	f8 94       	cli
    7dea:	de bf       	out	0x3e, r29	; 62
    7dec:	0f be       	out	0x3f, r0	; 63
    7dee:	cd bf       	out	0x3d, r28	; 61
    7df0:	0d 89       	ldd	r16, Y+21	; 0x15
    7df2:	1e 89       	ldd	r17, Y+22	; 0x16
    7df4:	86 e0       	ldi	r24, 0x06	; 6
    7df6:	8c 83       	std	Y+4, r24	; 0x04
    7df8:	1a 83       	std	Y+2, r17	; 0x02
    7dfa:	09 83       	std	Y+1, r16	; 0x01
    7dfc:	8f ef       	ldi	r24, 0xFF	; 255
    7dfe:	9f e7       	ldi	r25, 0x7F	; 127
    7e00:	9e 83       	std	Y+6, r25	; 0x06
    7e02:	8d 83       	std	Y+5, r24	; 0x05
    7e04:	ae 01       	movw	r20, r28
    7e06:	47 5e       	subi	r20, 0xE7	; 231
    7e08:	5f 4f       	sbci	r21, 0xFF	; 255
    7e0a:	6f 89       	ldd	r22, Y+23	; 0x17
    7e0c:	78 8d       	ldd	r23, Y+24	; 0x18
    7e0e:	ce 01       	movw	r24, r28
    7e10:	01 96       	adiw	r24, 0x01	; 1
    7e12:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <vfprintf>
    7e16:	ef 81       	ldd	r30, Y+7	; 0x07
    7e18:	f8 85       	ldd	r31, Y+8	; 0x08
    7e1a:	e0 0f       	add	r30, r16
    7e1c:	f1 1f       	adc	r31, r17
    7e1e:	10 82       	st	Z, r1
    7e20:	2e 96       	adiw	r28, 0x0e	; 14
    7e22:	0f b6       	in	r0, 0x3f	; 63
    7e24:	f8 94       	cli
    7e26:	de bf       	out	0x3e, r29	; 62
    7e28:	0f be       	out	0x3f, r0	; 63
    7e2a:	cd bf       	out	0x3d, r28	; 61
    7e2c:	df 91       	pop	r29
    7e2e:	cf 91       	pop	r28
    7e30:	1f 91       	pop	r17
    7e32:	0f 91       	pop	r16
    7e34:	08 95       	ret

00007e36 <sprintf_P>:
    7e36:	0f 93       	push	r16
    7e38:	1f 93       	push	r17
    7e3a:	cf 93       	push	r28
    7e3c:	df 93       	push	r29
    7e3e:	cd b7       	in	r28, 0x3d	; 61
    7e40:	de b7       	in	r29, 0x3e	; 62
    7e42:	2e 97       	sbiw	r28, 0x0e	; 14
    7e44:	0f b6       	in	r0, 0x3f	; 63
    7e46:	f8 94       	cli
    7e48:	de bf       	out	0x3e, r29	; 62
    7e4a:	0f be       	out	0x3f, r0	; 63
    7e4c:	cd bf       	out	0x3d, r28	; 61
    7e4e:	0d 89       	ldd	r16, Y+21	; 0x15
    7e50:	1e 89       	ldd	r17, Y+22	; 0x16
    7e52:	8e e0       	ldi	r24, 0x0E	; 14
    7e54:	8c 83       	std	Y+4, r24	; 0x04
    7e56:	1a 83       	std	Y+2, r17	; 0x02
    7e58:	09 83       	std	Y+1, r16	; 0x01
    7e5a:	8f ef       	ldi	r24, 0xFF	; 255
    7e5c:	9f e7       	ldi	r25, 0x7F	; 127
    7e5e:	9e 83       	std	Y+6, r25	; 0x06
    7e60:	8d 83       	std	Y+5, r24	; 0x05
    7e62:	ae 01       	movw	r20, r28
    7e64:	47 5e       	subi	r20, 0xE7	; 231
    7e66:	5f 4f       	sbci	r21, 0xFF	; 255
    7e68:	6f 89       	ldd	r22, Y+23	; 0x17
    7e6a:	78 8d       	ldd	r23, Y+24	; 0x18
    7e6c:	ce 01       	movw	r24, r28
    7e6e:	01 96       	adiw	r24, 0x01	; 1
    7e70:	0e 94 d4 37 	call	0x6fa8	; 0x6fa8 <vfprintf>
    7e74:	ef 81       	ldd	r30, Y+7	; 0x07
    7e76:	f8 85       	ldd	r31, Y+8	; 0x08
    7e78:	e0 0f       	add	r30, r16
    7e7a:	f1 1f       	adc	r31, r17
    7e7c:	10 82       	st	Z, r1
    7e7e:	2e 96       	adiw	r28, 0x0e	; 14
    7e80:	0f b6       	in	r0, 0x3f	; 63
    7e82:	f8 94       	cli
    7e84:	de bf       	out	0x3e, r29	; 62
    7e86:	0f be       	out	0x3f, r0	; 63
    7e88:	cd bf       	out	0x3d, r28	; 61
    7e8a:	df 91       	pop	r29
    7e8c:	cf 91       	pop	r28
    7e8e:	1f 91       	pop	r17
    7e90:	0f 91       	pop	r16
    7e92:	08 95       	ret

00007e94 <sscanf>:
    7e94:	cf 93       	push	r28
    7e96:	df 93       	push	r29
    7e98:	cd b7       	in	r28, 0x3d	; 61
    7e9a:	de b7       	in	r29, 0x3e	; 62
    7e9c:	2e 97       	sbiw	r28, 0x0e	; 14
    7e9e:	0f b6       	in	r0, 0x3f	; 63
    7ea0:	f8 94       	cli
    7ea2:	de bf       	out	0x3e, r29	; 62
    7ea4:	0f be       	out	0x3f, r0	; 63
    7ea6:	cd bf       	out	0x3d, r28	; 61
    7ea8:	85 e0       	ldi	r24, 0x05	; 5
    7eaa:	8c 83       	std	Y+4, r24	; 0x04
    7eac:	8b 89       	ldd	r24, Y+19	; 0x13
    7eae:	9c 89       	ldd	r25, Y+20	; 0x14
    7eb0:	9a 83       	std	Y+2, r25	; 0x02
    7eb2:	89 83       	std	Y+1, r24	; 0x01
    7eb4:	ae 01       	movw	r20, r28
    7eb6:	49 5e       	subi	r20, 0xE9	; 233
    7eb8:	5f 4f       	sbci	r21, 0xFF	; 255
    7eba:	6d 89       	ldd	r22, Y+21	; 0x15
    7ebc:	7e 89       	ldd	r23, Y+22	; 0x16
    7ebe:	ce 01       	movw	r24, r28
    7ec0:	01 96       	adiw	r24, 0x01	; 1
    7ec2:	0e 94 67 41 	call	0x82ce	; 0x82ce <vfscanf>
    7ec6:	2e 96       	adiw	r28, 0x0e	; 14
    7ec8:	0f b6       	in	r0, 0x3f	; 63
    7eca:	f8 94       	cli
    7ecc:	de bf       	out	0x3e, r29	; 62
    7ece:	0f be       	out	0x3f, r0	; 63
    7ed0:	cd bf       	out	0x3d, r28	; 61
    7ed2:	df 91       	pop	r29
    7ed4:	cf 91       	pop	r28
    7ed6:	08 95       	ret

00007ed8 <__ultoa_invert>:
    7ed8:	fa 01       	movw	r30, r20
    7eda:	aa 27       	eor	r26, r26
    7edc:	28 30       	cpi	r18, 0x08	; 8
    7ede:	51 f1       	breq	.+84     	; 0x7f34 <__ultoa_invert+0x5c>
    7ee0:	20 31       	cpi	r18, 0x10	; 16
    7ee2:	81 f1       	breq	.+96     	; 0x7f44 <__ultoa_invert+0x6c>
    7ee4:	e8 94       	clt
    7ee6:	6f 93       	push	r22
    7ee8:	6e 7f       	andi	r22, 0xFE	; 254
    7eea:	6e 5f       	subi	r22, 0xFE	; 254
    7eec:	7f 4f       	sbci	r23, 0xFF	; 255
    7eee:	8f 4f       	sbci	r24, 0xFF	; 255
    7ef0:	9f 4f       	sbci	r25, 0xFF	; 255
    7ef2:	af 4f       	sbci	r26, 0xFF	; 255
    7ef4:	b1 e0       	ldi	r27, 0x01	; 1
    7ef6:	3e d0       	rcall	.+124    	; 0x7f74 <__ultoa_invert+0x9c>
    7ef8:	b4 e0       	ldi	r27, 0x04	; 4
    7efa:	3c d0       	rcall	.+120    	; 0x7f74 <__ultoa_invert+0x9c>
    7efc:	67 0f       	add	r22, r23
    7efe:	78 1f       	adc	r23, r24
    7f00:	89 1f       	adc	r24, r25
    7f02:	9a 1f       	adc	r25, r26
    7f04:	a1 1d       	adc	r26, r1
    7f06:	68 0f       	add	r22, r24
    7f08:	79 1f       	adc	r23, r25
    7f0a:	8a 1f       	adc	r24, r26
    7f0c:	91 1d       	adc	r25, r1
    7f0e:	a1 1d       	adc	r26, r1
    7f10:	6a 0f       	add	r22, r26
    7f12:	71 1d       	adc	r23, r1
    7f14:	81 1d       	adc	r24, r1
    7f16:	91 1d       	adc	r25, r1
    7f18:	a1 1d       	adc	r26, r1
    7f1a:	20 d0       	rcall	.+64     	; 0x7f5c <__ultoa_invert+0x84>
    7f1c:	09 f4       	brne	.+2      	; 0x7f20 <__ultoa_invert+0x48>
    7f1e:	68 94       	set
    7f20:	3f 91       	pop	r19
    7f22:	2a e0       	ldi	r18, 0x0A	; 10
    7f24:	26 9f       	mul	r18, r22
    7f26:	11 24       	eor	r1, r1
    7f28:	30 19       	sub	r19, r0
    7f2a:	30 5d       	subi	r19, 0xD0	; 208
    7f2c:	31 93       	st	Z+, r19
    7f2e:	de f6       	brtc	.-74     	; 0x7ee6 <__ultoa_invert+0xe>
    7f30:	cf 01       	movw	r24, r30
    7f32:	08 95       	ret
    7f34:	46 2f       	mov	r20, r22
    7f36:	47 70       	andi	r20, 0x07	; 7
    7f38:	40 5d       	subi	r20, 0xD0	; 208
    7f3a:	41 93       	st	Z+, r20
    7f3c:	b3 e0       	ldi	r27, 0x03	; 3
    7f3e:	0f d0       	rcall	.+30     	; 0x7f5e <__ultoa_invert+0x86>
    7f40:	c9 f7       	brne	.-14     	; 0x7f34 <__ultoa_invert+0x5c>
    7f42:	f6 cf       	rjmp	.-20     	; 0x7f30 <__ultoa_invert+0x58>
    7f44:	46 2f       	mov	r20, r22
    7f46:	4f 70       	andi	r20, 0x0F	; 15
    7f48:	40 5d       	subi	r20, 0xD0	; 208
    7f4a:	4a 33       	cpi	r20, 0x3A	; 58
    7f4c:	18 f0       	brcs	.+6      	; 0x7f54 <__ultoa_invert+0x7c>
    7f4e:	49 5d       	subi	r20, 0xD9	; 217
    7f50:	31 fd       	sbrc	r19, 1
    7f52:	40 52       	subi	r20, 0x20	; 32
    7f54:	41 93       	st	Z+, r20
    7f56:	02 d0       	rcall	.+4      	; 0x7f5c <__ultoa_invert+0x84>
    7f58:	a9 f7       	brne	.-22     	; 0x7f44 <__ultoa_invert+0x6c>
    7f5a:	ea cf       	rjmp	.-44     	; 0x7f30 <__ultoa_invert+0x58>
    7f5c:	b4 e0       	ldi	r27, 0x04	; 4
    7f5e:	a6 95       	lsr	r26
    7f60:	97 95       	ror	r25
    7f62:	87 95       	ror	r24
    7f64:	77 95       	ror	r23
    7f66:	67 95       	ror	r22
    7f68:	ba 95       	dec	r27
    7f6a:	c9 f7       	brne	.-14     	; 0x7f5e <__ultoa_invert+0x86>
    7f6c:	00 97       	sbiw	r24, 0x00	; 0
    7f6e:	61 05       	cpc	r22, r1
    7f70:	71 05       	cpc	r23, r1
    7f72:	08 95       	ret
    7f74:	9b 01       	movw	r18, r22
    7f76:	ac 01       	movw	r20, r24
    7f78:	0a 2e       	mov	r0, r26
    7f7a:	06 94       	lsr	r0
    7f7c:	57 95       	ror	r21
    7f7e:	47 95       	ror	r20
    7f80:	37 95       	ror	r19
    7f82:	27 95       	ror	r18
    7f84:	ba 95       	dec	r27
    7f86:	c9 f7       	brne	.-14     	; 0x7f7a <__ultoa_invert+0xa2>
    7f88:	62 0f       	add	r22, r18
    7f8a:	73 1f       	adc	r23, r19
    7f8c:	84 1f       	adc	r24, r20
    7f8e:	95 1f       	adc	r25, r21
    7f90:	a0 1d       	adc	r26, r0
    7f92:	08 95       	ret

00007f94 <putval>:
    7f94:	20 fd       	sbrc	r18, 0
    7f96:	09 c0       	rjmp	.+18     	; 0x7faa <putval+0x16>
    7f98:	fc 01       	movw	r30, r24
    7f9a:	23 fd       	sbrc	r18, 3
    7f9c:	05 c0       	rjmp	.+10     	; 0x7fa8 <putval+0x14>
    7f9e:	22 ff       	sbrs	r18, 2
    7fa0:	02 c0       	rjmp	.+4      	; 0x7fa6 <putval+0x12>
    7fa2:	73 83       	std	Z+3, r23	; 0x03
    7fa4:	62 83       	std	Z+2, r22	; 0x02
    7fa6:	51 83       	std	Z+1, r21	; 0x01
    7fa8:	40 83       	st	Z, r20
    7faa:	08 95       	ret

00007fac <mulacc>:
    7fac:	44 fd       	sbrc	r20, 4
    7fae:	10 c0       	rjmp	.+32     	; 0x7fd0 <mulacc+0x24>
    7fb0:	46 fd       	sbrc	r20, 6
    7fb2:	10 c0       	rjmp	.+32     	; 0x7fd4 <mulacc+0x28>
    7fb4:	db 01       	movw	r26, r22
    7fb6:	fc 01       	movw	r30, r24
    7fb8:	aa 0f       	add	r26, r26
    7fba:	bb 1f       	adc	r27, r27
    7fbc:	ee 1f       	adc	r30, r30
    7fbe:	ff 1f       	adc	r31, r31
    7fc0:	10 94       	com	r1
    7fc2:	d1 f7       	brne	.-12     	; 0x7fb8 <mulacc+0xc>
    7fc4:	6a 0f       	add	r22, r26
    7fc6:	7b 1f       	adc	r23, r27
    7fc8:	8e 1f       	adc	r24, r30
    7fca:	9f 1f       	adc	r25, r31
    7fcc:	31 e0       	ldi	r19, 0x01	; 1
    7fce:	03 c0       	rjmp	.+6      	; 0x7fd6 <mulacc+0x2a>
    7fd0:	33 e0       	ldi	r19, 0x03	; 3
    7fd2:	01 c0       	rjmp	.+2      	; 0x7fd6 <mulacc+0x2a>
    7fd4:	34 e0       	ldi	r19, 0x04	; 4
    7fd6:	66 0f       	add	r22, r22
    7fd8:	77 1f       	adc	r23, r23
    7fda:	88 1f       	adc	r24, r24
    7fdc:	99 1f       	adc	r25, r25
    7fde:	31 50       	subi	r19, 0x01	; 1
    7fe0:	d1 f7       	brne	.-12     	; 0x7fd6 <mulacc+0x2a>
    7fe2:	62 0f       	add	r22, r18
    7fe4:	71 1d       	adc	r23, r1
    7fe6:	81 1d       	adc	r24, r1
    7fe8:	91 1d       	adc	r25, r1
    7fea:	08 95       	ret

00007fec <skip_spaces>:
    7fec:	0f 93       	push	r16
    7fee:	1f 93       	push	r17
    7ff0:	cf 93       	push	r28
    7ff2:	df 93       	push	r29
    7ff4:	8c 01       	movw	r16, r24
    7ff6:	c8 01       	movw	r24, r16
    7ff8:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    7ffc:	ec 01       	movw	r28, r24
    7ffe:	97 fd       	sbrc	r25, 7
    8000:	08 c0       	rjmp	.+16     	; 0x8012 <skip_spaces+0x26>
    8002:	0e 94 bf 42 	call	0x857e	; 0x857e <isspace>
    8006:	89 2b       	or	r24, r25
    8008:	b1 f7       	brne	.-20     	; 0x7ff6 <skip_spaces+0xa>
    800a:	b8 01       	movw	r22, r16
    800c:	ce 01       	movw	r24, r28
    800e:	0e 94 20 43 	call	0x8640	; 0x8640 <ungetc>
    8012:	ce 01       	movw	r24, r28
    8014:	df 91       	pop	r29
    8016:	cf 91       	pop	r28
    8018:	1f 91       	pop	r17
    801a:	0f 91       	pop	r16
    801c:	08 95       	ret

0000801e <conv_int>:
    801e:	8f 92       	push	r8
    8020:	9f 92       	push	r9
    8022:	af 92       	push	r10
    8024:	cf 92       	push	r12
    8026:	df 92       	push	r13
    8028:	ef 92       	push	r14
    802a:	ff 92       	push	r15
    802c:	0f 93       	push	r16
    802e:	1f 93       	push	r17
    8030:	cf 93       	push	r28
    8032:	df 93       	push	r29
    8034:	ec 01       	movw	r28, r24
    8036:	a6 2e       	mov	r10, r22
    8038:	4a 01       	movw	r8, r20
    803a:	02 2f       	mov	r16, r18
    803c:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    8040:	ac 01       	movw	r20, r24
    8042:	55 27       	eor	r21, r21
    8044:	4b 32       	cpi	r20, 0x2B	; 43
    8046:	51 05       	cpc	r21, r1
    8048:	21 f0       	breq	.+8      	; 0x8052 <conv_int+0x34>
    804a:	4d 32       	cpi	r20, 0x2D	; 45
    804c:	51 05       	cpc	r21, r1
    804e:	51 f4       	brne	.+20     	; 0x8064 <conv_int+0x46>
    8050:	00 68       	ori	r16, 0x80	; 128
    8052:	aa 94       	dec	r10
    8054:	11 f4       	brne	.+4      	; 0x805a <conv_int+0x3c>
    8056:	80 e0       	ldi	r24, 0x00	; 0
    8058:	67 c0       	rjmp	.+206    	; 0x8128 <conv_int+0x10a>
    805a:	ce 01       	movw	r24, r28
    805c:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    8060:	97 fd       	sbrc	r25, 7
    8062:	f9 cf       	rjmp	.-14     	; 0x8056 <conv_int+0x38>
    8064:	10 2f       	mov	r17, r16
    8066:	1d 7f       	andi	r17, 0xFD	; 253
    8068:	30 2f       	mov	r19, r16
    806a:	30 73       	andi	r19, 0x30	; 48
    806c:	01 f5       	brne	.+64     	; 0x80ae <conv_int+0x90>
    806e:	80 33       	cpi	r24, 0x30	; 48
    8070:	f1 f4       	brne	.+60     	; 0x80ae <conv_int+0x90>
    8072:	ff 24       	eor	r15, r15
    8074:	fa 94       	dec	r15
    8076:	fa 0c       	add	r15, r10
    8078:	09 f4       	brne	.+2      	; 0x807c <conv_int+0x5e>
    807a:	42 c0       	rjmp	.+132    	; 0x8100 <conv_int+0xe2>
    807c:	ce 01       	movw	r24, r28
    807e:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    8082:	97 fd       	sbrc	r25, 7
    8084:	3d c0       	rjmp	.+122    	; 0x8100 <conv_int+0xe2>
    8086:	38 2f       	mov	r19, r24
    8088:	3f 7d       	andi	r19, 0xDF	; 223
    808a:	38 35       	cpi	r19, 0x58	; 88
    808c:	51 f4       	brne	.+20     	; 0x80a2 <conv_int+0x84>
    808e:	12 64       	ori	r17, 0x42	; 66
    8090:	aa 94       	dec	r10
    8092:	aa 94       	dec	r10
    8094:	a9 f1       	breq	.+106    	; 0x8100 <conv_int+0xe2>
    8096:	ce 01       	movw	r24, r28
    8098:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    809c:	97 ff       	sbrs	r25, 7
    809e:	07 c0       	rjmp	.+14     	; 0x80ae <conv_int+0x90>
    80a0:	2f c0       	rjmp	.+94     	; 0x8100 <conv_int+0xe2>
    80a2:	06 ff       	sbrs	r16, 6
    80a4:	02 c0       	rjmp	.+4      	; 0x80aa <conv_int+0x8c>
    80a6:	12 60       	ori	r17, 0x02	; 2
    80a8:	01 c0       	rjmp	.+2      	; 0x80ac <conv_int+0x8e>
    80aa:	12 61       	ori	r17, 0x12	; 18
    80ac:	af 2c       	mov	r10, r15
    80ae:	c1 2c       	mov	r12, r1
    80b0:	d1 2c       	mov	r13, r1
    80b2:	76 01       	movw	r14, r12
    80b4:	20 ed       	ldi	r18, 0xD0	; 208
    80b6:	28 0f       	add	r18, r24
    80b8:	28 30       	cpi	r18, 0x08	; 8
    80ba:	80 f0       	brcs	.+32     	; 0x80dc <conv_int+0xbe>
    80bc:	14 ff       	sbrs	r17, 4
    80be:	04 c0       	rjmp	.+8      	; 0x80c8 <conv_int+0xaa>
    80c0:	be 01       	movw	r22, r28
    80c2:	0e 94 20 43 	call	0x8640	; 0x8640 <ungetc>
    80c6:	19 c0       	rjmp	.+50     	; 0x80fa <conv_int+0xdc>
    80c8:	2a 30       	cpi	r18, 0x0A	; 10
    80ca:	40 f0       	brcs	.+16     	; 0x80dc <conv_int+0xbe>
    80cc:	16 ff       	sbrs	r17, 6
    80ce:	f8 cf       	rjmp	.-16     	; 0x80c0 <conv_int+0xa2>
    80d0:	2f 7d       	andi	r18, 0xDF	; 223
    80d2:	3f ee       	ldi	r19, 0xEF	; 239
    80d4:	32 0f       	add	r19, r18
    80d6:	36 30       	cpi	r19, 0x06	; 6
    80d8:	98 f7       	brcc	.-26     	; 0x80c0 <conv_int+0xa2>
    80da:	27 50       	subi	r18, 0x07	; 7
    80dc:	41 2f       	mov	r20, r17
    80de:	c7 01       	movw	r24, r14
    80e0:	b6 01       	movw	r22, r12
    80e2:	0e 94 d6 3f 	call	0x7fac	; 0x7fac <mulacc>
    80e6:	6b 01       	movw	r12, r22
    80e8:	7c 01       	movw	r14, r24
    80ea:	12 60       	ori	r17, 0x02	; 2
    80ec:	aa 94       	dec	r10
    80ee:	59 f0       	breq	.+22     	; 0x8106 <conv_int+0xe8>
    80f0:	ce 01       	movw	r24, r28
    80f2:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    80f6:	97 ff       	sbrs	r25, 7
    80f8:	dd cf       	rjmp	.-70     	; 0x80b4 <conv_int+0x96>
    80fa:	11 fd       	sbrc	r17, 1
    80fc:	04 c0       	rjmp	.+8      	; 0x8106 <conv_int+0xe8>
    80fe:	ab cf       	rjmp	.-170    	; 0x8056 <conv_int+0x38>
    8100:	c1 2c       	mov	r12, r1
    8102:	d1 2c       	mov	r13, r1
    8104:	76 01       	movw	r14, r12
    8106:	17 ff       	sbrs	r17, 7
    8108:	08 c0       	rjmp	.+16     	; 0x811a <conv_int+0xfc>
    810a:	f0 94       	com	r15
    810c:	e0 94       	com	r14
    810e:	d0 94       	com	r13
    8110:	c0 94       	com	r12
    8112:	c1 1c       	adc	r12, r1
    8114:	d1 1c       	adc	r13, r1
    8116:	e1 1c       	adc	r14, r1
    8118:	f1 1c       	adc	r15, r1
    811a:	21 2f       	mov	r18, r17
    811c:	b7 01       	movw	r22, r14
    811e:	a6 01       	movw	r20, r12
    8120:	c4 01       	movw	r24, r8
    8122:	0e 94 ca 3f 	call	0x7f94	; 0x7f94 <putval>
    8126:	81 e0       	ldi	r24, 0x01	; 1
    8128:	df 91       	pop	r29
    812a:	cf 91       	pop	r28
    812c:	1f 91       	pop	r17
    812e:	0f 91       	pop	r16
    8130:	ff 90       	pop	r15
    8132:	ef 90       	pop	r14
    8134:	df 90       	pop	r13
    8136:	cf 90       	pop	r12
    8138:	af 90       	pop	r10
    813a:	9f 90       	pop	r9
    813c:	8f 90       	pop	r8
    813e:	08 95       	ret

00008140 <conv_brk>:
    8140:	7f 92       	push	r7
    8142:	8f 92       	push	r8
    8144:	9f 92       	push	r9
    8146:	af 92       	push	r10
    8148:	bf 92       	push	r11
    814a:	cf 92       	push	r12
    814c:	df 92       	push	r13
    814e:	ef 92       	push	r14
    8150:	ff 92       	push	r15
    8152:	0f 93       	push	r16
    8154:	1f 93       	push	r17
    8156:	cf 93       	push	r28
    8158:	df 93       	push	r29
    815a:	cd b7       	in	r28, 0x3d	; 61
    815c:	de b7       	in	r29, 0x3e	; 62
    815e:	a1 97       	sbiw	r28, 0x21	; 33
    8160:	0f b6       	in	r0, 0x3f	; 63
    8162:	f8 94       	cli
    8164:	de bf       	out	0x3e, r29	; 62
    8166:	0f be       	out	0x3f, r0	; 63
    8168:	cd bf       	out	0x3d, r28	; 61
    816a:	5c 01       	movw	r10, r24
    816c:	7a 01       	movw	r14, r20
    816e:	8e 01       	movw	r16, r28
    8170:	0f 5f       	subi	r16, 0xFF	; 255
    8172:	1f 4f       	sbci	r17, 0xFF	; 255
    8174:	68 01       	movw	r12, r16
    8176:	80 e2       	ldi	r24, 0x20	; 32
    8178:	d8 01       	movw	r26, r16
    817a:	1d 92       	st	X+, r1
    817c:	8a 95       	dec	r24
    817e:	e9 f7       	brne	.-6      	; 0x817a <conv_brk+0x3a>
    8180:	f5 01       	movw	r30, r10
    8182:	73 80       	ldd	r7, Z+3	; 0x03
    8184:	40 e0       	ldi	r20, 0x00	; 0
    8186:	50 e0       	ldi	r21, 0x00	; 0
    8188:	81 2c       	mov	r8, r1
    818a:	b0 e0       	ldi	r27, 0x00	; 0
    818c:	91 2c       	mov	r9, r1
    818e:	81 e0       	ldi	r24, 0x01	; 1
    8190:	90 e0       	ldi	r25, 0x00	; 0
    8192:	f9 01       	movw	r30, r18
    8194:	73 fc       	sbrc	r7, 3
    8196:	a5 91       	lpm	r26, Z+
    8198:	73 fe       	sbrs	r7, 3
    819a:	a1 91       	ld	r26, Z+
    819c:	8f 01       	movw	r16, r30
    819e:	7a 2f       	mov	r23, r26
    81a0:	9f 01       	movw	r18, r30
    81a2:	a1 11       	cpse	r26, r1
    81a4:	03 c0       	rjmp	.+6      	; 0x81ac <conv_brk+0x6c>
    81a6:	80 e0       	ldi	r24, 0x00	; 0
    81a8:	90 e0       	ldi	r25, 0x00	; 0
    81aa:	7d c0       	rjmp	.+250    	; 0x82a6 <conv_brk+0x166>
    81ac:	ae 35       	cpi	r26, 0x5E	; 94
    81ae:	19 f4       	brne	.+6      	; 0x81b6 <conv_brk+0x76>
    81b0:	41 15       	cp	r20, r1
    81b2:	51 05       	cpc	r21, r1
    81b4:	59 f1       	breq	.+86     	; 0x820c <conv_brk+0xcc>
    81b6:	e9 2d       	mov	r30, r9
    81b8:	f0 e0       	ldi	r31, 0x00	; 0
    81ba:	e4 17       	cp	r30, r20
    81bc:	f5 07       	cpc	r31, r21
    81be:	3c f4       	brge	.+14     	; 0x81ce <conv_brk+0x8e>
    81c0:	ad 35       	cpi	r26, 0x5D	; 93
    81c2:	69 f1       	breq	.+90     	; 0x821e <conv_brk+0xde>
    81c4:	ad 32       	cpi	r26, 0x2D	; 45
    81c6:	19 f4       	brne	.+6      	; 0x81ce <conv_brk+0x8e>
    81c8:	bb 23       	and	r27, r27
    81ca:	19 f1       	breq	.+70     	; 0x8212 <conv_brk+0xd2>
    81cc:	03 c0       	rjmp	.+6      	; 0x81d4 <conv_brk+0x94>
    81ce:	b1 11       	cpse	r27, r1
    81d0:	01 c0       	rjmp	.+2      	; 0x81d4 <conv_brk+0x94>
    81d2:	8a 2e       	mov	r8, r26
    81d4:	e7 2f       	mov	r30, r23
    81d6:	e6 95       	lsr	r30
    81d8:	e6 95       	lsr	r30
    81da:	e6 95       	lsr	r30
    81dc:	86 01       	movw	r16, r12
    81de:	0e 0f       	add	r16, r30
    81e0:	11 1d       	adc	r17, r1
    81e2:	f8 01       	movw	r30, r16
    81e4:	a7 2f       	mov	r26, r23
    81e6:	a7 70       	andi	r26, 0x07	; 7
    81e8:	8c 01       	movw	r16, r24
    81ea:	02 c0       	rjmp	.+4      	; 0x81f0 <conv_brk+0xb0>
    81ec:	00 0f       	add	r16, r16
    81ee:	11 1f       	adc	r17, r17
    81f0:	aa 95       	dec	r26
    81f2:	e2 f7       	brpl	.-8      	; 0x81ec <conv_brk+0xac>
    81f4:	d8 01       	movw	r26, r16
    81f6:	b0 81       	ld	r27, Z
    81f8:	ba 2b       	or	r27, r26
    81fa:	b0 83       	st	Z, r27
    81fc:	78 15       	cp	r23, r8
    81fe:	59 f0       	breq	.+22     	; 0x8216 <conv_brk+0xd6>
    8200:	78 15       	cp	r23, r8
    8202:	10 f4       	brcc	.+4      	; 0x8208 <conv_brk+0xc8>
    8204:	7f 5f       	subi	r23, 0xFF	; 255
    8206:	e6 cf       	rjmp	.-52     	; 0x81d4 <conv_brk+0x94>
    8208:	71 50       	subi	r23, 0x01	; 1
    820a:	e4 cf       	rjmp	.-56     	; 0x81d4 <conv_brk+0x94>
    820c:	99 24       	eor	r9, r9
    820e:	93 94       	inc	r9
    8210:	03 c0       	rjmp	.+6      	; 0x8218 <conv_brk+0xd8>
    8212:	b1 e0       	ldi	r27, 0x01	; 1
    8214:	01 c0       	rjmp	.+2      	; 0x8218 <conv_brk+0xd8>
    8216:	b0 e0       	ldi	r27, 0x00	; 0
    8218:	4f 5f       	subi	r20, 0xFF	; 255
    821a:	5f 4f       	sbci	r21, 0xFF	; 255
    821c:	ba cf       	rjmp	.-140    	; 0x8192 <conv_brk+0x52>
    821e:	bb 23       	and	r27, r27
    8220:	19 f0       	breq	.+6      	; 0x8228 <conv_brk+0xe8>
    8222:	8e 81       	ldd	r24, Y+6	; 0x06
    8224:	80 62       	ori	r24, 0x20	; 32
    8226:	8e 83       	std	Y+6, r24	; 0x06
    8228:	91 10       	cpse	r9, r1
    822a:	03 c0       	rjmp	.+6      	; 0x8232 <conv_brk+0xf2>
    822c:	99 24       	eor	r9, r9
    822e:	93 94       	inc	r9
    8230:	15 c0       	rjmp	.+42     	; 0x825c <conv_brk+0x11c>
    8232:	f6 01       	movw	r30, r12
    8234:	ce 01       	movw	r24, r28
    8236:	81 96       	adiw	r24, 0x21	; 33
    8238:	20 81       	ld	r18, Z
    823a:	20 95       	com	r18
    823c:	21 93       	st	Z+, r18
    823e:	e8 17       	cp	r30, r24
    8240:	f9 07       	cpc	r31, r25
    8242:	d1 f7       	brne	.-12     	; 0x8238 <conv_brk+0xf8>
    8244:	f3 cf       	rjmp	.-26     	; 0x822c <conv_brk+0xec>
    8246:	e1 14       	cp	r14, r1
    8248:	f1 04       	cpc	r15, r1
    824a:	29 f0       	breq	.+10     	; 0x8256 <conv_brk+0x116>
    824c:	d7 01       	movw	r26, r14
    824e:	8c 93       	st	X, r24
    8250:	f7 01       	movw	r30, r14
    8252:	31 96       	adiw	r30, 0x01	; 1
    8254:	7f 01       	movw	r14, r30
    8256:	61 50       	subi	r22, 0x01	; 1
    8258:	01 f1       	breq	.+64     	; 0x829a <conv_brk+0x15a>
    825a:	91 2c       	mov	r9, r1
    825c:	c5 01       	movw	r24, r10
    825e:	69 a3       	std	Y+33, r22	; 0x21
    8260:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    8264:	69 a1       	ldd	r22, Y+33	; 0x21
    8266:	97 fd       	sbrc	r25, 7
    8268:	16 c0       	rjmp	.+44     	; 0x8296 <conv_brk+0x156>
    826a:	28 2f       	mov	r18, r24
    826c:	26 95       	lsr	r18
    826e:	26 95       	lsr	r18
    8270:	26 95       	lsr	r18
    8272:	f6 01       	movw	r30, r12
    8274:	e2 0f       	add	r30, r18
    8276:	f1 1d       	adc	r31, r1
    8278:	20 81       	ld	r18, Z
    827a:	30 e0       	ldi	r19, 0x00	; 0
    827c:	ac 01       	movw	r20, r24
    827e:	47 70       	andi	r20, 0x07	; 7
    8280:	55 27       	eor	r21, r21
    8282:	02 c0       	rjmp	.+4      	; 0x8288 <conv_brk+0x148>
    8284:	35 95       	asr	r19
    8286:	27 95       	ror	r18
    8288:	4a 95       	dec	r20
    828a:	e2 f7       	brpl	.-8      	; 0x8284 <conv_brk+0x144>
    828c:	20 fd       	sbrc	r18, 0
    828e:	db cf       	rjmp	.-74     	; 0x8246 <conv_brk+0x106>
    8290:	b5 01       	movw	r22, r10
    8292:	0e 94 20 43 	call	0x8640	; 0x8640 <ungetc>
    8296:	91 10       	cpse	r9, r1
    8298:	86 cf       	rjmp	.-244    	; 0x81a6 <conv_brk+0x66>
    829a:	e1 14       	cp	r14, r1
    829c:	f1 04       	cpc	r15, r1
    829e:	11 f0       	breq	.+4      	; 0x82a4 <conv_brk+0x164>
    82a0:	d7 01       	movw	r26, r14
    82a2:	1c 92       	st	X, r1
    82a4:	c8 01       	movw	r24, r16
    82a6:	a1 96       	adiw	r28, 0x21	; 33
    82a8:	0f b6       	in	r0, 0x3f	; 63
    82aa:	f8 94       	cli
    82ac:	de bf       	out	0x3e, r29	; 62
    82ae:	0f be       	out	0x3f, r0	; 63
    82b0:	cd bf       	out	0x3d, r28	; 61
    82b2:	df 91       	pop	r29
    82b4:	cf 91       	pop	r28
    82b6:	1f 91       	pop	r17
    82b8:	0f 91       	pop	r16
    82ba:	ff 90       	pop	r15
    82bc:	ef 90       	pop	r14
    82be:	df 90       	pop	r13
    82c0:	cf 90       	pop	r12
    82c2:	bf 90       	pop	r11
    82c4:	af 90       	pop	r10
    82c6:	9f 90       	pop	r9
    82c8:	8f 90       	pop	r8
    82ca:	7f 90       	pop	r7
    82cc:	08 95       	ret

000082ce <vfscanf>:
    82ce:	4f 92       	push	r4
    82d0:	5f 92       	push	r5
    82d2:	7f 92       	push	r7
    82d4:	8f 92       	push	r8
    82d6:	9f 92       	push	r9
    82d8:	af 92       	push	r10
    82da:	bf 92       	push	r11
    82dc:	cf 92       	push	r12
    82de:	df 92       	push	r13
    82e0:	ef 92       	push	r14
    82e2:	ff 92       	push	r15
    82e4:	0f 93       	push	r16
    82e6:	1f 93       	push	r17
    82e8:	cf 93       	push	r28
    82ea:	df 93       	push	r29
    82ec:	1f 92       	push	r1
    82ee:	cd b7       	in	r28, 0x3d	; 61
    82f0:	de b7       	in	r29, 0x3e	; 62
    82f2:	8c 01       	movw	r16, r24
    82f4:	2b 01       	movw	r4, r22
    82f6:	7a 01       	movw	r14, r20
    82f8:	fc 01       	movw	r30, r24
    82fa:	17 82       	std	Z+7, r1	; 0x07
    82fc:	16 82       	std	Z+6, r1	; 0x06
    82fe:	a1 2c       	mov	r10, r1
    8300:	f8 01       	movw	r30, r16
    8302:	d3 80       	ldd	r13, Z+3	; 0x03
    8304:	f2 01       	movw	r30, r4
    8306:	d3 fc       	sbrc	r13, 3
    8308:	85 91       	lpm	r24, Z+
    830a:	d3 fe       	sbrs	r13, 3
    830c:	81 91       	ld	r24, Z+
    830e:	38 2f       	mov	r19, r24
    8310:	2f 01       	movw	r4, r30
    8312:	88 23       	and	r24, r24
    8314:	09 f4       	brne	.+2      	; 0x8318 <vfscanf+0x4a>
    8316:	fc c0       	rjmp	.+504    	; 0x8510 <vfscanf+0x242>
    8318:	90 e0       	ldi	r25, 0x00	; 0
    831a:	39 83       	std	Y+1, r19	; 0x01
    831c:	0e 94 bf 42 	call	0x857e	; 0x857e <isspace>
    8320:	39 81       	ldd	r19, Y+1	; 0x01
    8322:	89 2b       	or	r24, r25
    8324:	21 f0       	breq	.+8      	; 0x832e <vfscanf+0x60>
    8326:	c8 01       	movw	r24, r16
    8328:	0e 94 f6 3f 	call	0x7fec	; 0x7fec <skip_spaces>
    832c:	e9 cf       	rjmp	.-46     	; 0x8300 <vfscanf+0x32>
    832e:	35 32       	cpi	r19, 0x25	; 37
    8330:	41 f4       	brne	.+16     	; 0x8342 <vfscanf+0x74>
    8332:	f2 01       	movw	r30, r4
    8334:	d3 fc       	sbrc	r13, 3
    8336:	35 91       	lpm	r19, Z+
    8338:	d3 fe       	sbrs	r13, 3
    833a:	31 91       	ld	r19, Z+
    833c:	2f 01       	movw	r4, r30
    833e:	35 32       	cpi	r19, 0x25	; 37
    8340:	69 f4       	brne	.+26     	; 0x835c <vfscanf+0x8e>
    8342:	c8 01       	movw	r24, r16
    8344:	39 83       	std	Y+1, r19	; 0x01
    8346:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    834a:	39 81       	ldd	r19, Y+1	; 0x01
    834c:	97 fd       	sbrc	r25, 7
    834e:	de c0       	rjmp	.+444    	; 0x850c <vfscanf+0x23e>
    8350:	38 17       	cp	r19, r24
    8352:	b1 f2       	breq	.-84     	; 0x8300 <vfscanf+0x32>
    8354:	b8 01       	movw	r22, r16
    8356:	0e 94 20 43 	call	0x8640	; 0x8640 <ungetc>
    835a:	da c0       	rjmp	.+436    	; 0x8510 <vfscanf+0x242>
    835c:	3a 32       	cpi	r19, 0x2A	; 42
    835e:	41 f4       	brne	.+16     	; 0x8370 <vfscanf+0xa2>
    8360:	d3 fc       	sbrc	r13, 3
    8362:	35 91       	lpm	r19, Z+
    8364:	d3 fe       	sbrs	r13, 3
    8366:	31 91       	ld	r19, Z+
    8368:	2f 01       	movw	r4, r30
    836a:	bb 24       	eor	r11, r11
    836c:	b3 94       	inc	r11
    836e:	01 c0       	rjmp	.+2      	; 0x8372 <vfscanf+0xa4>
    8370:	b1 2c       	mov	r11, r1
    8372:	71 2c       	mov	r7, r1
    8374:	20 ed       	ldi	r18, 0xD0	; 208
    8376:	23 0f       	add	r18, r19
    8378:	2a 30       	cpi	r18, 0x0A	; 10
    837a:	90 f4       	brcc	.+36     	; 0x83a0 <vfscanf+0xd2>
    837c:	fb 2d       	mov	r31, r11
    837e:	f2 60       	ori	r31, 0x02	; 2
    8380:	bf 2e       	mov	r11, r31
    8382:	67 2d       	mov	r22, r7
    8384:	70 e0       	ldi	r23, 0x00	; 0
    8386:	80 e0       	ldi	r24, 0x00	; 0
    8388:	90 e0       	ldi	r25, 0x00	; 0
    838a:	40 e2       	ldi	r20, 0x20	; 32
    838c:	0e 94 d6 3f 	call	0x7fac	; 0x7fac <mulacc>
    8390:	76 2e       	mov	r7, r22
    8392:	f2 01       	movw	r30, r4
    8394:	d3 fc       	sbrc	r13, 3
    8396:	35 91       	lpm	r19, Z+
    8398:	d3 fe       	sbrs	r13, 3
    839a:	31 91       	ld	r19, Z+
    839c:	2f 01       	movw	r4, r30
    839e:	ea cf       	rjmp	.-44     	; 0x8374 <vfscanf+0xa6>
    83a0:	b1 fe       	sbrs	r11, 1
    83a2:	03 c0       	rjmp	.+6      	; 0x83aa <vfscanf+0xdc>
    83a4:	71 10       	cpse	r7, r1
    83a6:	03 c0       	rjmp	.+6      	; 0x83ae <vfscanf+0xe0>
    83a8:	b3 c0       	rjmp	.+358    	; 0x8510 <vfscanf+0x242>
    83aa:	77 24       	eor	r7, r7
    83ac:	7a 94       	dec	r7
    83ae:	38 36       	cpi	r19, 0x68	; 104
    83b0:	19 f0       	breq	.+6      	; 0x83b8 <vfscanf+0xea>
    83b2:	3c 36       	cpi	r19, 0x6C	; 108
    83b4:	61 f0       	breq	.+24     	; 0x83ce <vfscanf+0x100>
    83b6:	14 c0       	rjmp	.+40     	; 0x83e0 <vfscanf+0x112>
    83b8:	f2 01       	movw	r30, r4
    83ba:	d3 fc       	sbrc	r13, 3
    83bc:	35 91       	lpm	r19, Z+
    83be:	d3 fe       	sbrs	r13, 3
    83c0:	31 91       	ld	r19, Z+
    83c2:	2f 01       	movw	r4, r30
    83c4:	38 36       	cpi	r19, 0x68	; 104
    83c6:	61 f4       	brne	.+24     	; 0x83e0 <vfscanf+0x112>
    83c8:	fb 2d       	mov	r31, r11
    83ca:	f8 60       	ori	r31, 0x08	; 8
    83cc:	bf 2e       	mov	r11, r31
    83ce:	8b 2d       	mov	r24, r11
    83d0:	84 60       	ori	r24, 0x04	; 4
    83d2:	b8 2e       	mov	r11, r24
    83d4:	f2 01       	movw	r30, r4
    83d6:	d3 fc       	sbrc	r13, 3
    83d8:	35 91       	lpm	r19, Z+
    83da:	d3 fe       	sbrs	r13, 3
    83dc:	31 91       	ld	r19, Z+
    83de:	2f 01       	movw	r4, r30
    83e0:	33 23       	and	r19, r19
    83e2:	09 f4       	brne	.+2      	; 0x83e6 <vfscanf+0x118>
    83e4:	95 c0       	rjmp	.+298    	; 0x8510 <vfscanf+0x242>
    83e6:	63 2f       	mov	r22, r19
    83e8:	70 e0       	ldi	r23, 0x00	; 0
    83ea:	88 e3       	ldi	r24, 0x38	; 56
    83ec:	97 e1       	ldi	r25, 0x17	; 23
    83ee:	39 83       	std	Y+1, r19	; 0x01
    83f0:	0e 94 c7 42 	call	0x858e	; 0x858e <strchr_P>
    83f4:	39 81       	ldd	r19, Y+1	; 0x01
    83f6:	89 2b       	or	r24, r25
    83f8:	09 f4       	brne	.+2      	; 0x83fc <vfscanf+0x12e>
    83fa:	8a c0       	rjmp	.+276    	; 0x8510 <vfscanf+0x242>
    83fc:	b0 fc       	sbrc	r11, 0
    83fe:	07 c0       	rjmp	.+14     	; 0x840e <vfscanf+0x140>
    8400:	f7 01       	movw	r30, r14
    8402:	c0 80       	ld	r12, Z
    8404:	d1 80       	ldd	r13, Z+1	; 0x01
    8406:	c7 01       	movw	r24, r14
    8408:	02 96       	adiw	r24, 0x02	; 2
    840a:	7c 01       	movw	r14, r24
    840c:	02 c0       	rjmp	.+4      	; 0x8412 <vfscanf+0x144>
    840e:	c1 2c       	mov	r12, r1
    8410:	d1 2c       	mov	r13, r1
    8412:	3e 36       	cpi	r19, 0x6E	; 110
    8414:	51 f4       	brne	.+20     	; 0x842a <vfscanf+0x15c>
    8416:	f8 01       	movw	r30, r16
    8418:	46 81       	ldd	r20, Z+6	; 0x06
    841a:	57 81       	ldd	r21, Z+7	; 0x07
    841c:	60 e0       	ldi	r22, 0x00	; 0
    841e:	70 e0       	ldi	r23, 0x00	; 0
    8420:	2b 2d       	mov	r18, r11
    8422:	c6 01       	movw	r24, r12
    8424:	0e 94 ca 3f 	call	0x7f94	; 0x7f94 <putval>
    8428:	6b cf       	rjmp	.-298    	; 0x8300 <vfscanf+0x32>
    842a:	33 36       	cpi	r19, 0x63	; 99
    842c:	a1 f4       	brne	.+40     	; 0x8456 <vfscanf+0x188>
    842e:	b1 fc       	sbrc	r11, 1
    8430:	02 c0       	rjmp	.+4      	; 0x8436 <vfscanf+0x168>
    8432:	77 24       	eor	r7, r7
    8434:	73 94       	inc	r7
    8436:	c8 01       	movw	r24, r16
    8438:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    843c:	97 fd       	sbrc	r25, 7
    843e:	66 c0       	rjmp	.+204    	; 0x850c <vfscanf+0x23e>
    8440:	c1 14       	cp	r12, r1
    8442:	d1 04       	cpc	r13, r1
    8444:	29 f0       	breq	.+10     	; 0x8450 <vfscanf+0x182>
    8446:	f6 01       	movw	r30, r12
    8448:	80 83       	st	Z, r24
    844a:	c6 01       	movw	r24, r12
    844c:	01 96       	adiw	r24, 0x01	; 1
    844e:	6c 01       	movw	r12, r24
    8450:	7a 94       	dec	r7
    8452:	89 f7       	brne	.-30     	; 0x8436 <vfscanf+0x168>
    8454:	57 c0       	rjmp	.+174    	; 0x8504 <vfscanf+0x236>
    8456:	3b 35       	cpi	r19, 0x5B	; 91
    8458:	59 f4       	brne	.+22     	; 0x8470 <vfscanf+0x1a2>
    845a:	92 01       	movw	r18, r4
    845c:	a6 01       	movw	r20, r12
    845e:	67 2d       	mov	r22, r7
    8460:	c8 01       	movw	r24, r16
    8462:	0e 94 a0 40 	call	0x8140	; 0x8140 <conv_brk>
    8466:	2c 01       	movw	r4, r24
    8468:	00 97       	sbiw	r24, 0x00	; 0
    846a:	09 f0       	breq	.+2      	; 0x846e <vfscanf+0x1a0>
    846c:	4b c0       	rjmp	.+150    	; 0x8504 <vfscanf+0x236>
    846e:	45 c0       	rjmp	.+138    	; 0x84fa <vfscanf+0x22c>
    8470:	c8 01       	movw	r24, r16
    8472:	39 83       	std	Y+1, r19	; 0x01
    8474:	0e 94 f6 3f 	call	0x7fec	; 0x7fec <skip_spaces>
    8478:	39 81       	ldd	r19, Y+1	; 0x01
    847a:	97 fd       	sbrc	r25, 7
    847c:	47 c0       	rjmp	.+142    	; 0x850c <vfscanf+0x23e>
    847e:	3f 36       	cpi	r19, 0x6F	; 111
    8480:	69 f1       	breq	.+90     	; 0x84dc <vfscanf+0x20e>
    8482:	28 f4       	brcc	.+10     	; 0x848e <vfscanf+0x1c0>
    8484:	34 36       	cpi	r19, 0x64	; 100
    8486:	31 f1       	breq	.+76     	; 0x84d4 <vfscanf+0x206>
    8488:	39 36       	cpi	r19, 0x69	; 105
    848a:	79 f1       	breq	.+94     	; 0x84ea <vfscanf+0x21c>
    848c:	2b c0       	rjmp	.+86     	; 0x84e4 <vfscanf+0x216>
    848e:	33 37       	cpi	r19, 0x73	; 115
    8490:	69 f0       	breq	.+26     	; 0x84ac <vfscanf+0x1de>
    8492:	35 37       	cpi	r19, 0x75	; 117
    8494:	f9 f0       	breq	.+62     	; 0x84d4 <vfscanf+0x206>
    8496:	26 c0       	rjmp	.+76     	; 0x84e4 <vfscanf+0x216>
    8498:	c1 14       	cp	r12, r1
    849a:	d1 04       	cpc	r13, r1
    849c:	29 f0       	breq	.+10     	; 0x84a8 <vfscanf+0x1da>
    849e:	f6 01       	movw	r30, r12
    84a0:	80 82       	st	Z, r8
    84a2:	c6 01       	movw	r24, r12
    84a4:	01 96       	adiw	r24, 0x01	; 1
    84a6:	6c 01       	movw	r12, r24
    84a8:	7a 94       	dec	r7
    84aa:	71 f0       	breq	.+28     	; 0x84c8 <vfscanf+0x1fa>
    84ac:	c8 01       	movw	r24, r16
    84ae:	0e 94 e2 42 	call	0x85c4	; 0x85c4 <fgetc>
    84b2:	4c 01       	movw	r8, r24
    84b4:	97 fd       	sbrc	r25, 7
    84b6:	08 c0       	rjmp	.+16     	; 0x84c8 <vfscanf+0x1fa>
    84b8:	0e 94 bf 42 	call	0x857e	; 0x857e <isspace>
    84bc:	89 2b       	or	r24, r25
    84be:	61 f3       	breq	.-40     	; 0x8498 <vfscanf+0x1ca>
    84c0:	b8 01       	movw	r22, r16
    84c2:	c4 01       	movw	r24, r8
    84c4:	0e 94 20 43 	call	0x8640	; 0x8640 <ungetc>
    84c8:	c1 14       	cp	r12, r1
    84ca:	d1 04       	cpc	r13, r1
    84cc:	d9 f0       	breq	.+54     	; 0x8504 <vfscanf+0x236>
    84ce:	f6 01       	movw	r30, r12
    84d0:	10 82       	st	Z, r1
    84d2:	18 c0       	rjmp	.+48     	; 0x8504 <vfscanf+0x236>
    84d4:	fb 2d       	mov	r31, r11
    84d6:	f0 62       	ori	r31, 0x20	; 32
    84d8:	bf 2e       	mov	r11, r31
    84da:	07 c0       	rjmp	.+14     	; 0x84ea <vfscanf+0x21c>
    84dc:	8b 2d       	mov	r24, r11
    84de:	80 61       	ori	r24, 0x10	; 16
    84e0:	b8 2e       	mov	r11, r24
    84e2:	03 c0       	rjmp	.+6      	; 0x84ea <vfscanf+0x21c>
    84e4:	9b 2d       	mov	r25, r11
    84e6:	90 64       	ori	r25, 0x40	; 64
    84e8:	b9 2e       	mov	r11, r25
    84ea:	2b 2d       	mov	r18, r11
    84ec:	a6 01       	movw	r20, r12
    84ee:	67 2d       	mov	r22, r7
    84f0:	c8 01       	movw	r24, r16
    84f2:	0e 94 0f 40 	call	0x801e	; 0x801e <conv_int>
    84f6:	81 11       	cpse	r24, r1
    84f8:	05 c0       	rjmp	.+10     	; 0x8504 <vfscanf+0x236>
    84fa:	f8 01       	movw	r30, r16
    84fc:	83 81       	ldd	r24, Z+3	; 0x03
    84fe:	80 73       	andi	r24, 0x30	; 48
    8500:	29 f4       	brne	.+10     	; 0x850c <vfscanf+0x23e>
    8502:	06 c0       	rjmp	.+12     	; 0x8510 <vfscanf+0x242>
    8504:	b0 fc       	sbrc	r11, 0
    8506:	fc ce       	rjmp	.-520    	; 0x8300 <vfscanf+0x32>
    8508:	a3 94       	inc	r10
    850a:	fa ce       	rjmp	.-524    	; 0x8300 <vfscanf+0x32>
    850c:	aa 20       	and	r10, r10
    850e:	19 f0       	breq	.+6      	; 0x8516 <vfscanf+0x248>
    8510:	8a 2d       	mov	r24, r10
    8512:	90 e0       	ldi	r25, 0x00	; 0
    8514:	02 c0       	rjmp	.+4      	; 0x851a <vfscanf+0x24c>
    8516:	8f ef       	ldi	r24, 0xFF	; 255
    8518:	9f ef       	ldi	r25, 0xFF	; 255
    851a:	0f 90       	pop	r0
    851c:	df 91       	pop	r29
    851e:	cf 91       	pop	r28
    8520:	1f 91       	pop	r17
    8522:	0f 91       	pop	r16
    8524:	ff 90       	pop	r15
    8526:	ef 90       	pop	r14
    8528:	df 90       	pop	r13
    852a:	cf 90       	pop	r12
    852c:	bf 90       	pop	r11
    852e:	af 90       	pop	r10
    8530:	9f 90       	pop	r9
    8532:	8f 90       	pop	r8
    8534:	7f 90       	pop	r7
    8536:	5f 90       	pop	r5
    8538:	4f 90       	pop	r4
    853a:	08 95       	ret

0000853c <__eerd_byte_m1284p>:
    853c:	f9 99       	sbic	0x1f, 1	; 31
    853e:	fe cf       	rjmp	.-4      	; 0x853c <__eerd_byte_m1284p>
    8540:	92 bd       	out	0x22, r25	; 34
    8542:	81 bd       	out	0x21, r24	; 33
    8544:	f8 9a       	sbi	0x1f, 0	; 31
    8546:	99 27       	eor	r25, r25
    8548:	80 b5       	in	r24, 0x20	; 32
    854a:	08 95       	ret

0000854c <__eerd_word_m1284p>:
    854c:	a8 e1       	ldi	r26, 0x18	; 24
    854e:	b0 e0       	ldi	r27, 0x00	; 0
    8550:	42 e0       	ldi	r20, 0x02	; 2
    8552:	50 e0       	ldi	r21, 0x00	; 0
    8554:	0c 94 3b 43 	jmp	0x8676	; 0x8676 <__eerd_blraw_m1284p>

00008558 <__eewr_byte_m1284p>:
    8558:	26 2f       	mov	r18, r22

0000855a <__eewr_r18_m1284p>:
    855a:	f9 99       	sbic	0x1f, 1	; 31
    855c:	fe cf       	rjmp	.-4      	; 0x855a <__eewr_r18_m1284p>
    855e:	1f ba       	out	0x1f, r1	; 31
    8560:	92 bd       	out	0x22, r25	; 34
    8562:	81 bd       	out	0x21, r24	; 33
    8564:	20 bd       	out	0x20, r18	; 32
    8566:	0f b6       	in	r0, 0x3f	; 63
    8568:	f8 94       	cli
    856a:	fa 9a       	sbi	0x1f, 2	; 31
    856c:	f9 9a       	sbi	0x1f, 1	; 31
    856e:	0f be       	out	0x3f, r0	; 63
    8570:	01 96       	adiw	r24, 0x01	; 1
    8572:	08 95       	ret

00008574 <__eewr_word_m1284p>:
    8574:	0e 94 ac 42 	call	0x8558	; 0x8558 <__eewr_byte_m1284p>
    8578:	27 2f       	mov	r18, r23
    857a:	0c 94 ad 42 	jmp	0x855a	; 0x855a <__eewr_r18_m1284p>

0000857e <isspace>:
    857e:	91 11       	cpse	r25, r1
    8580:	88 c0       	rjmp	.+272    	; 0x8692 <__ctype_isfalse>
    8582:	80 32       	cpi	r24, 0x20	; 32
    8584:	19 f0       	breq	.+6      	; 0x858c <isspace+0xe>
    8586:	89 50       	subi	r24, 0x09	; 9
    8588:	85 50       	subi	r24, 0x05	; 5
    858a:	d0 f7       	brcc	.-12     	; 0x8580 <isspace+0x2>
    858c:	08 95       	ret

0000858e <strchr_P>:
    858e:	fc 01       	movw	r30, r24
    8590:	05 90       	lpm	r0, Z+
    8592:	06 16       	cp	r0, r22
    8594:	21 f0       	breq	.+8      	; 0x859e <strchr_P+0x10>
    8596:	00 20       	and	r0, r0
    8598:	d9 f7       	brne	.-10     	; 0x8590 <strchr_P+0x2>
    859a:	c0 01       	movw	r24, r0
    859c:	08 95       	ret
    859e:	31 97       	sbiw	r30, 0x01	; 1
    85a0:	cf 01       	movw	r24, r30
    85a2:	08 95       	ret

000085a4 <strrev>:
    85a4:	dc 01       	movw	r26, r24
    85a6:	fc 01       	movw	r30, r24
    85a8:	67 2f       	mov	r22, r23
    85aa:	71 91       	ld	r23, Z+
    85ac:	77 23       	and	r23, r23
    85ae:	e1 f7       	brne	.-8      	; 0x85a8 <strrev+0x4>
    85b0:	32 97       	sbiw	r30, 0x02	; 2
    85b2:	04 c0       	rjmp	.+8      	; 0x85bc <strrev+0x18>
    85b4:	7c 91       	ld	r23, X
    85b6:	6d 93       	st	X+, r22
    85b8:	70 83       	st	Z, r23
    85ba:	62 91       	ld	r22, -Z
    85bc:	ae 17       	cp	r26, r30
    85be:	bf 07       	cpc	r27, r31
    85c0:	c8 f3       	brcs	.-14     	; 0x85b4 <strrev+0x10>
    85c2:	08 95       	ret

000085c4 <fgetc>:
    85c4:	cf 93       	push	r28
    85c6:	df 93       	push	r29
    85c8:	ec 01       	movw	r28, r24
    85ca:	2b 81       	ldd	r18, Y+3	; 0x03
    85cc:	20 ff       	sbrs	r18, 0
    85ce:	33 c0       	rjmp	.+102    	; 0x8636 <fgetc+0x72>
    85d0:	26 ff       	sbrs	r18, 6
    85d2:	0a c0       	rjmp	.+20     	; 0x85e8 <fgetc+0x24>
    85d4:	2f 7b       	andi	r18, 0xBF	; 191
    85d6:	2b 83       	std	Y+3, r18	; 0x03
    85d8:	8e 81       	ldd	r24, Y+6	; 0x06
    85da:	9f 81       	ldd	r25, Y+7	; 0x07
    85dc:	01 96       	adiw	r24, 0x01	; 1
    85de:	9f 83       	std	Y+7, r25	; 0x07
    85e0:	8e 83       	std	Y+6, r24	; 0x06
    85e2:	8a 81       	ldd	r24, Y+2	; 0x02
    85e4:	90 e0       	ldi	r25, 0x00	; 0
    85e6:	29 c0       	rjmp	.+82     	; 0x863a <fgetc+0x76>
    85e8:	22 ff       	sbrs	r18, 2
    85ea:	0f c0       	rjmp	.+30     	; 0x860a <fgetc+0x46>
    85ec:	e8 81       	ld	r30, Y
    85ee:	f9 81       	ldd	r31, Y+1	; 0x01
    85f0:	80 81       	ld	r24, Z
    85f2:	99 27       	eor	r25, r25
    85f4:	87 fd       	sbrc	r24, 7
    85f6:	90 95       	com	r25
    85f8:	00 97       	sbiw	r24, 0x00	; 0
    85fa:	19 f4       	brne	.+6      	; 0x8602 <fgetc+0x3e>
    85fc:	20 62       	ori	r18, 0x20	; 32
    85fe:	2b 83       	std	Y+3, r18	; 0x03
    8600:	1a c0       	rjmp	.+52     	; 0x8636 <fgetc+0x72>
    8602:	31 96       	adiw	r30, 0x01	; 1
    8604:	f9 83       	std	Y+1, r31	; 0x01
    8606:	e8 83       	st	Y, r30
    8608:	0e c0       	rjmp	.+28     	; 0x8626 <fgetc+0x62>
    860a:	ea 85       	ldd	r30, Y+10	; 0x0a
    860c:	fb 85       	ldd	r31, Y+11	; 0x0b
    860e:	09 95       	icall
    8610:	97 ff       	sbrs	r25, 7
    8612:	09 c0       	rjmp	.+18     	; 0x8626 <fgetc+0x62>
    8614:	2b 81       	ldd	r18, Y+3	; 0x03
    8616:	01 96       	adiw	r24, 0x01	; 1
    8618:	11 f4       	brne	.+4      	; 0x861e <fgetc+0x5a>
    861a:	80 e1       	ldi	r24, 0x10	; 16
    861c:	01 c0       	rjmp	.+2      	; 0x8620 <fgetc+0x5c>
    861e:	80 e2       	ldi	r24, 0x20	; 32
    8620:	82 2b       	or	r24, r18
    8622:	8b 83       	std	Y+3, r24	; 0x03
    8624:	08 c0       	rjmp	.+16     	; 0x8636 <fgetc+0x72>
    8626:	2e 81       	ldd	r18, Y+6	; 0x06
    8628:	3f 81       	ldd	r19, Y+7	; 0x07
    862a:	2f 5f       	subi	r18, 0xFF	; 255
    862c:	3f 4f       	sbci	r19, 0xFF	; 255
    862e:	3f 83       	std	Y+7, r19	; 0x07
    8630:	2e 83       	std	Y+6, r18	; 0x06
    8632:	99 27       	eor	r25, r25
    8634:	02 c0       	rjmp	.+4      	; 0x863a <fgetc+0x76>
    8636:	8f ef       	ldi	r24, 0xFF	; 255
    8638:	9f ef       	ldi	r25, 0xFF	; 255
    863a:	df 91       	pop	r29
    863c:	cf 91       	pop	r28
    863e:	08 95       	ret

00008640 <ungetc>:
    8640:	fb 01       	movw	r30, r22
    8642:	23 81       	ldd	r18, Z+3	; 0x03
    8644:	20 ff       	sbrs	r18, 0
    8646:	12 c0       	rjmp	.+36     	; 0x866c <ungetc+0x2c>
    8648:	26 fd       	sbrc	r18, 6
    864a:	10 c0       	rjmp	.+32     	; 0x866c <ungetc+0x2c>
    864c:	8f 3f       	cpi	r24, 0xFF	; 255
    864e:	3f ef       	ldi	r19, 0xFF	; 255
    8650:	93 07       	cpc	r25, r19
    8652:	61 f0       	breq	.+24     	; 0x866c <ungetc+0x2c>
    8654:	82 83       	std	Z+2, r24	; 0x02
    8656:	2f 7d       	andi	r18, 0xDF	; 223
    8658:	20 64       	ori	r18, 0x40	; 64
    865a:	23 83       	std	Z+3, r18	; 0x03
    865c:	26 81       	ldd	r18, Z+6	; 0x06
    865e:	37 81       	ldd	r19, Z+7	; 0x07
    8660:	21 50       	subi	r18, 0x01	; 1
    8662:	31 09       	sbc	r19, r1
    8664:	37 83       	std	Z+7, r19	; 0x07
    8666:	26 83       	std	Z+6, r18	; 0x06
    8668:	99 27       	eor	r25, r25
    866a:	08 95       	ret
    866c:	8f ef       	ldi	r24, 0xFF	; 255
    866e:	9f ef       	ldi	r25, 0xFF	; 255
    8670:	08 95       	ret

00008672 <__eerd_block_m1284p>:
    8672:	dc 01       	movw	r26, r24
    8674:	cb 01       	movw	r24, r22

00008676 <__eerd_blraw_m1284p>:
    8676:	fc 01       	movw	r30, r24
    8678:	f9 99       	sbic	0x1f, 1	; 31
    867a:	fe cf       	rjmp	.-4      	; 0x8678 <__eerd_blraw_m1284p+0x2>
    867c:	06 c0       	rjmp	.+12     	; 0x868a <__eerd_blraw_m1284p+0x14>
    867e:	f2 bd       	out	0x22, r31	; 34
    8680:	e1 bd       	out	0x21, r30	; 33
    8682:	f8 9a       	sbi	0x1f, 0	; 31
    8684:	31 96       	adiw	r30, 0x01	; 1
    8686:	00 b4       	in	r0, 0x20	; 32
    8688:	0d 92       	st	X+, r0
    868a:	41 50       	subi	r20, 0x01	; 1
    868c:	50 40       	sbci	r21, 0x00	; 0
    868e:	b8 f7       	brcc	.-18     	; 0x867e <__eerd_blraw_m1284p+0x8>
    8690:	08 95       	ret

00008692 <__ctype_isfalse>:
    8692:	99 27       	eor	r25, r25
    8694:	88 27       	eor	r24, r24

00008696 <__ctype_istrue>:
    8696:	08 95       	ret

00008698 <_exit>:
    8698:	f8 94       	cli

0000869a <__stop_program>:
    869a:	ff cf       	rjmp	.-2      	; 0x869a <__stop_program>
